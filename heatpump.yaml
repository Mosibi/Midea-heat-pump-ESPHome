substitutions:
  devicename: heatpump
  description: Heatpump Controller
  device_description: ${description} YORK YKF09CNC 9kW Monoblock via Modbus protocol
  modbus_address: '11'
  hour_start_day: '7'
  hour_end_day: '19'
  month_start_summer: '5'
  month_end_summer: '9'
globals:
- id: unmasked_value_register_0
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_value_register_5
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_value_water_temperature_t1s
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_curve_selection
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_value_register_210
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_value_register_211
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_value_register_270
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: unmasked_value_register_272
  type: uint16_t
  restore_value: false
  initial_value: '0'
- id: manually_disabled_dhw_heating_timestamp
  type: int32_t
  restore_value: true
- id: manually_disabled_zone1_heating_timestamp
  type: int32_t
  restore_value: true
- id: manually_disabled_zone2_heating_timestamp
  type: int32_t
  restore_value: true
- id: timestamp_water_pump_timestamp_last_run
  type: int32_t
  restore_value: true
- id: tempereture_avg_last_hour
  type: float
  restore_value: true
- id: tempereture_avg_last_24h
  type: float
  restore_value: true
- id: relay1_start
  type: int32_t
  restore_value: true
- id: relay2_start
  type: int32_t
  restore_value: true
  initial_value: '0'
- id: external_temp_sensor_avg_rooms_temp_saved
  type: float
  restore_value: true
  initial_value: '0'
- id: Restore_enable_DHW
  type: bool
  initial_value: '1'
  restore_value: true
- id: Restore_enable_Zone1
  type: bool
  restore_value: true
  initial_value: '1'
- id: Restore_enable_Zone2
  type: bool
  restore_value: true
  initial_value: '1'
- id: Restore_time_dhw
  type: uint16_t
  restore_value: true
  initial_value: '180'
- id: Restore_time_zone1
  type: uint16_t
  restore_value: true
  initial_value: '190'
- id: Restore_time_zone2
  type: uint16_t
  restore_value: true
  initial_value: '200'
esphome:
  name: ${devicename}
  comment: ${device_description}
  friendly_name: ${description}
  project:
    name: null
    version: 4.1.2Y
esp32:
  board: wemos_d1_mini32
  framework:
    type: esp-idf
preferences:
  flash_write_interval: 60min
logger:
  level: INFO
api:
  encryption:
    key: null
  on_client_connected:
  - if:
      condition:
        lambda: return (0 == client_info.find("Home Assistant "));
      then:
      - light.turn_on:
          id: wifi_led
          effect: blink_slow1s
  on_client_disconnected:
  - if:
      condition:
        lambda: return (0 == client_info.find("Home Assistant "));
      then:
      - light.turn_on:
          id: wifi_led
          effect: blink_fast
web_server:
  port: 80
  log: true
  auth:
    username: null
    password: null
  include_internal: true
  version: 3
  local: true
ota:
  platform: esphome
  id: my_ota
  password: null
wifi:
  ssid: null
  password: null
  use_address: 10.48.18.61
  enable_on_boot: true
  power_save_mode: none
  on_connect:
    then:
    - light.turn_on:
        id: wifi_led
        effect: blink_slow
  on_disconnect:
    then:
      light.turn_off: wifi_led
  ap:
    ssid: ${devicename}-setup
    password: null
captive_portal: null
uart:
  id: mod_bus
  tx_pin: GPIO3
  rx_pin: GPIO1
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1
modbus:
  id: heatpump_modbus
  send_wait_time: 500ms
  role: client
modbus_controller:
- id: ${devicename}
  address: ${modbus_address}
  modbus_id: heatpump_modbus
  setup_priority: -10
  update_interval: 30s
  offline_skip_updates: 0
output:
- platform: gpio
  pin: GPIO2
  id: blue_led
  inverted: false
light:
- platform: binary
  id: wifi_led
  output: blue_led
  internal: true
  icon: mdi:led-on
  entity_category: diagnostic
  effects:
  - strobe:
      name: blink_slow1s
      colors:
      - state: true
        duration: null
      - state: false
        duration: null
  - strobe:
      name: blink_slow
      colors:
      - state: true
        duration: null
      - state: false
        duration: null
  - strobe:
      name: blink_fast
      colors:
      - state: true
        duration: null
      - state: false
        duration: null
time:
- platform: homeassistant
  id: esptime
  on_time_sync:
    then:
    - logger.log: Synchronized System Clock from HomeAssisatnt
interval:
- interval: 1min
  then:
  - lambda: "if (!id(esptime).is_failed()) {\n  //Check at start if dhw or heat/cool\
      \ zone 1&2 is disabled\n  if (!id(${devicename}_power_dhw_t5s).state and id(manually_disabled_dhw_heating_timestamp)\
      \ == 0 and id(Restore_enable_DHW)==1) id(manually_disabled_dhw_heating_timestamp)\
      \ = id(esptime).now().timestamp;\n  if (!id(${devicename}_power_heat_cool_control_zone1).state\
      \ and id(manually_disabled_zone1_heating_timestamp) == 0 and id(Restore_enable_Zone1)==1)\
      \ id(manually_disabled_zone1_heating_timestamp) = id(esptime).now().timestamp;;\n\
      \  if (!id(${devicename}_power_heat_cool_control_zone2).state and id(manually_disabled_zone2_heating_timestamp)\
      \ == 0 and id(Restore_enable_Zone2)==1) id(manually_disabled_zone2_heating_timestamp)\
      \ = id(esptime).now().timestamp;;\n  //check when dhw or zone1 or zone2 heat\
      \ is disabled -enable if timer to enable elapsed\n  int32_t duration_dhw_timer_elapsed\
      \ = 0;\n  ESP_LOGI(\"interval_time_1min\",\"DHW parse: id(manually_disabled_dhw_heating_timestamp)\
      \ %i\", id(manually_disabled_dhw_heating_timestamp));\n  if (id(manually_disabled_dhw_heating_timestamp)\
      \ > 0 and id(Restore_enable_DHW)) {\n    duration_dhw_timer_elapsed = id(esptime).now().timestamp\
      \ - id(manually_disabled_dhw_heating_timestamp);\n    if (duration_dhw_timer_elapsed\
      \ > (id(${devicename}_restore_time_heat_dhw_after_turn_off).state * 60)) {\n\
      \      id(${devicename}_power_dhw_t5s).turn_on();\n      ESP_LOGI(\"interval_time_1min\"\
      , \"Enable DHW Heating\");\n    }\n  }\n  int32_t duration_zone1_timer_elapsed\
      \ = 0;\n  if (id(manually_disabled_zone1_heating_timestamp) > 0 and id(Restore_enable_Zone1)==1)\
      \ {\n    duration_zone1_timer_elapsed = id(esptime).now().timestamp - (int32_t)id(manually_disabled_zone1_heating_timestamp);\n\
      \    if (duration_zone1_timer_elapsed > (id(${devicename}_restore_time_heat_zone1_after_turn_off).state\
      \ * 60)) {\n      id(${devicename}_power_heat_cool_control_zone1).turn_on();\n\
      \      ESP_LOGI(\"interval_time_1min\", \"Enable Zone1 Heating/cooling\");\n\
      \    }\n  }\n  int32_t duration_zone2_timer_elapsed = 0;\n  if (id(manually_disabled_zone2_heating_timestamp)\
      \ > 0 and id(Restore_enable_Zone2)==1) {\n    duration_zone2_timer_elapsed =\
      \ id(esptime).now().timestamp - (int32_t)id(manually_disabled_zone2_heating_timestamp);\n\
      \    if (duration_zone2_timer_elapsed > (id(${devicename}_restore_time_heat_zone2_after_turn_off).state\
      \ * 60)) {\n      id(${devicename}_power_heat_cool_control_zone2).turn_on();\n\
      \      ESP_LOGI(\"interval_time_1min\", \"Enable Zone2 Heating/cooling\");\n\
      \    }\n  }\n\n  //Secure heatpump from pipe freeze -if pump_i don't run in\
      \ last hour start external pump for eg. 5 minutes and add when load PUMP_I is\
      \ active disable relay\n  float ext_t4_temp = id(${devicename}_outdoor_ambient_temperature).state;\n\
      \  bool pump_i_status = id(${devicename}_load_output_water_pump_pump_i).state;\n\
      \  int32_t duration_pump_i_lastrun = 0;\n  ESP_LOGI(\"interval_time_1min\",\"\
      PUMP_I last run now:%li, pump_ts %i, duration: %i, outside temp %f\", id(esptime).now().timestamp,\
      \ id(timestamp_water_pump_timestamp_last_run), duration_pump_i_lastrun, ext_t4_temp);\n\
      \  if (id(timestamp_water_pump_timestamp_last_run) > 0) {\n    duration_pump_i_lastrun\
      \ = id(esptime).now().timestamp - id(timestamp_water_pump_timestamp_last_run);\n\
      \    if (duration_pump_i_lastrun > ((int32_t)id(${devicename}_pump_i_antifrize_check_last_run_interval).state\
      \ * 60) and !pump_i_status and ext_t4_temp < float(id(${devicename}_temp_secure_antifreeze).state)\
      \ ) {\n      //start external relay if pump_i not active in last hour with external\
      \ temp under declared val\n      ESP_LOGI(\"time start relay pump\",\"PROCEDURE\
      \ START RELAY PUMP\");\n      id(${devicename}_relay1_external_pump).turn_on();\
      \  //#################\n      id(${devicename}_relay2_external_pump).turn_on();\
      \   //###################\n    }\n  }\n  //check how long external switch was\
      \ on -if more than 5 minutes -turn off\n  int32_t duration_relay1_active = id(esptime).now().timestamp\
      \ - (int32_t)id(relay1_start);\n  if (duration_relay1_active > (id(${devicename}_output_external_pump_for_antifreeze_relay1).state\
      \ * 60) and id(relay1_start) > 0) {\n    ESP_LOGI(\"interval_time_1min relay\"\
      ,\"Relay1 Stops %um\", duration_relay1_active);\n    id(${devicename}_relay1_external_pump).turn_off();\
      \   //#########################\n  }\n  int32_t duration_relay2_active = id(esptime).now().timestamp\
      \ - (int32_t)id(relay2_start);\n  if (duration_relay2_active > (id(${devicename}_external_relay_timer).state\
      \ * 60) and id(relay2_start) > 0) {\n    ESP_LOGI(\"interval_time_1min_relay\"\
      ,\"Relay2 Stops %u\", duration_relay2_active);\n    id(${devicename}_relay2_external_pump).turn_off();\
      \   //#################\n  }\n}"
- interval: 60min
  then:
  - lambda: "if (!id(esptime).is_failed()) {\n  //calculate curve and set T1s\n  //${devicename}_temperature_t1s_zone1\
      \      set_water_temperature_t1s_zone_1\n  auto operation_state = id(${devicename}_operational_mode).state;\n\
      \  ESP_LOGI(\"interval_time_30min\", \"Setting temp for mode .%s. compare: %s\"\
      , operation_state.c_str(), (operation_state == \"Cool\")?\"YES\":\"NO\");\n\n\
      \  //calculae curve\n  float ext_t4_temp = id(${devicename}_outdoor_ambient_temperature).state;\n\
      \  float calculated_temp = 35;\n  float avg_temp;\n  if (${devicename}_outdoor_ambient_temperature_daily\
      \ != 0) {\n    avg_temp = id(${devicename}_outdoor_ambient_temperature_daily).state;\n\
      \  } else if (${devicename}_outdoor_ambient_temperature_hourly != 0) {\n   \
      \ avg_temp = id(${devicename}_outdoor_ambient_temperature_hourly).state;\n \
      \ } else avg_temp = id(${devicename}_outdoor_ambient_temperature).state;\n \
      \ // Arduino map implementation \n  // Long map(long xx, long in_min, long in_max,\
      \ long out_min, long out_max){\n  // Rreturn (xx - in_min) * (out_max - out_min)\
      \ / (in_max - in_min) + out_min;}\n  float xx, in_min, in_max, out_min, out_max;\n\
      \  // float temp_floorheat = map(avg_temp, -20, 15, 50, 25); //zmapuj zakres\
      \ zewnatrz gdy -20 to grzej 50 a gdy zewnatrz 15 grzej 15\n  xx = avg_temp;\n\
      \  in_min = -20;\n  in_max = 15;\n  out_min = 50;\n  out_max = 25;\n  float\
      \ temp_floorheat = (xx - in_min) * (out_max - out_min) / (in_max - in_min) +\
      \ out_min;\n  xx = temp_floorheat;\n  in_min = 50;\n  in_max = 25;\n  out_min\
      \ = 50;\n  out_max = 35;\n  // calculated_temp = map(temp_floorheat, 50, 25,\
      \ 50, 35);\n  calculated_temp = (xx - in_min) * (out_max - out_min) / (in_max\
      \ - in_min) + out_min;\n\n  if (calculated_temp < 30) calculated_temp = 28;\n\
      \  calculated_temp *= 0.2;\n  ESP_LOGI(\"interval_time_30min\", \"Calculated\
      \ curve for heating my without room temps is %f\", calculated_temp);\n  id(${devicename}_calculated_curve).publish_state(calculated_temp);\n\
      \n\n  float baseTemp = calculated_temp; // Flow temperature at 0\xB0C outdoor\n\
      \  float tempChangePerDegree = 1.0; // Flow temperature increase per degree\
      \ drop in outdoor temperature\n  // Calculate temperature difference from desired\
      \ room temperature\n  float tempDifference = 22.0 - float(id(${devicename}_external_temp_sensor_avg_rooms_temp).state);\
      \    //22 is wanted room temp\n  if (avg_temp < 0) {\n    calculated_temp =\
      \ baseTemp + (-avg_temp) * tempChangePerDegree + (tempDifference * 1.5);\n \
      \ } else {\n    calculated_temp = baseTemp - avg_temp * (tempChangePerDegree\
      \ / 2) + (tempDifference * 1.5);\n  }\n\n  // float temp_floorheat = map(srednia,\
      \ -20, 15, 50, 25); //zmapuj zakres zewnatrz gdy -20 to grzej 50 a gdy zewnatrz\
      \ 15 grzej 15\n  // float setT1STempZone1 = map(temp_floorheat, 50, 25, 50,\
      \ 35);\n  // *0.2\n  ESP_LOGI(\"interval_time_30min\", \"Calculated curve for\
      \ heating is %f\", calculated_temp);\n  id(${devicename}_calculated_curve2).publish_state(calculated_temp);\n\
      \  // Arduino map implementation\n  xx = id(${devicename}_external_temp_sensor_avg_rooms_temp).state;\n\
      \  in_min = 19.5;\n  in_max = 22;\n  out_min = 45;\n  out_max = 28;        \
      \            \n  float temp_curve = (xx - in_min) * (out_max - out_min) / (in_max\
      \ - in_min) + out_min;\n  // float temp_curve = map(id(${devicename}_external_temp_sensor_avg_rooms_temp).state,\
      \ 19.5, 22, 45, 28);\n\n  calculated_temp = temp_curve;\n  ESP_LOGI(\"interval_time_30min\"\
      , \"Calculated curve 3 for heating is %f\", temp_curve);\n  id(${devicename}_calculated_curve3).publish_state(temp_curve);\n\
      \n\n  // Set Heating/Cooling temp of Zone 1 calculated\n  if (operation_state\
      \ == \"Cool\") {\n    auto t1s_zone_1 = id(${devicename}_set_water_temperature_t1s_zone_1).make_call();\n\
      \    t1s_zone_1.set_value(5);\n    t1s_zone_1.perform(); \n    ESP_LOGI(\"interval_time_30min\"\
      , \"Setting temp for Cool mode %d\", 5);\n  } else if (operation_state == \"\
      Heat\" or operation_state == \"Auto\") {\n    auto t1s_zone_1 = id(${devicename}_set_water_temperature_t1s_zone_1).make_call();\n\
      \    if (calculated_temp < 29) calculated_temp = 29;\n    t1s_zone_1.set_value(calculated_temp);\n\
      \    t1s_zone_1.perform();\n    ESP_LOGI(\"interval_time_30min\", \"Setting\
      \ temp for Heat mode %f Out Temp %f\", calculated_temp, ext_t4_temp);\n  }\n\
      }"
- interval: 120min
  then:
  - lambda: "//change parameters to summer mode -months 5-9\nbool essential_changed\
      \ = false;\nfloat new_delta_dhw_day = 6;\n//save statuses of heating dhw and\
      \ zones\nbool dhwstate = id(${devicename}_power_dhw_t5s).state;\nbool zone1state\
      \ = id(${devicename}_power_heat_cool_control_zone1).state;\nbool zone2state\
      \ = id(${devicename}_power_heat_cool_control_zone2).state;\nESP_LOGI(\"interval_delta\"\
      , \"now.month: %i, month_start_summer: %i, month_end_summer: %i comp month>=month_start:\
      \ %s, id(esptime).now().month <= month_end_summer %s\", id(esptime).now().month,\
      \ ${month_start_summer}, ${month_end_summer}, (id(esptime).now().month >= ${month_start_summer})?\"\
      Yes\":\"No\", id(esptime).now().month <= ${month_end_summer}?\"Yes\":\"No\"\
      );\nif (id(esptime).now().month >= ${month_start_summer} and id(esptime).now().month\
      \ <= ${month_end_summer}) {\n  //change from heat to cool don't stop heatpump\n\
      \  auto m1_mode = id( ${devicename}_operational_mode).make_call();\n  m1_mode.set_option(\"\
      Cool\");\n  m1_mode.perform();\n  ESP_LOGE(\"interval_time_1h_1\",\"Enable Summer\
      \ Mode -change behavior to COOLING for summertime and update deltas\");\n  //heatpump\
      \ stop after: dt1s5 dt1sh dtsh dtsc\n  float new_delta = 7.0F;\n  if (id(${devicename}_dt1s5).state\
      \ != new_delta) {\n    auto delta_dt1s5 = id(${devicename}_dt1s5).make_call();\n\
      \    delta_dt1s5.set_value(new_delta);\n    delta_dt1s5.perform();\n    essential_changed\
      \ = true;\n  }\n  if (id(${devicename}_dt1sh).state != new_delta) {\n    auto\
      \ delta_dt1sh = id(${devicename}_dt1sh).make_call();\n    delta_dt1sh.set_value(new_delta);\n\
      \    delta_dt1sh.perform();\n    essential_changed = true;\n  }\n  if (id(${devicename}_dtsh).state\
      \ != new_delta) {\n    auto delta_dtsh = id(${devicename}_dtsh).make_call();\n\
      \    delta_dtsh.set_value(new_delta);\n    delta_dtsh.perform();\n    essential_changed\
      \ = true;\n  }\n  if (id(${devicename}_dtsc).state != new_delta) {\n    auto\
      \ delta_dtsc = id(${devicename}_dtsc).make_call();\n    delta_dtsc.set_value(new_delta);\n\
      \    delta_dtsc.perform();\n    essential_changed = true;\n  }\n  new_delta_dhw_day\
      \ = 5;\n}\n//change parameters to winter mode -months 1-4 and 10-12\nESP_LOGI(\"\
      interval_delta\", \"now.month: %i, month_start_summer: %i, month_end_summer:\
      \ %i comp month<month_start: %s, id(esptime).now().month > month_end_summer\
      \ %s\", id(esptime).now().month, ${month_start_summer}, ${month_end_summer},\
      \ (id(esptime).now().month < ${month_start_summer})?\"Yes\":\"No\", id(esptime).now().month\
      \ > ${month_end_summer}?\"Yes\":\"No\");\nif (id(esptime).now().month < ${month_start_summer}\
      \ or id(esptime).now().month > ${month_end_summer}) {\n  //change from heat\
      \ to cool don't stop heatpump\n  auto m1_mode = id( ${devicename}_operational_mode).make_call();\n\
      \  m1_mode.set_option(\"Heat\");\n  m1_mode.perform();\n  ESP_LOGE(\"interval_time_1h_1\"\
      ,\"Enable Winter Mode -change behavior to HEATING and update deltas\");\n  //heatpump\
      \ stop after: dt1s5 dt1sh dtsh dtsc\n  float new_delta = 5.0F;\n  if (id(${devicename}_dt1s5).state\
      \ != new_delta) {\n    auto delta_dt1s5 = id(${devicename}_dt1s5).make_call();\n\
      \    delta_dt1s5.set_value(new_delta);\n    delta_dt1s5.perform();\n    essential_changed\
      \ = true;\n  }\n  if (id(${devicename}_dt1sh).state != new_delta) {\n    auto\
      \ delta_dt1sh = id(${devicename}_dt1sh).make_call();\n    delta_dt1sh.set_value(new_delta);\n\
      \    delta_dt1sh.perform();\n    essential_changed = true;\n  }\n  if (id(${devicename}_dtsh).state\
      \ != new_delta) {\n    auto delta_dtsh = id(${devicename}_dtsh).make_call();\n\
      \    delta_dtsh.set_value(new_delta);\n    delta_dtsh.perform();\n    essential_changed\
      \ = true;\n  }\n  if (id(${devicename}_dtsc).state != new_delta) {\n    auto\
      \ delta_dtsc = id(${devicename}_dtsc).make_call();\n    delta_dtsc.set_value(new_delta);\n\
      \    delta_dtsc.perform();\n    essential_changed = true;\n  }\n  new_delta_dhw_day\
      \ = 7;\n}\n//set delta DHW to 5degree for day\n//changing delta disables heatpump\n\
      float actual_delta_dhw = id(${devicename}_dt5_on).state;\n//for winter return\
      \ delta 7, for summer delta 5\nif (id(esptime).now().hour >= ${hour_start_day}\
      \ and id(esptime).now().hour <= ${hour_end_day}) {\n  if (actual_delta_dhw !=\
      \ new_delta_dhw_day ) {\n    auto delta__dt5_on = id(${devicename}_dt5_on).make_call();\n\
      \    delta__dt5_on.set_value(new_delta_dhw_day);\n    delta__dt5_on.perform();\n\
      \    essential_changed = true;\n  }\n  id(${devicename}_power_dhw_t5s).turn_on();\n\
      \  \n  ESP_LOGE(\"interval_time_1h_1_delta\",\"Changed delta T5s for DHW at\
      \ day to: %f\", new_delta_dhw_day);\n} else if (id(esptime).now().hour < ${hour_start_day}\
      \ or id(esptime).now().hour > ${hour_end_day}  ) {\n  //set delta DHW to reach\
      \ minimum wanted DHW temp to allow drop at night\n  //CHANGE DELTA FOR DHW WATER\
      \ HEATING to ~32deg for night (Actual set DHW temp to which is heated - minimal\
      \ accepted temp for DHW + 1)\n  float new_delta_night = (float(id(${devicename}_set_dhw_tank_temperature_t5s).state)\
      \ - float(id(${devicename}_gl_dhw_minimal_temp).state) + 1);\n  if (actual_delta_dhw\
      \ != new_delta_night) {\n    // auto delta__dt5_on = id(${devicename}_dt5_on).make_call();\n\
      \    // delta__dt5_on.set_value(new_delta_night);\n    // delta__dt5_on.perform();\n\
      \    // essential_changed = true;\n    ESP_LOGE(\"interval_time_1h_1\",\"Changed\
      \ delta T5s for DHW at night to: %f\", new_delta_night);\n  }\n  id(${devicename}_power_dhw_t5s).turn_off();\n\
      }\n// Neccesserry default values turn on\n// Maybe: Make heat pump silent at\
      \ night between 22 and 6 am  YorkM5functionMOde   bitSet(tmptemp, 6);    //SilentMode\
      \              bitClear(tmptemp, 7);  //SuperSilent\n// I use only zone 1 -actually\
      \ this is buffer -not directly to radiators -this is much better choice, in\
      \ cooling i cool buffer. Enabling air conditioner is different functionallity\
      \ ;(\n// After setting any of values below heat pump turn off heating/cooling\n\
      if (!id(${devicename}_p_s_1_heating_and_cooling_first_or_water_first).state)\
      \ {\n  id(${devicename}_p_s_1_heating_and_cooling_first_or_water_first).publish_state(true);\n\
      \  essential_changed = true;\n  ESP_LOGI(\"interval_time_1h_2\", \"Set p_s_1_heating_and_cooling_first_or_water_first\"\
      );\n}\nif (!id(${devicename}_p_s_1_enable_heating).state) {\n  id(${devicename}_p_s_1_enable_heating).publish_state(true);\n\
      \  essential_changed = true;\n  ESP_LOGI(\"interval_time_1h_2\", \"Set p_s_1_enable_heating\"\
      );\n}\nif (!id(${devicename}_p_s_1_enable_cooling).state) {\n  id(${devicename}_p_s_1_enable_cooling).publish_state(true);\n\
      \  essential_changed = true;\n  ESP_LOGI(\"interval_time_1h_2\", \"Set p_s_1_enable_cooling\"\
      );\n}\nif (!id(${devicename}_p_s_1_enable_water_heating).state) {\n  id(${devicename}_p_s_1_enable_water_heating).publish_state(true);\n\
      \  essential_changed = true;\n  ESP_LOGI(\"interval_time_1h_2\", \"Set p_s_1_enable_water_heating\"\
      );\n}\n//#update heat and cool end for zone 1 -i use buffer to cool so I need\
      \ to set for cool \"Fan Coil Unit\" which enables temp range 5-25 degree\nauto\
      \ zone1_cooling_end_state = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;\n\
      if (zone1_cooling_end_state != \"Fan Coil Unit\") {\n  auto zone1_cooling_end\
      \ = id(${devicename}_zone_1_end_cooling_mode_emission_type).make_call();\n \
      \ zone1_cooling_end.set_option(\"Fan Coil Unit\");\n  zone1_cooling_end.perform();\n\
      \  essential_changed = true;\n  ESP_LOGI(\"interval_time_1h_2\", \"Set Zone\
      \ 1 Cooling to Fan Coil Unit was: %s\", zone1_cooling_end_state.c_str());\n\
      }\n//#Radiator and Fan Coil Unit enables temp range 35 to 65degree i want below\
      \ 35 ;)\nauto zone1_heating_end_state = id(${devicename}_zone_1_end_heating_mode_emission_type).state;\n\
      if (zone1_heating_end_state != \"Underfloor Heating\") {\n  auto zone1_heating_end\
      \ = id(${devicename}_zone_1_end_heating_mode_emission_type).make_call();\n \
      \ zone1_heating_end.set_option(\"Underfloor Heating\");\n  zone1_heating_end.perform();\n\
      \  essential_changed = true;\n  ESP_LOGI(\"interval_time_1h_2\", \"Set Zone\
      \ 1 heating to Underfloor Heating was: %s\", zone1_heating_end_state.c_str());\n\
      }\nif (essential_changed) {\n  delay(1500);\n  //some essential parameter was\
      \ chanagedd so Heat pump disable heat -so enable it now -this is not manual\
      \ disable\n  if (dhwstate) id(${devicename}_power_dhw_t5s).turn_on();\n  if\
      \ (zone1state) id(${devicename}_power_heat_cool_control_zone1).turn_on();\n\
      \  if (zone2state) id(${devicename}_power_heat_cool_control_zone2).turn_on();\n\
      \  ESP_LOGE(\"interval_time_1h_1\", \"ReEnable %s%s%s Heat/Cool after change\
      \ essentials (enable heating/cooling/DHW/DHW first/change emmissions...etc)\"\
      , id(Restore_enable_DHW)?\"DHW\":\"\", id(Restore_enable_Zone1)?\" and Zone1\"\
      :\"\", id(Restore_enable_Zone2)?\" and Zone2\":\"\");\n}"
button:
- platform: restart
  name: Restart
  id: ${devicename}_restart
  icon: mdi:lock-reset
  entity_category: diagnostic
- platform: factory_reset
  name: Restart with Controller Factory Default Settings -not Heat Pump
  id: ${devicename}_factory_reset_and_restart
  icon: mdi:lock-reset
  entity_category: diagnostic
select:
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Operational Mode
  id: ${devicename}_operational_mode
  icon: mdi:fan
  address: 1
  value_type: U_WORD
  optimistic: true
  optionsmap:
    Heat: 3
    Cool: 2
    Auto: 1
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Power Input Limitation to
  id: ${devicename}_power_input_limitation_type
  icon: mdi:state-machine
  address: 269
  value_type: U_WORD
  optimistic: true
  optionsmap:
    None: 0
    '1': 1
    '2': 2
    '3': 3
    '4': 4
    '5': 5
    '6': 6
    '7': 7
    '8': 8
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Zone 1 End Heating Mode Emission Type
  id: ${devicename}_zone_1_end_heating_mode_emission_type
  icon: mdi:heat-wave
  address: 272
  value_type: U_WORD
  optimistic: true
  optionsmap:
    Fan Coil Unit: 0
    Radiator: 1
    Underfloor Heating: 2
  lambda: "// Update the global var unmasked_value_register_272\nid(unmasked_value_register_272)\
    \ = x;\n// ESP_LOGI(\"Register 272\",\"unmasked_value_register_272: %d\",id(unmasked_value_register_272));\n\
    // Extracting 4-bit values\nuint8_t zone1_h_emission = x & 0xF;\n// ESP_LOGI(\"\
    Register 272\",\"zone1_h_emission is %d\"zone2_h_emission);\n// Map/dictionary\
    \ with the possible values\nstd::string string_result;\nif (zone1_h_emission ==\
    \ 0) {\n  string_result = \"Fan Coil Unit\";\n} else if (zone1_h_emission == 1)\
    \ {\n  string_result = \"Radiator\";\n} else if (zone1_h_emission == 2) {\n  string_result\
    \ = \"Underfloor Heating\";\n} else {\n  string_result = \"Unknown: \";\n  string_result\
    \ += std::to_string(zone1_h_emission);\n}\nreturn string_result;"
  write_lambda: 'ESP_LOGI("Register 272", "zone1_h_emission Set option to %s (%lld)",
    x.c_str(), value);

    uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked
    value

    uint8_t value_byte = value;                            // New byte value with
    the heating emission type for zone 1

    new_value &= 0xFFF0;     // Clear the first 4 bits

    new_value |= value_byte; // Set the first 4 bits with the new value

    // ESP_LOGD("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272),
    new_value);

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x110, new_value);

    ${devicename}->queue_command(set_payload_command);

    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Zone 2 End Heating Mode Emission Type
  id: ${devicename}_zone_2_end_heating_mode_emission_type
  icon: mdi:heat-wave
  address: 272
  value_type: U_WORD
  optimistic: true
  optionsmap:
    Fan Coil Unit: 0
    Radiator: 1
    Underfloor Heating: 2
  lambda: "// Updating the global var unmasked_value_register_272 is already done\n\
    // in the first part of this register\n// ESP_LOGI(\"\",\"unmasked_value_register_272:\
    \ %d\",id(unmasked_value_register_272));\n// Extracting 4-bit values\nuint8_t\
    \ zone2_h_emission = (x >> 4) & 0xF;\n// ESP_LOGI(\"Register 272\",\"zone2_h_emission\
    \ is %d\", zone2_h_emission);\n// Map/dictionary with the possible values\nstd::string\
    \ string_result;\nif (zone2_h_emission == 0) {\n  string_result = \"Fan Coil Unit\"\
    ;\n} else if (zone2_h_emission == 1) {\n  string_result = \"Radiator\";\n} else\
    \ if (zone2_h_emission == 2) {\n  string_result = \"Underfloor Heating\";\n} else\
    \ {\n  string_result = \"Unknown: \";\n  string_result += std::to_string(zone2_h_emission);\n\
    }\nreturn string_result;"
  write_lambda: 'ESP_LOGI("Register 272", "zone2_h_emission Set option to %s (%lld)",
    x.c_str(), value);

    uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked
    value

    uint8_t value_byte = value;                            // New byte value with
    the heating emission type for zone 2

    new_value &= 0xFF0F;             // Clear the second pair of 4 bits

    new_value |= (value_byte << 4);  // Set the second pair of 4 bits with the new
    value

    // ESP_LOGI("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272),
    new_value);

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x110, new_value);

    ${devicename}->queue_command(set_payload_command);

    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Zone 1 End Cooling Mode Emission Type
  id: ${devicename}_zone_1_end_cooling_mode_emission_type
  icon: mdi:heat-wave
  address: 272
  value_type: U_WORD
  optimistic: true
  optionsmap:
    Fan Coil Unit: 0
    Radiator: 1
    Underfloor Heating: 2
  lambda: "// Updating the global var unmasked_value_register_272 is already done\n\
    // in the first part of this register\n// ESP_LOGI(\"\",\"unmasked_value_register_272:\
    \ %d\",id(unmasked_value_register_272));\n// Extracting 4-bit values\nuint8_t\
    \ zone1_c_emission = (x >> 8) & 0xF;\n// ESP_LOGD(\"Register 272\",\"zone1_c_emission\
    \ is %d\", zone1_c_emission);\n// Map/dictionary with the possible values\nstd::string\
    \ string_result;\nif (zone1_c_emission == 0) {\n  string_result = \"Fan Coil Unit\"\
    ;\n} else if (zone1_c_emission == 1) {\n  string_result = \"Radiator\";\n} else\
    \ if (zone1_c_emission == 2) {\n  string_result = \"Underfloor Heating\";\n} else\
    \ {\n  string_result = \"Unknown: \";\n  string_result += std::to_string(zone1_c_emission);\n\
    }\nreturn string_result;"
  write_lambda: 'ESP_LOGI("Register 272", "zone1_c_emission Set option to %s (%lld)",
    x.c_str(), value);

    uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked
    value

    uint8_t value_byte = value;                            // New byte value with
    the cooling emission type for zone 1

    new_value &= 0xF0FF;             // Clear the third pair of 4 bits

    new_value |= (value_byte << 8);  // Set the third pair of 4 bits with the new
    value

    // ESP_LOGI("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272),
    new_value);

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x110, new_value);

    ${devicename}->queue_command(set_payload_command);

    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Zone 2 End Cooling Mode Emission Type
  id: ${devicename}_zone_2_end_cooling_mode_emission_type
  icon: mdi:heat-wave
  address: 272
  value_type: U_WORD
  optimistic: true
  optionsmap:
    Fan Coil Unit: 0
    Radiator: 1
    Underfloor Heating: 2
  lambda: "// Updating the global var unmasked_value_register_272 is already done\n\
    // in the first part of this register\n// ESP_LOGI(\"Register 272\",\"unmasked_value_register_272:\
    \ 0x%x\", id(unmasked_value_register_272);\nid(unmasked_value_register_272) =\
    \ x;\n// Extracting 4-bit values\nuint8_t zone2_c_emission = (x >> 12) & 0xF;\n\
    // ESP_LOGI(\"Register 272\",\"zone2_c_emission is %d\", zone2_c_emission);\n\
    // Map/dictionary with the possible values\nstd::string string_result;\nif (zone2_c_emission\
    \ == 0) {\n  string_result = \"Fan Coil Unit\";\n} else if (zone2_c_emission ==\
    \ 1) {\n  string_result = \"Radiator\";\n} else if (zone2_c_emission == 2) {\n\
    \  string_result = \"Underfloor Heating\";\n} else {\n  string_result = \"Unknown:\
    \ \";\n  string_result += std::to_string(zone2_c_emission);\n}\nreturn string_result;"
  write_lambda: 'ESP_LOGI("Register 272", "zone2_c_emission Set option to %s (%lld)",
    x.c_str(), value);

    uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked
    value

    uint8_t value_byte = value;                            // New byte value with
    the cooling emission type for zone 2

    new_value &= 0x0FFF;              // Clear the fourth pair of 4 bits

    new_value |= (value_byte << 12);  // Set the fourth pair of 4 bits with the new
    value

    // ESP_LOGI("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272),
    new_value);

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x110, new_value);

    ${devicename}->queue_command(set_payload_command);

    return {};'
sensor:
- platform: homeassistant
  name: External Temp Sensor of avg Rooms temp
  id: ${devicename}_external_temp_sensor_avg_rooms_temp
  entity_id: sensor.wanas_m7_temp_pomieszcz_2
  internal: true
  unit_of_measurement: "\xB0C"
  icon: mdi:temperature-celsius
  on_value:
    then:
      lambda: '// Update the global var to save last read

        id(external_temp_sensor_avg_rooms_temp_saved) = x;'
- platform: uptime
  id: ${devicename}_uptime_sec
  name: Uptime
  unit_of_measurement: s
  icon: mdi:timelapse
  entity_category: diagnostic
  on_value:
    then:
    - text_sensor.template.publish:
        id: uptime_human
        state: null
- platform: wifi_signal
  name: WiFi Signal
  id: ${devicename}_wifi_signal
  update_interval: 60s
  entity_category: diagnostic
  icon: mdi:wifi
- platform: template
  name: SM Last time PUMP_I Run
  id: ${devicename}_water_pump_i_runtime
  entity_category: diagnostic
  unit_of_measurement: s
  icon: mdi:clock
  lambda: if (id(timestamp_water_pump_timestamp_last_run)==0) return 0; else return
    id(esptime).now().timestamp - id(timestamp_water_pump_timestamp_last_run);
- platform: template
  name: SM Recovery Heating DHW time in
  id: ${devicename}_recovery_heating_dhw_time_in
  entity_category: diagnostic
  unit_of_measurement: s
  icon: mdi:clock
  internal: true
  lambda: if (id(manually_disabled_dhw_heating_timestamp)==0 or id(Restore_enable_DHW)==false)
    {return 0;} else {return (id(${devicename}_restore_time_heat_dhw_after_turn_off).state
    * 60) - id(esptime).now().timestamp - id(manually_disabled_dhw_heating_timestamp);}
- platform: template
  name: SM Recovery Heating/Cooling Zone1 time in
  id: ${devicename}_recovery_heating_cooling_zone1_time_in
  entity_category: diagnostic
  unit_of_measurement: s
  icon: mdi:clock
  internal: true
  lambda: if (id(manually_disabled_zone1_heating_timestamp)==0 or id(Restore_enable_Zone1)==false)
    return 0; else return (id(${devicename}_restore_time_heat_zone1_after_turn_off).state
    * 60) - id(esptime).now().timestamp - id(manually_disabled_zone1_heating_timestamp);
- platform: template
  name: SM Recovery Heating/Cooling Zone2 time in
  id: ${devicename}_recovery_heating_cooling_zone2_time_in
  entity_category: diagnostic
  unit_of_measurement: s
  icon: mdi:clock
  internal: true
  lambda: if (id(manually_disabled_zone2_heating_timestamp)==0 or id(Restore_enable_Zone2)==false)
    return 0; else return (id(${devicename}_restore_time_heat_zone2_after_turn_off).state
    * 60) - id(esptime).now().timestamp - id(manually_disabled_zone2_heating_timestamp);
- platform: template
  name: SM Averange Hourly outside temp
  id: ${devicename}_outdoor_ambient_temperature_hourly
  icon: mdi:temperature-celsius
  unit_of_measurement: "\xB0C"
  accuracy_decimals: 1
  update_interval: never
  filters:
  - sliding_window_moving_average:
      window_size: 120
      send_every: 1
      send_first_at: 1
  on_value:
    then:
    - lambda: id(tempereture_avg_last_hour) = x;
- platform: template
  name: SM Averange Daily outside temp
  id: ${devicename}_outdoor_ambient_temperature_daily
  icon: mdi:temperature-celsius
  unit_of_measurement: "\xB0C"
  accuracy_decimals: 1
  update_interval: 30min
  lambda: 'return id(${devicename}_outdoor_ambient_temperature_hourly).state;

    '
  filters:
  - sliding_window_moving_average:
      window_size: 48
      send_every: 1
      send_first_at: 1
  on_value:
    then:
    - lambda: id(tempereture_avg_last_24h) = x;
- platform: template
  name: SM Calculated Curve
  id: ${devicename}_calculated_curve
  unit_of_measurement: "\xB0C"
  icon: mdi:temperature-celsius
- platform: template
  name: SM Calculated Curve2
  id: ${devicename}_calculated_curve2
  unit_of_measurement: "\xB0C"
  icon: mdi:temperature-celsius
- platform: template
  name: SM Calculated Curve3
  id: ${devicename}_calculated_curve3
  unit_of_measurement: "\xB0C"
  icon: mdi:temperature-celsius
- platform: template
  name: Activate DHW below this value
  id: ${devicename}_helper_activate_dhw_below_this_value
  unit_of_measurement: "\xB0C"
  icon: mdi:temperature-celsius
  update_interval: 30s
  lambda: return id(${devicename}_set_dhw_tank_temperature_t5s).state - id(${devicename}_dt5_on).state;
- platform: template
  name: Coefficient of Performance
  id: ${devicename}_coefficient_of_performance
  icon: mdi:copyleft
  accuracy_decimals: 2
  unit_of_measurement: COP
  lambda: "// Verify that electricity_consumption is <> 0 to avoid division by 0 error\n\
    if (id(${devicename}_electricity_consumption).state != 0) {\n  return id(${devicename}_power_output).state\
    \ / id(${devicename}_electricity_consumption).state;\n} else return {};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Register 0 switches
  id: ${devicename}_register_0_switches
  internal: true
  register_type: holding
  address: 0
  value_type: U_WORD
  icon: mdi:eye
  lambda: '// Update the global var unmasked_value_register_0

    id(unmasked_value_register_0) = x;

    return x;'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Air Temperature Ts
  id: ${devicename}_air_temperature_ts
  icon: mdi:temperature-celsius
  register_type: holding
  address: 3
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  filters:
  - multiply: 0.5
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: DHW Tank Temperature T5s
  id: ${devicename}_dhw_tank_temperature_t5s
  icon: mdi:temperature-celsius
  register_type: holding
  address: 4
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Register 5 switches
  id: ${devicename}_register_5_switches
  internal: true
  register_type: holding
  address: 5
  value_type: U_WORD
  icon: mdi:eye
  lambda: '// Update the global var unmasked_value_register_5

    id(unmasked_value_register_5) = x;

    return x;'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: t_SG_MAX or Reserved
  id: ${devicename}_t_sg_max
  icon: mdi:clock
  register_type: holding
  address: 10
  value_type: U_WORD
  unit_of_measurement: hr
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Compressor Operating Frequency
  id: ${devicename}_compressor_operating_frequency
  icon: mdi:sine-wave
  register_type: holding
  address: 100
  value_type: U_WORD
  unit_of_measurement: Hz
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Fan Speed
  id: ${devicename}_fan_speed
  icon: mdi:fan
  register_type: holding
  address: 102
  unit_of_measurement: r/min
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: PMV Openness
  id: ${devicename}_pmv_openness
  icon: mdi:valve
  register_type: holding
  address: 103
  value_type: U_WORD
  unit_of_measurement: '%'
  filters:
  - calibrate_linear:
    - 0 -> 0.0
    - 480 -> 100.0
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Water Inlet Temperature
  id: ${devicename}_water_inlet_temperature
  icon: mdi:temperature-celsius
  register_type: holding
  address: 104
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Water Outlet Temperature
  id: ${devicename}_water_outlet_temperature
  icon: mdi:temperature-celsius
  register_type: holding
  address: 105
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Condensor Temperature T3
  id: ${devicename}_condensor_temperature_t3
  icon: mdi:temperature-celsius
  register_type: holding
  address: 106
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Outdoor Ambient Temperature
  id: ${devicename}_outdoor_ambient_temperature
  icon: mdi:temperature-celsius
  register_type: holding
  address: 107
  unit_of_measurement: "\xB0C"
  value_type: S_WORD
  on_value:
    then:
      lambda: '//Send actual outside temp to calculate avg hourly

        id(${devicename}_outdoor_ambient_temperature_hourly).publish_state(x);'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Discharge Temperature
  id: ${devicename}_discharge_temperature
  icon: mdi:temperature-celsius
  register_type: holding
  address: 108
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Return Air Temperature
  id: ${devicename}_return_air_temperature
  icon: mdi:temperature-celsius
  register_type: holding
  address: 109
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Total Water Outlet Temperature T1
  id: ${devicename}_total_water_outlet_temperature_t1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 110
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: System Total Water Outlet Temperature T1B
  id: ${devicename}_system_total_water_outlet_temperature_t1b
  icon: mdi:temperature-celsius
  register_type: holding
  address: 111
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Refrigerant Liquid Side Temperature T2
  id: ${devicename}_refrigerant_liquid_side_temperature_t2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 112
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Refrigerant Gas Side Temperature T2B
  id: ${devicename}_refrigerant_gas_side_temperature_t2b
  icon: mdi:temperature-celsius
  register_type: holding
  address: 113
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Room Temperature Ta
  id: ${devicename}_room_temperature_ta
  icon: mdi:temperature-celsius
  register_type: holding
  address: 114
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Water Tank Temperature T5
  id: ${devicename}_water_tank_temperature_t5
  icon: mdi:thermometer-water
  register_type: holding
  address: 115
  unit_of_measurement: "\xB0C"
  value_type: S_WORD
  on_value_range:
  - below: null
    then:
    - switch.turn_on: ${devicename}_power_dhw_t5s
    - logger.log: TURN ON WATER HEATING -TEMP BELOW id(${devicename}_gl_dhw_minimal_temp).state=~32DEG
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Outdoor Unit High Pressure
  id: ${devicename}_outdoor_unit_high_pressure
  icon: mdi:car-brake-worn-linings
  register_type: holding
  address: 116
  value_type: U_WORD
  unit_of_measurement: kPA
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: ' Outdoor Unit Low Pressure'
  id: ${devicename}_outdoor_unit_low_pressure
  icon: mdi:car-brake-low-pressure
  register_type: holding
  address: 117
  value_type: U_WORD
  unit_of_measurement: kPA
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Outdoor Unit Current
  id: ${devicename}_outdoor_unit_current
  icon: mdi:alpha-a
  register_type: holding
  address: 118
  value_type: U_WORD
  unit_of_measurement: A
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Outdoor Unit Voltage
  id: ${devicename}_outdoor_unit_voltage
  icon: mdi:alpha-v
  register_type: holding
  address: 119
  value_type: U_WORD
  unit_of_measurement: V
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Hydraulic Module Current 1 or tbt1
  id: ${devicename}_hydraulic_module_current_1_tbt1
  icon: mdi:thermometer
  unit_of_measurement: "\xB0C"
  register_type: holding
  address: 120
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Hydraulic Module Current 2 or tbt2
  id: ${devicename}_hydraulic_module_current_2_tbt2
  icon: mdi:thermometer
  unit_of_measurement: "\xB0C"
  register_type: holding
  address: 121
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Compressor Operation Time
  id: ${devicename}_compressor_operation_time
  icon: mdi:av-timer
  register_type: holding
  address: 122
  value_type: U_WORD
  unit_of_measurement: hr
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Unit Capacity
  id: ${devicename}_unit_capacity
  icon: mdi:lightning-bolt-circle
  register_type: holding
  address: 123
  value_type: U_WORD
  unit_of_measurement: kWh
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Current Fault
  id: ${devicename}_current_fault
  icon: mdi:alert-circle
  register_type: holding
  entity_category: diagnostic
  address: 124
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Fault 1
  id: ${devicename}_fault_1
  icon: mdi:alert-circle
  register_type: holding
  entity_category: diagnostic
  address: 125
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Fault 2
  id: ${devicename}_fault_2
  icon: mdi:alert-circle
  register_type: holding
  entity_category: diagnostic
  address: 126
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Fault 3
  id: ${devicename}_fault_3
  icon: mdi:alert-circle
  register_type: holding
  entity_category: diagnostic
  address: 127
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Software Version
  id: ${devicename}_software_version
  icon: mdi:information
  register_type: holding
  address: 130
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Wired Controller Version Number
  id: ${devicename}_wired_controller_version_number
  icon: mdi:information
  register_type: holding
  address: 131
  value_type: U_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Compressor Target Frequency
  id: ${devicename}_compressor_target_frequency
  icon: mdi:sine-wave
  register_type: holding
  address: 132
  value_type: U_WORD
  unit_of_measurement: Hz
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: DC Bus Current
  id: ${devicename}_dc_bus_current
  icon: mdi:alpha-a
  register_type: holding
  address: 133
  value_type: U_WORD
  unit_of_measurement: A
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: DC Bus Voltage
  id: ${devicename}_dc_bus_voltage
  icon: mdi:alpha-v
  register_type: holding
  address: 134
  value_type: U_WORD
  unit_of_measurement: V
  filters:
  - multiply: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: TF module temperature
  id: ${devicename}_tf_module_temperature
  icon: mdi:temperature-celsius
  register_type: holding
  address: 135
  unit_of_measurement: "\xB0C"
  value_type: S_WORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Climate Curve T1S Calculated Value 1
  id: ${devicename}_climate_curve_t1s_calculated_value_1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 136
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Climate Curve T1S Calculated Value 2
  id: ${devicename}_climate_curve_t1s_calculated_value_2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 137
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Water Flow
  id: ${devicename}_water_flow
  icon: mdi:waves-arrow-right
  register_type: holding
  address: 138
  value_type: U_WORD
  unit_of_measurement: m3/H
  accuracy_decimals: 2
  filters:
  - lambda: return x * 0.01;
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Limit Scheme Of Outdoor Unit Current
  id: ${devicename}_limit_scheme_of_outdoor_unit_current
  icon: mdi:eye
  register_type: holding
  address: 139
  value_type: U_WORD
  unit_of_measurement: kW
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Ability Of Hydraulic Module
  id: ${devicename}_ability_of_hydraulic_module
  icon: mdi:lightning-bolt
  register_type: holding
  address: 140
  value_type: U_WORD
  unit_of_measurement: kW
  accuracy_decimals: 2
  filters:
  - lambda: return x * 0.01;
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Tsolar
  id: ${devicename}_tsolar
  icon: mdi:thermometer
  register_type: holding
  address: 141
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Electricity Consumption
  id: ${devicename}_electricity_consumption
  icon: mdi:lightning-bolt-outline
  register_type: holding
  unit_of_measurement: kWh
  device_class: energy
  state_class: total_increasing
  address: 143
  value_type: U_DWORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Power Output
  id: ${devicename}_power_output
  icon: mdi:lightning-bolt-outline
  register_type: holding
  unit_of_measurement: kWh
  device_class: energy
  state_class: total_increasing
  address: 145
  value_type: U_DWORD
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Upper Limit Of T1S Cooling Zone 1
  id: ${devicename}_temperature_upper_limit_of_t1s_cooling_zone_1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 201
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 255
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Upper Limit Of T1S Cooling Zone 2
  id: ${devicename}_temperature_upper_limit_of_t1s_cooling_zone_2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 201
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 65280
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Lower Limit Of T1S Cooling Zone 1
  id: ${devicename}_temperature_lower_limit_of_t1s_cooling_zone_1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 202
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 255
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Lower Limit Of T1S Cooling Zone 2
  id: ${devicename}_temperature_lower_limit_of_t1s_cooling_zone_2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 202
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 65280
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Upper Limit Of T1S Heating Zone 1
  id: ${devicename}_temperature_upper_limit_of_t1s_heating_zone_1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 203
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 255
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Upper Limit Of T1S Heating Zone 2
  id: ${devicename}_temperature_upper_limit_of_t1s_heating_zone_2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 203
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 65280
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Lower Limit Of T1S Heating Zone 1
  id: ${devicename}_temperature_lower_limit_of_t1s_heating_zone_1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 204
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 255
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Lower Limit Of T1S Heating Zone 2
  id: ${devicename}_temperature_lower_limit_of_t1s_heating_zone_2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 204
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  bitmask: 65280
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Upper Limit Of TS Setting
  id: ${devicename}_temperature_upper_limit_of_ts_setting
  icon: mdi:temperature-celsius
  register_type: holding
  address: 205
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  filters:
  - multiply: 0.5
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Lower Limit Of TS Setting
  id: ${devicename}_temperature_lower_limit_of_ts_setting
  icon: mdi:temperature-celsius
  register_type: holding
  address: 206
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  filters:
  - multiply: 0.5
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Upper Limit Of water Heating
  id: ${devicename}_temperature_upper_limit_of_water_heating
  icon: mdi:temperature-celsius
  register_type: holding
  address: 207
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Lower Limit Of Water Heating
  id: ${devicename}_temperature_lower_limit_of_water_heating
  icon: mdi:temperature-celsius
  register_type: holding
  address: 208
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Parameter Settings 1
  id: ${devicename}_parameter_settings_1
  icon: mdi:state-machine
  internal: true
  register_type: holding
  address: 210
  value_type: U_WORD
  lambda: '// Update the global var unmasked_value_register_210

    id(unmasked_value_register_210) = x;

    return x;'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Parameter Settings 2
  id: ${devicename}_parameter_settings_2
  icon: mdi:state-machine
  internal: true
  register_type: holding
  address: 211
  value_type: U_WORD
  lambda: '// Update the global var unmasked_value_register_211

    id(unmasked_value_register_211) = x;

    return x;'
- platform: template
  name: T1S DHW
  id: ${devicename}_t1s_dhw
  icon: mdi:thermometer
  unit_of_measurement: "\xB0C"
  lambda: 'int dt1s5 = id(${devicename}_dt1s5).state;

    int t5 = id(${devicename}_water_tank_temperature_t5).state;

    int t1s_dhw = t5 + dt1s5;

    return t1s_dhw;'
binary_sensor:
- platform: homeassistant
  name: MARM20 Pump Working Disable HeatPump from Heating and DHW
  entity_id: input_boolean.scene_daytime
  id: marm_pump_is_running_m20
  internal: true
  icon: mdi:eye
  on_state:
    then:
    - switch.turn_off: ${devicename}_power_dhw_t5s
    - logger.log: 'MARM20 HA Sensor: Disable DHW and Floor Heating on HeatPump....'
- platform: template
  name: F.S. Holiday Away
  id: ${devicename}_f_s_holiday_away
  icon: mdi:eye
  lambda: return (id(unmasked_value_register_5) & 0x20) == 0x20; //return status bit5
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Defrosting
  id: ${devicename}_status_bit_1_defrosting
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 2
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Anti Freezing
  id: ${devicename}_status_bit_1_anti_freezing
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 4
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Oil Return
  id: ${devicename}_status_bit_1_oil_return
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 8
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Remote On/Off
  id: ${devicename}_status_bit_1_remote_on_off
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 16
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Outdoor Unit Test Mode Mark
  id: ${devicename}_status_bit_1_outdoor_unit_test_mode_mark
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 32
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Heating Mode Set By Room Thermostat
  id: ${devicename}_status_bit_1_heating_mode_set_by_room_thermostat
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 64
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Cooling Mode Set By Room Thermostat
  id: ${devicename}_status_bit_1_cooling_mode_set_by_room_thermostat
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 128
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Solar Energy Signal Input
  id: ${devicename}_status_bit_1_solar_energy_signal_input
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 256
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Anti Freezing Operation For Water Tank
  id: ${devicename}_status_bit_1_anti_freezing_operation_for_water_tank
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 512
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 SG
  id: ${devicename}_status_bit_1_sg
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 1024
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 EUV
  id: ${devicename}_status_bit_1_euv
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 2048
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Request Serial Number Code
  id: ${devicename}_status_bit_1_request_serial_number_code
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 8192
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Request Software Version
  id: ${devicename}_status_bit_1_request_software_version
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 16384
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Status BIT 1 Request Operation Parameter
  id: ${devicename}_status_bit_1_request_operation_parameter
  icon: mdi:eye
  register_type: holding
  address: 128
  bitmask: 32768
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Electric Heater IBH 1
  id: ${devicename}_load_output_electric_heater_ibh1
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 1
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Electric Heater IBH 2
  id: ${devicename}_load_output_electric_heater_ibh_2
  icon: mdi:head-question-outline
  register_type: holding
  address: 129
  bitmask: 2
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Electric Heater TBH
  id: ${devicename}_load_output_electric_heater_tbh
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 4
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Water Pump PUMP_I
  id: ${devicename}_load_output_water_pump_pump_i
  icon: mdi:pump
  register_type: holding
  address: 129
  bitmask: 8
  on_press:
    then:
    - lambda: 'id(${devicename}_relay1_external_pump).turn_off();  //#XXXXXXX

        id(${devicename}_relay2_external_pump).turn_off();  //#XXXXXXX

        ESP_LOGI("PUMP_I Status","turn off relay 1 and 2");  //#XXXXXXX

        id(timestamp_water_pump_timestamp_last_run) = 0;'
  on_release:
    then:
    - lambda: 'id(timestamp_water_pump_timestamp_last_run) = id(esptime).now().timestamp;

        ESP_LOGI("PUMP_I Status","Set global timestamp last pump run and turn off");'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output SV1 -DHW
  id: ${devicename}_load_output_sv1
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 16
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output SV2
  id: ${devicename}_load_output_sv2
  icon: mdi:head-question-outline
  register_type: holding
  address: 129
  bitmask: 32
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output External Water Pump P_o
  id: ${devicename}_load_output_external_water_pump_p_o
  icon: mdi:pump
  register_type: holding
  address: 129
  bitmask: 64
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Water Return Water P_d
  id: ${devicename}_load_output_water_return_water_p_d
  icon: mdi:pump
  register_type: holding
  address: 129
  bitmask: 128
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Mixed Water Pump P_c
  id: ${devicename}_load_output_mixed_water_pump_p_c
  icon: mdi:pump
  register_type: holding
  address: 129
  bitmask: 256
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output SV3
  id: ${devicename}_load_output_sv3
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 512
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output HEAT 4
  id: ${devicename}_load_output_heat4
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 1024
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Solar Water Pump
  id: ${devicename}_load_output_solar_water_pump
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 2048
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output ALARM
  id: ${devicename}_load_output_alarm
  icon: mdi:eye
  register_type: holding
  entity_category: diagnostic
  address: 129
  bitmask: 4096
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output RUN
  id: ${devicename}_load_output_run
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 8192
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output Auxiliary Heat Source
  id: ${devicename}_load_output_auxiliary_heat_source
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 16384
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Load Output DEFROST
  id: ${devicename}_load_output_defrost
  icon: mdi:eye
  register_type: holding
  address: 129
  bitmask: 32768
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Slave Unit 1 Online Status
  id: ${devicename}_slave_unit_1_online_status
  icon: mdi:eye
  register_type: holding
  address: 142
  bitmask: 2
- platform: template
  name: PS1 T1S Heating High Low Temperature Settings RO?
  id: ${devicename}_p_s_1_t1s_heating_high_low_temperature_settings
  icon: mdi:eye
  lambda: return (id(unmasked_value_register_210) & 0x40) == 0x40; // Return status
    bit6
- platform: template
  name: PS1 T1s Cooling High Low Temperature Settings RO?
  id: ${devicename}_p_s_1_t1s_cooling_high_low_temperature_settings
  icon: mdi:eye
  lambda: return (id(unmasked_value_register_210) & 0x100) == 0x100; // Return status
    bit8
- platform: template
  name: PS1 Supports Water Tank Electric Heater TBH RO?
  id: ${devicename}_p_s_1_supports_water_tank_electric_heater_tbh
  icon: mdi:eye
  disabled_by_default: true
  lambda: return (id(unmasked_value_register_210) & 0x4000) == 0x4000; // Return status
    bit14
- platform: template
  name: Heat pump running
  id: ${devicename}_heat_pump_running
  icon: mdi:power
  entity_category: diagnostic
  device_class: plug
  lambda: "int fan_speed = id(${devicename}_fan_speed).state;\nint compressor_frequency\
    \ = id(${devicename}_compressor_operating_frequency).state;\nbool external_water_pump_on\
    \ = false; //id(${devicename}_load_output_external_water_pump_p_o).state;   //disabled\n\
    bool internal_water_pump_I_on = id(${devicename}_load_output_water_pump_pump_i).state;\n\
    //rather water_pump_i is better to check -external pump almost always run when\
    \ Heatpump is idle, but most often nobody have it\n\n// If fan_speed is above\
    \ 0, compressor_frequency is above 0 or external_water_pump_on is true or rather\
    \ internal pump_i is true,\n// then the outside unit of the heat pump system is\
    \ running\nif (fan_speed > 0 || compressor_frequency > 0 || external_water_pump_on\
    \ || internal_water_pump_I_on) {\n    return true;\n} else {\n    return false;\n\
    }"
switch:
- platform: template
  name: Relay 1 External Pump
  id: ${devicename}_relay1_external_pump
  optimistic: true
  icon: mdi:toggle-switch-off-outline
  on_turn_on:
    then:
      lambda: "if (id(${devicename}_load_output_water_pump_pump_i).state) {\n//turn\
        \ off when pump_i active\n  id(${devicename}_relay1_external_pump).turn_off();\n\
        \  ESP_LOGI(\"TAG\", \"load_output_water_pump_pump_i is ON. Disable relay1\
        \ %d\", id(relay1_start));\n} else {\n  id(relay1_start) = id(esptime).now().timestamp;\n\
        \  ESP_LOGI(\"TAG\", \"relay1_external_pump ON %d\", id(relay1_start));\n}"
  on_turn_off:
    then:
      lambda: 'id(relay1_start) = 0;

        id(timestamp_water_pump_timestamp_last_run) = id(esptime).now().timestamp;

        ESP_LOGI("TAG", "relay1 OFF %d and save new time for last work PUMP_I", id(relay1_start));'
  entity_category: diagnostic
- platform: template
  name: Relay 2 External Pump
  id: ${devicename}_relay2_external_pump
  optimistic: true
  icon: mdi:toggle-switch-off-outline
  on_turn_on:
    then:
      lambda: "if (id(${devicename}_load_output_water_pump_pump_i).state) {\n//turn\
        \ off when pump_i active\n  id(${devicename}_relay2_external_pump).turn_off();\n\
        } else {\n  id(relay2_start) = id(esptime).now().timestamp;\n  ESP_LOGI(\"\
        TAG\", \"relay2_external2 %d\", id(relay2_start));\n}"
  on_turn_off:
    lambda: 'id(relay2_start) = 0;

      ESP_LOGE("TAG", "relay2 OFF %d", id(relay2_start));'
  entity_category: diagnostic
- platform: template
  name: Power Climate Control -uses FanCoilUnit
  id: ${devicename}_power_climate_control_fancoilunit
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_0) & 0x1) == 0x1;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x1;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_0)) {\n  //write new value to heatpump if changed\n\
      \  ESP_LOGI(\"unmasked_value_register_0\", \"Set option to on power_air_conditioner_zone_1\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_0), new_value);\n  id(unmasked_value_register_0)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x1;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_0))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_0\", \"Set option to off power_air_conditioner_zone_1\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_0), new_value);\n  id(unmasked_value_register_0)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: Power Heat/Cool Control Zone 1
  id: ${devicename}_power_heat_cool_control_zone1
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_0) & 0x2) == 0x2;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x2;                          //affected bit number\n\
      uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked\
      \ value\nnew_value &= ~checked_bit;                                        \
      \     // Clear and set\nnew_value += checked_bit;\nif ((new_value) != id(unmasked_value_register_0))\
      \ {\n  //write new value to heatpump if changed\n  ESP_LOGI(\"unmasked_value_register_0\"\
      , \"Set option to on power_heat_cool_control_zone1 0x%x -> 0x%x\", id(unmasked_value_register_0),\
      \ new_value);\n  id(unmasked_value_register_0) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\n\
      id(manually_disabled_zone1_heating_timestamp) = 0;"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x2;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_0))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_0\", \"Set option to off power_heat_cool_control_zone1\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_0), new_value);\n  id(unmasked_value_register_0)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\n\
      id(manually_disabled_zone1_heating_timestamp) = id(esptime).now().timestamp;"
- platform: template
  name: Power DHW T5S
  id: ${devicename}_power_dhw_t5s
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: 'bool state_dhw = (id(unmasked_value_register_0) & 0x4) == 0x4;

    // if (state_dhw) id(manually_disabled_dhw_heating_timestamp) = 0; else if (id(manually_disabled_dhw_heating_timestamp)
    == 0) id(manually_disabled_dhw_heating_timestamp) = id(esptime).now().timestamp;

    return state_dhw;'
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x4;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_0)) {\n  ESP_LOGI(\"unmasked_value_register_0\"\
      , \"Set option to on power_dhw_t5s 0x%x -> 0x%x\", id(unmasked_value_register_0),\
      \ new_value);\n  id(unmasked_value_register_0) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\n\
      id(manually_disabled_dhw_heating_timestamp) = 0;"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x4;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\n\nif ((new_value) != id(unmasked_value_register_0))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_0\", \"Set option to off power_dhw_t5s\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_0), new_value);\n  id(unmasked_value_register_0)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\n\
      id(manually_disabled_dhw_heating_timestamp) = id(esptime).now().timestamp;"
- platform: template
  name: Power Heat/Cool Control Zone 2
  id: ${devicename}_power_heat_cool_control_zone2
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_0) & 0x8) == 0x8;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x8;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_0)) {\n  ESP_LOGI(\"unmasked_value_register_0\"\
      , \"Set option to on power_air_conditioner_zone_2 0x%x -> 0x%x\", id(unmasked_value_register_0),\
      \ new_value);\n  id(unmasked_value_register_0) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\n\
      id(manually_disabled_zone2_heating_timestamp) = 0;"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x8;\nuint16_t new_value = id(unmasked_value_register_0);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\n\nif ((new_value) != id(unmasked_value_register_0))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_0\", \"Set option to off power_air_conditioner_zone_2\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_0), new_value);\n  id(unmasked_value_register_0)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x0, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\n\
      id(manually_disabled_zone2_heating_timestamp) = id(esptime).now().timestamp;"
- platform: template
  name: F.S. Disinfect
  id: ${devicename}_f_s_disinfect
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x10) == 0x10; //return status bit
    4
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x10;                         //bit to change\n\
      uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked\
      \ value\nnew_value &= ~checked_bit;                                        \
      \     // Clear and set\nnew_value += checked_bit;\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to on f_s_disinfect\
      \ 0x%x -> 0x%xs\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x10;                         //bit to change\n\
      uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked\
      \ value\nnew_value &= ~checked_bit;                                        \
      \     // Clear and set\nif ((new_value) != id(unmasked_value_register_5)) {\n\
      \  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off f_s_disinfect\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}  "
- platform: template
  name: F.S. Silent Mode
  id: ${devicename}_f_s_silent_mode
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x40) == 0x40;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x40;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on f_s_silent_mode 0x%x -> 0x%x\", id(unmasked_value_register_5),\
      \ new_value);\n  id(unmasked_value_register_5) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x40;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off f_s_silent_mode\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 0x5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}\
      \  "
- platform: template
  name: F.S. Silent Mode Level 1 or 2
  id: ${devicename}_f_s_silent_mode_level
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x80) == 0x80;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x80;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on f_s_silent_mode_level 0x%x -> 0x%x\", id(unmasked_value_register_5),\
      \ new_value);\n  id(unmasked_value_register_5) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x80;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off f_s_silent_mode_level\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}  "
- platform: template
  name: F.S. Holiday Home
  id: ${devicename}_f_s_holiday_home
  icon: mdi:eye
  disabled_by_default: true
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x100) == 0x100;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x100;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on f_s_holiday_home 0x%x -> 0x%x\", id(unmasked_value_register_5),\
      \ new_value);\n  id(unmasked_value_register_5) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x100;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off f_s_holiday_home\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}  "
- platform: template
  name: F.S. ECO Mode
  id: ${devicename}_f_s_eco_mode
  icon: mdi:eye
  disabled_by_default: true
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x400) == 0x400;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x400;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on f_s_eco_mode 0x%x -> 0x%x\", id(unmasked_value_register_5),\
      \ new_value);\n  id(unmasked_value_register_5) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x400;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off f_s_eco_mode\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: F.S. DHW Pumps Running Constant Temperature Water Recycling
  id: ${devicename}_f_s_dhw_pumps_running_constant_temperature_water_recycling
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x800) == 0x800;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x800;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on f_s_dhw_pumps_running_constant_temperature_water_recycling\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x800;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off f_s_dhw_pumps_running_constant_temperature_water_recycling\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: Weather Compensation Zone 1
  id: ${devicename}_weather_compensation_zone_1
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x1000) == 0x1000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x1000;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on weather_compensation_zone_1 0x%x -> 0x%x\", id(unmasked_value_register_5),\
      \ new_value);\n  id(unmasked_value_register_5) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x1000;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off weather_compensation_zone_1\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: Weather Compensation Zone 2
  id: ${devicename}_weather_compensation_zone_2
  icon: mdi:eye
  disabled_by_default: true
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_5) & 0x2000) == 0x2000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x2000;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_5)) {\n  // ESP_LOGD(\"unmasked_value_register_5\"\
      , \"Set option to on weather_compensation_zone_2 0x%x -> 0x%x\", id(unmasked_value_register_5),\
      \ new_value);\n  id(unmasked_value_register_5) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x2000;\nuint16_t new_value = id(unmasked_value_register_5);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_5))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_5\", \"Set option to off weather_compensation_zone_2\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_5), new_value);\n  id(unmasked_value_register_5)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 5, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}  \
      \  "
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Forced Water Tank Heater On/Off
  id: ${devicename}_forced_water_tank_heating_on_off
  icon: mdi:fire-alert
  address: 7
  register_type: holding
  entity_category: config
  lambda: 'ESP_LOGI("Register 7", "Forced water tank Heater value: %d", x);

    return x == 1;'
  write_lambda: 'uint16_t value = x;

    // Check if value is off -if yes change value to 2 as documentation says

    if (value == 0) value = 2;

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x7, value);

    ${devicename}->queue_command(set_payload_command);

    ESP_LOGI("Register 7", "Set forced water tank Heater to: %s", value == 1?"ON":"OFF");

    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Forced Tank Buffer Heater
  id: ${devicename}_forced_tbh
  icon: mdi:fire-alert
  address: 8
  register_type: holding
  entity_category: config
  lambda: '// ESP_LOGI("Register 8", "Forced Tank Buffer Heater value: %d", x);

    return x == 1;'
  write_lambda: 'uint16_t value = x;

    // Check if value is off -if yes change value to 2 as documentation says

    if (value == 0) value = 2;

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x8, value);

    ${devicename}->queue_command(set_payload_command);

    ESP_LOGI("Register 8", "Forced Tank Buffer Heater to: %s", value == 1?"ON":"OFF");

    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Forced Hydraulic Module Rear Electric Heater 1
  id: ${devicename}_forced_hydraulic_module_rear_electric_heater_1
  icon: mdi:fire-alert
  address: 9
  register_type: holding
  entity_category: config
  lambda: 'ESP_LOGI("Register 9", "Forced Hydraulic Module Rear Electric Heater 1
    value: %d", x);

    return x == 1;'
  write_lambda: 'uint16_t value = x;

    // Check if value is off -if yes change value to 2 as documentation says

    if (value == 0) value = 2;

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x9, value);

    ${devicename}->queue_command(set_payload_command);

    ESP_LOGI("Register 9", "Set Forced Hydraulic Module Rear Electric Heater 1 to:
    %s", value == 1?"ON":"OFF");

    return {};'
- platform: template
  name: PS1 Heating And Cooling First Or Water First
  id: ${devicename}_p_s_1_heating_and_cooling_first_or_water_first
  icon: mdi:eye
  entity_category: config
  restore_mode: DISABLED
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x1) == 0x1;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x1;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_210)) {\n  // ESP_LOGD(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_heating_and_cooling_first_or_water_first 0x%x ->\
      \ 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x1;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_210\", \"Set option to off p_s_1_heating_and_cooling_first_or_water_first\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Dual Room Thermostat Supported
  id: ${devicename}_p_s_1_dual_room_thermostat_supported
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x2) == 0x2;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x2;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGD(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_dual_room_thermostat_supported 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x2;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_210\", \"Set option to off p_s_1_dual_room_thermostat_supported\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Room Thermostat
  id: ${devicename}_p_s_1_room_thermostat
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x4) == 0x4;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x4;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGD(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_room_thermostat 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x4;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_210\", \"Set option to off p_s_1_room_thermostat\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Supports Room Thermostat
  id: ${devicename}_p_s_1_supports_room_thermostat
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x8) == 0x8;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x8;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGD(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_supports_room_thermostat 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x8;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_210\", \"Set option to off p_s_1_supports_room_thermostat\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Supports Room Temperature Sensor Ta
  id: ${devicename}_p_s_1_supports_room_temperature_sensor_ta
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x10) == 0x10;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x10;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGD(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_supports_room_temperature_sensor_ta 0x%x -> 0x%x\"\
      , id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x10;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_210\", \"Set option to off p_s_1_supports_room_temperature_sensor_ta\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Silent Mode PUMP I,
  id: ${devicename}_p_s_1_silent_mode_pump_i
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x20) == 0x20;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x20;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_silent_mode_pump_i 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x20;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_silent_mode_pump_i\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Enable Heating
  id: ${devicename}_p_s_1_enable_heating
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x80) == 0x80;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x80;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_enable_heating 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x80;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_enable_heating\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Enable Cooling
  id: ${devicename}_p_s_1_enable_cooling
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x200) == 0x200;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x200;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_enable_cooling 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x200;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_enable_cooling\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 DHW Pump Supports Pipe Disinfect
  id: ${devicename}_p_s_1_dhw_pump_supports_pipe_disinfect
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x400) == 0x400;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x400;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nnew_value += checked_bit;\n\
      if ((new_value) != id(unmasked_value_register_210)) {\n  // ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_dhw_pump_supports_pipe_disinfect 0x%x -> 0x%x\",\
      \ id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x400;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \                                 // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_dhw_pump_supports_pipe_disinfect\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 DHW Pump Supported
  id: ${devicename}_p_s_1_dhw_pump_supported
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x1000) == 0x1000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x1000;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_210)) {\n  // ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_dhw_pump_supported 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x1000;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_dhw_pump_supported\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Supports Disinfection
  id: ${devicename}_p_s_1_supports_disinfection
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x2000) == 0x2000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x2000;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_210)) {\n  // ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_supports_disinfection 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x2000;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_supports_disinfection\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS1 Enable Water Heating
  id: ${devicename}_p_s_1_enable_water_heating
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_210) & 0x8000) == 0x8000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x8000;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_210)) {\n  ESP_LOGI(\"unmasked_value_register_210\"\
      , \"Set option to on p_s_1_enable_water_heating 0x%x -> 0x%x\", id(unmasked_value_register_210),\
      \ new_value);\n  id(unmasked_value_register_210) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x8000;\nuint16_t new_value = id(unmasked_value_register_210);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_210))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_210\", \"Set option to off p_s_1_enable_water_heating\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_210), new_value);\n  id(unmasked_value_register_210)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 210, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 IBH AHS Installation Position
  id: ${devicename}_p_s_2_ibh_ahs_installation_position
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x1) == 0x1;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x1;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  ESP_LOGI(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x1;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_211\", \"Set option to off p_s_2_ibh_ahs_installation_position\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Tbt Sensor Enable
  id: ${devicename}_p_s_2_tbt_sensor_enable
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x2) == 0x2;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x2;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  ESP_LOGI(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_tbt_sensor_enable 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x2;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_211\", \"Set option to off p_s_2_tbt_sensor_enable\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Ta Sensor Position
  id: ${devicename}_p_s_2_ta_sensor_position
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x4) == 0x4;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x4;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_ta_sensor_position 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x4;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_ta_sensor_position\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Double Zone Setting Is Valid
  id: ${devicename}_p_s_2_double_zone_setting_is_valid
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x8) == 0x8;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x8;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  ESP_LOGI(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x8;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  ESP_LOGI(\"unmasked_value_register_211\", \"Set option to off p_s_2_ibh_ahs_installation_position\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Setting The High Low Temperature Of Heating Mode T1S
  id: ${devicename}_p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x10) == 0x10;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x10;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGI(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x10;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGI(\"unmasked_value_register_211\", \"Set option to off p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Setting The High Low Temperature Of Cooling Mode T1S
  id: ${devicename}_p_s_2_setting_the_high_low_temperature_of_cooling_mode_t1s
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x20) == 0x20;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x20;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_setting_the_high_low_temperature_of_cooling_mode_t1s\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x20;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_setting_the_high_low_temperature_of_cooling_mode_t1s\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Tw2 T1B Enabled
  id: ${devicename}_p_s_2_tw2_enabled
  icon: mdi:eye
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x40) == 0x40;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x40;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_tw2_enabled 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x40;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_tw2_enabled\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Smart Grid
  id: ${devicename}_p_s_2_smart_grid
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x80) == 0x80;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x80;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  id(unmasked_value_register_211) = new_value;\n\
      \  esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x80;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Port 0-OnOff_1-DHW heater
  id: ${devicename}_p_s_2_port_definition
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x100) == 0x100;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x100;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  id(unmasked_value_register_211) = new_value;\n\
      \  esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x100;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Solar Energy Kit Enable
  id: ${devicename}_p_s_2_solar_energy_kit_enable
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x200) == 0x200;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x200;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_solar_energy_kit_enable 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x200;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_solar_energy_kit_enable\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Solar Energy Input Port
  id: ${devicename}_p_s_2_solar_energy_input_port
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x400) == 0x400;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x400;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_smart_grid 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x400;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_smart_grid\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Piping Length Selection
  id: ${devicename}_p_s_2_piping_length_selection
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x800) == 0x800;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x800;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_piping_length_selection 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x800;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_piping_length_selection\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Tbt2 Sensor Is Valid
  id: ${devicename}_p_s_2_tbt2_sensor_is_valid
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x1000) == 0x1000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x1000;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_tbt2_sensor_is_valid 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x1000;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_tbt2_sensor_is_valid\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 Enable Temperature Collection Kit
  id: ${devicename}_p_s_2_enable_temperature_collection_kit
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x2000) == 0x2000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x2000;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_enable_temperature_collection_kit 0x%x -> 0x%x\"\
      , id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x2000;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_enable_temperature_collection_kit\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: PS2 M1M2 Is Used For AHS Control
  id: ${devicename}_p_s_2_m1m2_is_used_for_ahs_control
  icon: mdi:eye
  disabled_by_default: true
  restore_mode: DISABLED
  entity_category: config
  optimistic: true
  lambda: return (id(unmasked_value_register_211) & 0x4000) == 0x4000;
  on_turn_on:
  - lambda: "uint16_t checked_bit = 0x4000;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nnew_value += checked_bit;\nif ((new_value) !=\
      \ id(unmasked_value_register_211)) {\n  // ESP_LOGD(\"unmasked_value_register_211\"\
      , \"Set option to on p_s_2_m1m2_is_used_for_ahs_control 0x%x -> 0x%x\", id(unmasked_value_register_211),\
      \ new_value);\n  id(unmasked_value_register_211) = new_value;\n  esphome::modbus_controller::ModbusCommandItem\
      \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
  on_turn_off:
  - lambda: "uint16_t checked_bit = 0x4000;\nuint16_t new_value = id(unmasked_value_register_211);\
      \  // The original unmasked value\nnew_value &= ~checked_bit;              \
      \             // Clear and set\nif ((new_value) != id(unmasked_value_register_211))\
      \ {\n  // ESP_LOGD(\"unmasked_value_register_211\", \"Set option to off p_s_2_m1m2_is_used_for_ahs_control\
      \ 0x%x -> 0x%x\", id(unmasked_value_register_211), new_value);\n  id(unmasked_value_register_211)\
      \ = new_value;\n  esphome::modbus_controller::ModbusCommandItem set_payload_command\
      \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
      \ 211, new_value);\n  ${devicename}->queue_command(set_payload_command);\n}"
- platform: template
  name: SM Enable RecoverTime enable DHW
  id: ${devicename}_enable_recoverytime_enable_dhw
  optimistic: true
  entity_category: config
  icon: mdi:switch
  on_turn_on:
    then:
      lambda: 'id(Restore_enable_DHW) = 1; ESP_LOGI("Enable RecoverTime enable DHW","
        is ON state: %d", id(Restore_enable_DHW)); id(${devicename}_enable_recoverytime_enable_dhw).publish_state(id(Restore_enable_DHW));'
  on_turn_off:
    then:
      lambda: 'id(Restore_enable_DHW) = 0; ESP_LOGI("Enable RecoverTime enable DHW","
        is OFF state: %d", id(Restore_enable_DHW)); id(${devicename}_enable_recoverytime_enable_dhw).publish_state(id(Restore_enable_DHW));'
- platform: template
  name: SM Enable RecoverTime enable Zone1
  id: ${devicename}_enable_recoverytime_enable_zone1
  optimistic: true
  entity_category: config
  icon: mdi:switch
  on_turn_on:
    then:
      lambda: 'id(Restore_enable_Zone1) = 1; ESP_LOGI("Enable RecoverTime enable ZONE1","
        is ON state: %d", id(Restore_enable_Zone1)); id(${devicename}_enable_recoverytime_enable_zone1).publish_state(id(Restore_enable_Zone1));'
  on_turn_off:
    then:
      lambda: 'id(Restore_enable_Zone1) = 0; ESP_LOGI("Enable RecoverTime enable Zone1","
        is OFF state: %d", id(Restore_enable_Zone1)); id(${devicename}_enable_recoverytime_enable_zone1).publish_state(id(Restore_enable_Zone1));'
- platform: template
  name: SM Enable RecoverTime enable Zone2
  id: ${devicename}_enable_recoverytime_enable_zone2
  optimistic: true
  entity_category: config
  icon: mdi:switch
  on_turn_on:
    then:
      lambda: 'id(Restore_enable_Zone2) = 1; ESP_LOGI("Enable RecoverTime enable Zone2","
        is ON state: %d", id(Restore_enable_Zone2)); id(${devicename}_enable_recoverytime_enable_zone2).publish_state(id(Restore_enable_Zone2));'
  on_turn_off:
    then:
      lambda: 'id(Restore_enable_Zone2) = 0; ESP_LOGI("Enable RecoverTime enable Zone2","
        is OFF state: %d", id(Restore_enable_Zone2)); id(${devicename}_enable_recoverytime_enable_zone2).publish_state(id(Restore_enable_Zone2));'
number:
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Set Water Temperature T1S Zone 1
  id: ${devicename}_set_water_temperature_t1s_zone_1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 2
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 65
  mode: slider
  lambda: '// Update the global var unmasked_value_water_temperature_t1s

    id(unmasked_value_water_temperature_t1s) = x;


    // ESP_LOGI("","unmasked_value_water_temperature_t1s: %d",id(unmasked_value_water_temperature_t1s));

    uint8_t value_bytes[2];

    uint16_t value = x;

    value_bytes[0] = value >> 8;     // high byte (zone 2)

    value_bytes[1] = value & 0x00FF; // low byte (zone 1)

    // ESP_LOGI("Register 2Low","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);

    return value_bytes[1];'
  write_lambda: "uint16_t value = id(unmasked_value_water_temperature_t1s); // The\
    \ original unmasked value\nuint8_t value_byte = x;                           \
    \       // New byte value with the new temp for zone 1\nauto operation_state =\
    \ id(${devicename}_operational_mode).state;\nauto end_heating_unit = id(${devicename}_zone_1_end_heating_mode_emission_type).state;\n\
    auto end_cooling_unit = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;\n\
    if (operation_state == \"Cool\") {\n  if (x < 5 and end_cooling_unit == \"Fan\
    \ Coil Unit\") value_byte = 5;\n  if (x < 18 and end_cooling_unit != \"Fan Coil\
    \ Unit\") value_byte = 18;\n  if (x > 25) value_byte = 25;\n} else if (operation_state\
    \ == \"Heat\" or operation_state == \"Auto\") {\n  if (x < 25 and end_heating_unit\
    \ == \"Underfloor Heating\") value_byte = 25;\n  if (x > 55 and end_heating_unit\
    \ == \"Underfloor Heating\") value_byte = 55;\n  if (x < 35 and end_heating_unit\
    \ == \"Radiator\") value_byte = 35;\n  if (x > 65 and end_heating_unit == \"Radiator\"\
    ) value_byte = 65;\n}\nvalue &= 0xFF00;      // Clear the lower byte of the value\n\
    value |= value_byte;  // Update the lower byte with the new byte value\n\nESP_LOGI(\"\
    Register 6Low, set_water_temperature_t1s_zone_1\", \"Set option to %f, Original\
    \ value 0x%x New value: 0x%x\", float(x), id(unmasked_value_water_temperature_t1s),\
    \ value);\n\nesphome::modbus_controller::ModbusCommandItem set_payload_command\
    \ = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
    \ 0x2, value);\n${devicename}->queue_command(set_payload_command);\nid(unmasked_value_water_temperature_t1s)\
    \ = value;\nreturn {};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Set Water Temperature T1S Zone 2
  id: ${devicename}_set_water_temperature_t1s_zone_2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 2
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 65
  mode: slider
  lambda: '// The global var unmasked_value_water_temperature_t1s is already

    // updated in the previous, where the low byte variant is executed

    // id(unmasked_value_water_temperature_t1s) = x;


    uint8_t value_bytes[2];

    uint16_t value = x;

    value_bytes[0] = value >> 8;     // high byte (zone 2)

    value_bytes[1] = value & 0x00FF; // low byte (zone 1)

    // ESP_LOGD("Register 2High","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);

    return value_bytes[0];'
  write_lambda: "uint16_t value = id(unmasked_value_water_temperature_t1s); // The\
    \ original unmasked value\nuint8_t value_byte = x;                           \
    \       // New byte value with the new temp for zone 2\n// Apply minmax for standard\
    \ temp\nauto operation_state = id(${devicename}_operational_mode).state;\nauto\
    \ end_heating_unit = id(${devicename}_zone_2_end_heating_mode_emission_type).state;\n\
    auto end_cooling_unit = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;\n\
    if (operation_state == \"Cool\") {\n  if (x < 5 and end_cooling_unit == \"Fan\
    \ Coil Unit\") value_byte = 5;\n  if (x < 18 and end_cooling_unit != \"Fan Coil\
    \ Unit\") value_byte = 18;\n  if (x >25) value_byte = 25;\n} else if (operation_state\
    \ == \"Heat\") {\n  if (x < 25 and end_heating_unit == \"Underfloor Heating\"\
    ) value_byte = 25;\n  if (x > 55 and end_heating_unit == \"Underfloor Heating\"\
    ) value_byte = 55;\n  if (x < 35 and end_heating_unit == \"Radiator\") value_byte\
    \ = 35;\n  if (x > 65 and end_heating_unit == \"Radiator\") value_byte = 65;\n\
    }\nvalue &= 0x00FF;             // Clear the upper byte of the value\nvalue |=\
    \ (value_byte << 8);  // Update the upper byte with the new byte value\n\nESP_LOGI(\"\
    set_water_temperature_t1s_zone_2\", \"Set option to %f, Original value 0x%x New\
    \ value: 0x%x\", float(x), id(unmasked_value_water_temperature_t1s), value);\n\
    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
    \ 0x2, value);\n${devicename}->queue_command(set_payload_command);\nid(unmasked_value_water_temperature_t1s)\
    \ = value;\nreturn {};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Set DHW Tank Temperature T5s
  id: ${devicename}_set_dhw_tank_temperature_t5s
  icon: mdi:temperature-celsius
  register_type: holding
  address: 4
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 20
  max_value: 65
  mode: slider
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Weather Compensation Curve Zone 1
  id: ${devicename}_weather_compensation_curve_zone_1
  icon: mdi:eye
  register_type: holding
  address: 6
  value_type: U_WORD
  entity_category: config
  min_value: 1
  max_value: 9
  mode: slider
  lambda: '// Update the global var unmasked_curve_selection

    id(unmasked_curve_selection) = x;


    // ESP_LOGI("","unmasked_curve_selection: %d",id(unmasked_curve_selection));


    uint8_t value_bytes[2];

    uint16_t value = x;

    value_bytes[0] = value >> 8;     // high byte (zone 2)

    value_bytes[1] = value & 0x00FF; // low byte (zone 1)


    // ESP_LOGI("Register 6Low","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);


    return value_bytes[1];'
  write_lambda: 'uint16_t value = id(unmasked_curve_selection); // The original unmasked
    value

    uint8_t value_byte = x;                        // New byte value with the new
    temp for zone 1


    value &= 0xFF00;      // Clear the lower byte of the value

    value |= value_byte;  // Update the lower byte with the new byte value


    ESP_LOGI("Register 6Low", "Original value: %d, New value: %d", id(unmasked_curve_selection),
    value);


    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x6, value);

    ${devicename}->queue_command(set_payload_command);


    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Weather Compensation Curve Zone 2
  id: ${devicename}_weather_compensation_curve_zone_2
  icon: mdi:eye
  register_type: holding
  address: 6
  value_type: U_WORD
  entity_category: config
  min_value: 1
  max_value: 9
  mode: slider
  lambda: '// The global var unmasked_curve_selection is already

    // updated in the previous, where the low byte variant is executed

    // id(unmasked_curve_selection) = x;


    uint8_t value_bytes[2];

    uint16_t value = x;

    value_bytes[0] = value >> 8;     // high byte (zone 2)

    value_bytes[1] = value & 0x00FF; // low byte (zone 1)


    return value_bytes[0];'
  write_lambda: 'uint16_t value = id(unmasked_curve_selection); // The original unmasked
    value

    uint8_t value_byte = x;                        // New byte value with the new
    temp for zone 2


    value &= 0x00FF;             // Clear the upper byte of the value

    value |= (value_byte << 8);  // Update the upper byte with the new byte value

    ESP_LOGI("Register 6High", "Original value: %d, New value: %d", id(unmasked_curve_selection),
    value);

    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x6, value);

    ${devicename}->queue_command(set_payload_command);


    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature T1s Zone1
  id: ${devicename}_temperature_t1s_zone1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 11
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 65
  mode: slider
  lambda: "float value = x;\nauto operation_state = id(${devicename}_operational_mode).state;\n\
    auto end_heating_unit = id(${devicename}_zone_1_end_heating_mode_emission_type).state;\n\
    auto end_cooling_unit = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;\n\
    if (operation_state == \"Cool\") {\n  if (x < 5 and end_cooling_unit == \"Fan\
    \ Coil Unit\") value = 5;\n  if (x < 18 and end_cooling_unit != \"Fan Coil Unit\"\
    ) value = 18;\n  if (x > 25) value = 25;\n} else if (operation_state == \"Heat\"\
    ) {\n  if (x < 25 and end_heating_unit == \"Underfloor Heating\") value = 25;\n\
    \  if (x > 55 and end_heating_unit == \"Underfloor Heating\") value = 55;\n  if\
    \ (x < 35 and end_heating_unit == \"Radiator\") value = 35;\n  if (x > 65 and\
    \ end_heating_unit == \"Radiator\") value = 65;\n}\nreturn value;"
  write_lambda: "//return{}; //maybe this duplicate write?\nuint16_t value = x;\n\
    auto operation_state = id(${devicename}_operational_mode).state;\nauto end_heating_unit\
    \ = id(${devicename}_zone_1_end_heating_mode_emission_type).state;\nauto end_cooling_unit\
    \ = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;\nif (operation_state\
    \ == \"Cool\") {\n  if (x < 5 and end_cooling_unit == \"Fan Coil Unit\") value\
    \ = 5;\n  if (x < 18 and end_cooling_unit != \"Fan Coil Unit\") value = 18;\n\
    \  if (x > 25) value = 25;\n} else if (operation_state == \"Heat\") {\n  if (x\
    \ < 25 and end_heating_unit == \"Underfloor Heating\") value = 25;\n  if (x >\
    \ 55 and end_heating_unit == \"Underfloor Heating\") value = 55;\n  if (x < 35\
    \ and end_heating_unit == \"Radiator\") value = 35;\n  if (x > 65 and end_heating_unit\
    \ == \"Radiator\") value = 65;\n}\nESP_LOGI(\"temperature_t1s_zone1\", \"Set option\
    \ to %f, New value: %d\", float(x), value);\nesphome::modbus_controller::ModbusCommandItem\
    \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
    \ 11, value);\n${devicename}->queue_command(set_payload_command);\nreturn {};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature T1s Zone2
  id: ${devicename}_temperature_t1s_zone2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 12
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 65
  mode: slider
  lambda: "float value = x;\nauto operation_state = id(${devicename}_operational_mode).state;\n\
    auto end_heating_unit = id(${devicename}_zone_2_end_heating_mode_emission_type).state;\n\
    auto end_cooling_unit = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;\n\
    if (operation_state == \"Cool\") {\n  if (x < 5 and end_cooling_unit == \"Fan\
    \ Coil Unit\") value = 5;\n  if (x < 18 and end_cooling_unit != \"Fan Coil Unit\"\
    ) value = 18;\n  if (x >25) value = 25;\n} else if (operation_state == \"Heat\"\
    ) {\n  if (x < 25 and end_heating_unit == \"Underfloor Heating\") value = 25;\n\
    \  if (x > 55 and end_heating_unit == \"Underfloor Heating\") value = 55;\n  if\
    \ (x < 35 and end_heating_unit == \"Radiator\") value = 35;\n  if (x > 65 and\
    \ end_heating_unit == \"Radiator\") value = 65;\n}\nreturn value;"
  write_lambda: "//return{}; //maybe this duplicate write?\nuint16_t value = x;\n\
    auto operation_state = id(${devicename}_operational_mode).state;\nauto end_heating_unit\
    \ = id(${devicename}_zone_2_end_heating_mode_emission_type).state;\nauto end_cooling_unit\
    \ = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;\nif (operation_state\
    \ == \"Cool\") {\n  if (x < 5 and end_cooling_unit == \"Fan Coil Unit\") value\
    \ = 5;\n  if (x < 18 and end_cooling_unit != \"Fan Coil Unit\") value = 18;\n\
    \  if (x >25) value = 25;\n} else if (operation_state == \"Heat\") {\n  if (x\
    \ < 25 and end_heating_unit == \"Underfloor Heating\") value = 25;\n  if (x >\
    \ 55 and end_heating_unit == \"Underfloor Heating\") value = 55;\n  if (x < 35\
    \ and end_heating_unit == \"Radiator\") value = 35;\n  if (x > 65 and end_heating_unit\
    \ == \"Radiator\") value = 65;\n}\nESP_LOGI(\"temperature_t1s_zone2\", \"Set option\
    \ to %f, New value: %d\", float(x), value);\nesphome::modbus_controller::ModbusCommandItem\
    \ set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},\
    \ 12, value);\n${devicename}->queue_command(set_payload_command);\nreturn {};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: DHW Pump Return Running Time
  id: ${devicename}_dhw_pump_return_running_time
  icon: mdi:clock-check-outline
  register_type: holding
  address: 209
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 5
  max_value: 120
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dT5_On
  id: ${devicename}_dt5_on
  icon: mdi:temperature-celsius
  register_type: holding
  address: 212
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 1
  max_value: 30
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dT1S5
  id: ${devicename}_dt1s5
  icon: mdi:temperature-celsius
  register_type: holding
  address: 213
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 40
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T Interval DHW
  id: ${devicename}_t_interval_dhw
  icon: mdi:clock-check-outline
  register_type: holding
  address: 214
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 5
  max_value: 30
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4 DHW max
  id: ${devicename}_t4_dhw_max
  icon: mdi:temperature-celsius
  register_type: holding
  address: 215
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 35
  max_value: 43
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4 DHW min
  id: ${devicename}_t4_dhw_min
  icon: mdi:temperature-celsius
  register_type: holding
  address: 216
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -25
  max_value: 30
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: t TBH Delay
  id: ${devicename}_t_tbh_delay
  icon: mdi:camera-timer
  register_type: holding
  address: 217
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 0
  max_value: 240
  step: 5
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dT5 TBH Off
  id: ${devicename}_dt5_tbh_off
  icon: mdi:temperature-celsius
  register_type: holding
  address: 218
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 0
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4 TBH On
  id: ${devicename}_t4_tbh_on
  icon: mdi:temperature-celsius
  register_type: holding
  address: 219
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -5
  max_value: 20
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature For Disinfection Operation
  id: ${devicename}_t5s_di
  disabled_by_default: true
  icon: mdi:temperature-celsius
  register_type: holding
  address: 220
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 60
  max_value: 70
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Maximum Disinfection Duration
  id: ${devicename}_t_di_max
  icon: mdi:clock
  register_type: holding
  address: 221
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 90
  max_value: 300
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Disinfection High Temperature Duration
  id: ${devicename}_t_di_hightemp
  icon: mdi:clock
  register_type: holding
  address: 222
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 5
  max_value: 60
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Time Interval Of Compressor Startup In Cooling mode
  id: ${devicename}_t_interval_c
  icon: mdi:clock
  register_type: holding
  address: 223
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 5
  max_value: 30
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dT1SC
  id: ${devicename}_dt1sc
  icon: mdi:temperature-celsius
  register_type: holding
  address: 224
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 2
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dTSC
  id: ${devicename}_dtsc
  icon: mdi:temperature-celsius
  register_type: holding
  address: 225
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 1
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4cmax
  id: ${devicename}_t4cmax
  icon: mdi:temperature-celsius
  register_type: holding
  address: 226
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 35
  max_value: 46
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4cmin
  id: ${devicename}_t4cmin
  icon: mdi:temperature-celsius
  register_type: holding
  address: 227
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -5
  max_value: 25
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Time Interval Of Compressor Startup In Heating mode
  id: ${devicename}_t_interval_h
  icon: mdi:clock
  register_type: holding
  address: 228
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 5
  max_value: 60
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dT1SH
  id: ${devicename}_dt1sh
  icon: mdi:temperature-celsius
  register_type: holding
  address: 229
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 2
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: dTSH
  id: ${devicename}_dtsh
  icon: mdi:temperature-celsius
  register_type: holding
  address: 230
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 1
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4hmax
  id: ${devicename}_t4hmax
  icon: mdi:temperature-celsius
  register_type: holding
  address: 231
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 20
  max_value: 35
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4hmin
  id: ${devicename}_t4hmin
  icon: mdi:temperature-celsius
  register_type: holding
  address: 232
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -25
  max_value: 5
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Ambient Temperature For Enabling Hydraulic Module Auxiliary Electric Heating
    IBH
  id: ${devicename}_t4_ibh_on
  icon: mdi:temperature-celsius
  register_type: holding
  address: 233
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -15
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Return Difference For Enabling The Hydraulic Module Auxiliary
    IBH
  id: ${devicename}_dt1_ibh_on
  icon: mdi:temperature-celsius
  register_type: holding
  address: 234
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 1
  max_value: 7
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Delay Time Of Enabling The Hydraulic Module Auxiliary Electric Heating IBH
  id: ${devicename}_t_ibh_delay
  disabled_by_default: true
  icon: mdi:camera-timer
  register_type: holding
  address: 235
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 15
  max_value: 120
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Ambient Temperature Trigger For AHS
  id: ${devicename}_t4_ahs_on
  disabled_by_default: true
  icon: mdi:temperature-celsius
  register_type: holding
  address: 237
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -15
  max_value: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Trigger Temperature Difference Between T1S And Current Heat for AHS
  id: ${devicename}_dt1_ahs_on
  disabled_by_default: true
  icon: mdi:temperature-celsius
  register_type: holding
  address: 238
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 1
  max_value: 7
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Delay Time for Enabling AHS
  id: ${devicename}_t_ahs_delay
  disabled_by_default: true
  icon: mdi:camera-timer
  register_type: holding
  address: 240
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 5
  max_value: 120
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Water Heating Max Duration
  id: ${devicename}_t_dhwhp_max
  icon: mdi:clock-check-outline
  register_type: holding
  address: 241
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 10
  max_value: 600
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T DHWHP Restrict
  id: ${devicename}_t_dhwhp_restrict
  icon: mdi:clock-check-outline
  register_type: holding
  address: 242
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 10
  max_value: 600
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4autocmin
  id: ${devicename}_t4autocmin
  icon: mdi:thermometer
  register_type: holding
  address: 243
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 20
  max_value: 29
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4autohmax
  id: ${devicename}_t4autohmax
  icon: mdi:temperature-celsius
  register_type: holding
  address: 244
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 10
  max_value: 17
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Heating Or Cooling Temperature When Holiday Mode Is Active
  id: ${devicename}_t1s_h_a_h
  disabled_by_default: true
  icon: mdi:temperature-celsius
  register_type: holding
  address: 245
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 20
  max_value: 29
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Domestic Hot Water Temperature When Holiday Mode is Active
  id: ${devicename}_t5s_h_a_dhw
  disabled_by_default: true
  icon: mdi:temperature-celsius
  register_type: holding
  address: 246
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 20
  max_value: 25
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: PER START Ratio
  id: ${devicename}_per_start_ratio
  icon: mdi:eye
  register_type: holding
  address: 247
  value_type: U_WORD
  entity_category: config
  min_value: 10
  max_value: 100
  step: 10
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: TIME ADJUST
  id: ${devicename}_time_adjust
  icon: mdi:clock
  register_type: holding
  address: 248
  value_type: U_WORD
  unit_of_measurement: min
  entity_category: config
  min_value: 1
  max_value: 60
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: DTbt2
  id: ${devicename}_dtbt2
  icon: mdi:temperature-celsius
  disabled_by_default: true
  register_type: holding
  address: 249
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 0
  max_value: 50
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: IBH1 Power
  id: ${devicename}_ibh1_power
  icon: mdi:alpha-w
  disabled_by_default: true
  register_type: holding
  address: 250
  value_type: U_WORD
  unit_of_measurement: W
  multiply: 0.01
  entity_category: config
  min_value: 0
  max_value: 20000
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: IBH2 Power
  id: ${devicename}_ibh2_power
  icon: mdi:alpha-w
  disabled_by_default: true
  register_type: holding
  address: 251
  value_type: U_WORD
  unit_of_measurement: W
  multiply: 0.01
  entity_category: config
  min_value: 0
  max_value: 20000
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: TBH Power
  id: ${devicename}_tbh_power
  icon: mdi:alpha-w
  disabled_by_default: true
  register_type: holding
  address: 252
  value_type: U_WORD
  unit_of_measurement: W
  multiply: 0.01
  entity_category: config
  min_value: 0
  max_value: 20000
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Rise Day Number
  id: ${devicename}_t_dryup
  icon: mdi:calendar-week
  disabled_by_default: true
  register_type: holding
  address: 255
  value_type: U_WORD
  entity_category: config
  min_value: 4
  max_value: 15
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Drying Day Number
  id: ${devicename}_t_highpeak
  icon: mdi:calendar-week
  disabled_by_default: true
  register_type: holding
  address: 256
  value_type: U_WORD
  entity_category: config
  min_value: 3
  max_value: 7
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Temperature Drop Day Number
  id: ${devicename}_t_dryd
  icon: mdi:calendar-week
  disabled_by_default: true
  register_type: holding
  address: 257
  value_type: U_WORD
  entity_category: config
  min_value: 4
  max_value: 15
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Highest Drying Temperature
  id: ${devicename}_t_drypeak
  disabled_by_default: true
  icon: mdi:temperature-celsius
  register_type: holding
  address: 258
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 30
  max_value: 55
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Running Time Of Floor Heating For The First Time
  id: ${devicename}_t_firstfh
  icon: mdi:clock-check-outline
  disabled_by_default: true
  register_type: holding
  address: 259
  value_type: U_WORD
  unit_of_measurement: hr
  entity_category: config
  min_value: 48
  max_value: 96
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T1S Of Floor Heating For The First Time
  id: ${devicename}_t1s_firstfh
  icon: mdi:temperature-celsius
  disabled_by_default: true
  register_type: holding
  address: 260
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 25
  max_value: 35
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T1SetC1
  id: ${devicename}_t1setc1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 261
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 25
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T1SetC2
  id: ${devicename}_t1setc2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 262
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 5
  max_value: 25
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4C1
  id: ${devicename}_t4c1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 263
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -5
  max_value: 46
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4C2
  id: ${devicename}_t4c2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 264
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -5
  max_value: 46
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T1SetH1
  id: ${devicename}_t1seth1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 265
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 25
  max_value: 65
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T1SetH2
  id: ${devicename}_t1seth2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 266
  value_type: U_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: 25
  max_value: 65
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4H1
  id: ${devicename}_t4h1
  icon: mdi:temperature-celsius
  register_type: holding
  address: 267
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -25
  max_value: 30
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: T4H2
  id: ${devicename}_t4h2
  icon: mdi:temperature-celsius
  register_type: holding
  address: 268
  value_type: S_WORD
  unit_of_measurement: "\xB0C"
  entity_category: config
  min_value: -25
  max_value: 30
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: t_T4 FRESH_H
  id: ${devicename}_t_t4_fresh_h
  icon: mdi:clock-check-outline
  register_type: holding
  address: 270
  value_type: U_WORD
  unit_of_measurement: hr
  entity_category: config
  min_value: 0.5
  max_value: 6.0
  step: 0.5
  mode: slider
  lambda: '// Update the global var unmasked_value_register_270

    id(unmasked_value_register_270) = x;


    float value_floats[2];

    uint16_t value = x;


    // Extracting the high byte (Cooling) and storing it as a float

    value_floats[0] = (float)(value >> 8) * 0.5;


    // Extracting the low byte (Heating) and storing it as a float

    value_floats[1] = (float)(value & 0x00FF) * 0.5;


    // ESP_LOGI("","t_T4 FRESH_H is %f", value_floats[1]);

    // ESP_LOGI("","t_T4 FRESH_C is %f", value_floats[0]);


    return value_floats[1];'
  write_lambda: 'uint16_t value = id(unmasked_value_register_270); // The original
    unmasked value

    float input = x * 2.0;                            // Multiply x (the input from
    the slider) by 2


    // Multiply the input from the slider (x) by by

    // and convert to uint8_t

    uint8_t input_byte = static_cast<uint8_t>(x * 2.0);


    value &= 0xFF00;      // Clear the lower byte of the value

    value |= input_byte;  // Update the lower byte with the new byte value


    ESP_LOGI("Register _t_t4_fresh_h", "Original value: %d, New value: %d", id(unmasked_curve_selection),
    value);


    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x10e, value);

    ${devicename}->queue_command(set_payload_command);


    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: t_T4 FRESH_C
  id: ${devicename}_t_t4_fresh_c
  icon: mdi:clock-check-outline
  register_type: holding
  address: 270
  value_type: U_WORD
  unit_of_measurement: hr
  entity_category: config
  min_value: 0.5
  max_value: 6.0
  step: 0.5
  mode: slider
  lambda: '// Update the global var unmasked_value_register_270

    id(unmasked_value_register_270) = x;


    float value_floats[2];

    uint16_t value = x;


    // Extracting the high byte (Cooling) and storing it as a float

    value_floats[0] = (float)(value >> 8) * 0.5;


    // Extracting the low byte (Heating) and storing it as a float

    value_floats[1] = (float)(value & 0x00FF) * 0.5;


    return value_floats[1];'
  write_lambda: 'uint16_t value = id(unmasked_value_register_270); // The original
    unmasked value

    float input = x * 2.0;                            // Multiply x (the input from
    the slider) by 2


    // Multiply the input from the slider (x) by by

    // and convert to uint8_t

    uint8_t input_byte = static_cast<uint8_t>(x * 2.0);


    value &= 0x00FF;             // Clear the upper byte of the value

    value |= (input_byte << 8);  // Update the upper byte with the new byte value


    ESP_LOGI("Register 10e _t_t4_fresh_c", "Original value: %d, New value: %d", id(unmasked_curve_selection),
    value);


    esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename},
    0x10e, value);

    ${devicename}->queue_command(set_payload_command);


    return {};'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Built-in Circulating Pump Delay
  id: ${devicename}_t_delay_pump
  icon: mdi:camera-timer
  register_type: holding
  address: 271
  value_type: U_WORD
  unit_of_measurement: min
  multiply: 2.0
  entity_category: config
  min_value: 2.0
  max_value: 20.0
  step: 0.5
- platform: template
  name: SM Restore DHW Heat after time
  id: ${devicename}_restore_time_heat_dhw_after_turn_off
  icon: mdi:clock-check-outline
  min_value: 0
  max_value: 1440
  step: 5
  unit_of_measurement: min
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 210
  on_value:
    then:
      lambda: 'ESP_LOGI("Restore DHW Heat after time","Restore DHW Heat after time:
        %f min", x);'
- platform: template
  name: SM Restore Zone1 Heat/Cool after time
  id: ${devicename}_restore_time_heat_zone1_after_turn_off
  icon: mdi:clock-check-outline
  min_value: 0
  max_value: 1440
  step: 5
  unit_of_measurement: min
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 210
  on_value:
    then:
      lambda: 'ESP_LOGI("Restore Zone1 Heat after time","Restore Zone1 Heat after
        time: %f min", x);'
- platform: template
  name: SM Restore Zone2 Heat after time
  id: ${devicename}_restore_time_heat_zone2_after_turn_off
  icon: mdi:clock-check-outline
  min_value: 0
  max_value: 1440
  step: 5
  unit_of_measurement: min
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 210
  on_value:
    then:
      lambda: 'ESP_LOGI("Restore Zone2 Heat after time","Restore Zone2 Heat after
        time: %f min", x);'
- platform: template
  name: SM Antifreeze time temp treshold
  id: ${devicename}_temp_secure_antifreeze
  icon: mdi:temperature-celsius
  min_value: -1
  max_value: 30
  step: 1
  unit_of_measurement: "\xB0C"
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 3
  on_value:
    then:
      lambda: "ESP_LOGI(\"SM Antifreeze time temp treshold\",\"Actual value: %f \xB0\
        C\", x);"
- platform: template
  name: SM Minimal DHW Temp Allow to drop
  id: ${devicename}_gl_dhw_minimal_temp
  icon: mdi:temperature-celsius
  min_value: 25
  max_value: 50
  step: 1
  unit_of_measurement: "\xB0C"
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 32
  on_value:
    then:
      lambda: "ESP_LOGI(\"SM Minimal DHW Temp Allow to drop\",\"Actual value: %f \xB0\
        C\", x);"
- platform: template
  name: SM Antifreeze protect between PUMP_I run
  id: ${devicename}_pump_i_antifrize_check_last_run_interval
  icon: mdi:clock
  min_value: 1
  max_value: 120
  step: 1
  unit_of_measurement: min
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 60
  on_value:
    then:
      lambda: 'ESP_LOGI("SM Antifreeze protect between PUMP_I run","Actual value:
        %f min", x);'
- platform: template
  name: SM Output External pump for antifreeze
  id: ${devicename}_output_external_pump_for_antifreeze_relay1
  icon: mdi:clock
  min_value: 1
  max_value: 15
  step: 1
  unit_of_measurement: min
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 5
  on_value:
    then:
      lambda: 'ESP_LOGI("SM Output External pump for antifreeze","Actual value: %f
        min", x);'
- platform: template
  name: SM Output External pump -spare
  id: ${devicename}_external_relay_timer
  icon: mdi:clock
  min_value: 1
  max_value: 15
  step: 1
  unit_of_measurement: min
  entity_category: config
  optimistic: true
  restore_value: true
  initial_value: 5
  on_value:
    then:
      lambda: 'ESP_LOGI("SM Output External pump for antifreeze -spare","Actual value:
        %f min", x);'
text_sensor:
- platform: version
  name: ESPHome Version
  id: ${devicename}_esphome_version
  icon: mdi:information
  hide_timestamp: true
  entity_category: diagnostic
- platform: template
  name: Uptime HR
  id: uptime_human
  icon: mdi:clock-start
  entity_category: diagnostic
- platform: wifi_info
  ip_address:
    name: IP
    entity_category: diagnostic
    icon: mdi:ip-network
  ssid:
    name: SSID
    entity_category: diagnostic
    icon: mdi:wifi
  bssid:
    name: BSSID
    entity_category: diagnostic
    icon: mdi:wifi-alert
- platform: template
  name: Active State
  id: ${devicename}_active_state
  icon: mdi:power
  entity_category: diagnostic
  lambda: "if (id(${devicename}_load_output_run).state) {\n  // The heat pump is on\n\
    \  if (id(${devicename}_status_bit_1_defrosting).state) {\n    return {\"Defrosting\"\
    };\n  } else if (id(${devicename}_load_output_sv1).state) {\n    return {\"DHW\"\
    };\n  } else if (id(${devicename}_status_bit_1_heating_mode_set_by_room_thermostat).state\
    \ \n    || id(${devicename}_power_heat_cool_control_zone1).state) {\n    return\
    \ {\"Heating\"};\n  } else if (id(${devicename}_status_bit_1_cooling_mode_set_by_room_thermostat).state\n\
    \    || id(${devicename}_power_climate_control_fancoilunit).state\n    || id(${devicename}_power_heat_cool_control_zone2).state)\
    \ {\n    return {\"Cooling\"};\n  } else {\n    return {\"Unknown\"};\n  }\n}\
    \ else {\n  // The heat pump is off\n  return {\"Inactive\"};\n}"
- platform: template
  name: Current Fault Error Code
  id: ${devicename}_current_fault_error_code
  icon: mdi:alert-circle
  lambda: "int current_fault = id(${devicename}_current_fault).state;\n\n// ESP_LOGI(\"\
    main\", \"Current fault: %d\", current_fault);\n\nif (current_fault >= 0 && current_fault\
    \ <= 143) {\n  return std::to_string(current_fault);\n} else {\n  return {\"Unknown\"\
    };\n}"
  filters:
  - map:
    - 0 -> OK
    - 1 -> E0
    - 2 -> E1
    - 3 -> E2
    - 4 -> E3
    - 5 -> E4
    - 6 -> E5
    - 7 -> E6
    - 8 -> E7
    - 9 -> E8
    - 10 -> E9
    - 11 -> EA
    - 12 -> Eb
    - 13 -> Ec
    - 14 -> Ed
    - 15 -> EE
    - 20 -> P0
    - 21 -> P1
    - 23 -> P3
    - 24 -> P4
    - 25 -> P5
    - 26 -> P6
    - 31 -> Pb
    - 33 -> Pd
    - 38 -> PP
    - 39 -> H0
    - 40 -> H1
    - 41 -> H2
    - 42 -> H3
    - 43 -> H4
    - 44 -> H5
    - 45 -> H6
    - 46 -> H7
    - 47 -> H8
    - 48 -> H9
    - 49 -> HA
    - 50 -> Hb
    - 52 -> Hd
    - 53 -> HE
    - 54 -> HF
    - 55 -> HH
    - 57 -> HP
    - 65 -> C7
    - 112 -> bH
    - 116 -> F1
    - 134 -> L0
    - 135 -> L1
    - 136 -> L2
    - 138 -> L4
    - 139 -> L5
    - 141 -> L7
    - 142 -> L8
    - 143 -> L9
- platform: template
  name: Current Fault Error Code Description
  id: ${devicename}_current_fault_error_code_description
  icon: mdi:alert-circle
  lambda: "int current_fault = id(${devicename}_current_fault).state;\n\n// ESP_LOGI(\"\
    main\", \"Current fault: %d\", current_fault);\n\nif (current_fault >= 0 && current_fault\
    \ <= 143) {\n  return std::to_string(current_fault);\n} else {\n  return {\"Unknown\"\
    };\n}"
  filters:
  - map:
    - 0 -> OK
    - 1 -> Water flow fault(E8 displayed 3 times)
    - 2 -> Phase loss or neutral wire and live wire are connected reversely(only for
      three phase unit)
    - 3 -> Communication fault between controller and hydraulic module
    - 4 -> Final outlet water temp. sensor(T1) fault
    - 5 -> Water tank temp. sensor(T5) fault
    - 6 -> The condenser outlet refrigerant temperature sensor(T3) fault
    - 7 -> The ambient temperature sensor(T4) fault
    - 8 -> Buffer tank up temp. sensor(Tbt1) fault
    - 9 -> Water flow failure
    - 10 -> Suction temp. sensor (Th) fault
    - 11 -> Discharge temp. sensor (Tp) fault
    - 12 -> Solar temp. sensor(Tsolar) fault
    - 13 -> Buffer tank low temp. sensor(Tbt2) fault
    - 14 -> Inlet water temp. sensor(Tw_in) malfunction
    - 15 -> Hydraulic module EEprom failure
    - 20 -> Low pressure switch protection
    - 21 -> High pressure switch protection
    - 23 -> Compressor overcurrent protection
    - 24 -> High discharge temperature protection
    - 25 -> |Tw_out - Tw_in| value too big protection
    - 26 -> Inverter module protection
    - 31 -> Anti-freeze mode
    - 33 -> High temperature protection of refrigerant outlet temp. of condenser
    - 38 -> Tw_out - Tw_in unusual protection
    - 39 -> Communication fault between main board PCB B and main control board of
      hydraulic module
    - 40 -> Communication fault between inverter module PCB A and main control board
      PCB B
    - 41 -> Refrigerant liquid temp. sensor(T2) fault
    - 42 -> Refrigerant gas temp. sensor(T2B) fault
    - 43 -> Three times P6(L0/L1) protection
    - 44 -> Room temo. sensor (Ta) fault
    - 45 -> DC fan motor fault
    - 46 -> Voltage protection
    - 47 -> Pressure sensor fault
    - 48 -> Outlet water for zone 2 temp. sensor(Tw2) fault
    - 49 -> Outlet water temp. sensor(Tw_out) fault
    - "50 -> 3 times PP protection and Tw_out<7\u2103"
    - 52 -> Communication fault between hydraulic module parallel
    - 53 -> Communication error between main board and thermostat transfer board
    - 54 -> Inverter module board EE PROM fault
    - 55 -> H6 display 10 times in 2 hours
    - 57 -> Low pressure protection (Pe<0.6) occurred 3 times in 1 hour
    - 65 -> Transducer module temperature too high protection
    - 112 -> PED PCB fault
    - 116 -> Low DC generatrix voltage protection
    - 134 -> Module protection
    - 135 -> DC generatrix low voltage protection
    - 136 -> DC generatrix high voltage protection
    - 138 -> MCE fault
    - 139 -> Zero speed protection
    - 141 -> Phase sequence fault
    - 142 -> Speed difference > 15Hz protection between the front and the back clock
    - 143 -> Speed difference > 15Hz protection between the real and the setting speed
- platform: template
  name: Fault 1 Error Code
  id: ${devicename}_fault_1_error_code
  icon: mdi:alert-circle
  lambda: "int fault_one = id(${devicename}_fault_1).state;\n\nif (fault_one >= 0\
    \ && fault_one <= 143) {\n  return std::to_string(fault_one);\n} else {\n  return\
    \ {\"Unknown\"};\n}"
  filters:
  - map:
    - 0 -> OK
    - 1 -> E0
    - 2 -> E1
    - 3 -> E2
    - 4 -> E3
    - 5 -> E4
    - 6 -> E5
    - 7 -> E6
    - 8 -> E7
    - 9 -> E8
    - 10 -> E9
    - 11 -> EA
    - 12 -> Eb
    - 13 -> Ec
    - 14 -> Ed
    - 15 -> EE
    - 20 -> P0
    - 21 -> P1
    - 23 -> P3
    - 24 -> P4
    - 25 -> P5
    - 26 -> P6
    - 31 -> Pb
    - 33 -> Pd
    - 38 -> PP
    - 39 -> H0
    - 40 -> H1
    - 41 -> H2
    - 42 -> H3
    - 43 -> H4
    - 44 -> H5
    - 45 -> H6
    - 46 -> H7
    - 47 -> H8
    - 48 -> H9
    - 49 -> HA
    - 50 -> Hb
    - 52 -> Hd
    - 53 -> HE
    - 54 -> HF
    - 55 -> HH
    - 57 -> HP
    - 65 -> C7
    - 112 -> bH
    - 116 -> F1
    - 134 -> L0
    - 135 -> L1
    - 136 -> L2
    - 138 -> L4
    - 139 -> L5
    - 141 -> L7
    - 142 -> L8
    - 143 -> L9
- platform: template
  name: Fault 2 Error Code
  id: ${devicename}_fault_2_error_code
  icon: mdi:alert-circle
  lambda: "int fault_two = id(${devicename}_fault_2).state;\n\nif (fault_two >= 0\
    \ && fault_two <= 143) {\n  return std::to_string(fault_two);\n} else {\n  return\
    \ {\"Unknown\"};\n}"
  filters:
  - map:
    - 0 -> OK
    - 1 -> E0
    - 2 -> E1
    - 3 -> E2
    - 4 -> E3
    - 5 -> E4
    - 6 -> E5
    - 7 -> E6
    - 8 -> E7
    - 9 -> E8
    - 10 -> E9
    - 11 -> EA
    - 12 -> Eb
    - 13 -> Ec
    - 14 -> Ed
    - 15 -> EE
    - 20 -> P0
    - 21 -> P1
    - 23 -> P3
    - 24 -> P4
    - 25 -> P5
    - 26 -> P6
    - 31 -> Pb
    - 33 -> Pd
    - 38 -> PP
    - 39 -> H0
    - 40 -> H1
    - 41 -> H2
    - 42 -> H3
    - 43 -> H4
    - 44 -> H5
    - 45 -> H6
    - 46 -> H7
    - 47 -> H8
    - 48 -> H9
    - 49 -> HA
    - 50 -> Hb
    - 52 -> Hd
    - 53 -> HE
    - 54 -> HF
    - 55 -> HH
    - 57 -> HP
    - 65 -> C7
    - 112 -> bH
    - 116 -> F1
    - 134 -> L0
    - 135 -> L1
    - 136 -> L2
    - 138 -> L4
    - 139 -> L5
    - 141 -> L7
    - 142 -> L8
    - 143 -> L9
- platform: template
  name: Fault 3 Error Code
  id: ${devicename}_fault_3_error_code
  icon: mdi:alert-circle
  lambda: "int fault_three = id(${devicename}_fault_3).state;\n\nif (fault_three >=\
    \ 0 && fault_three <= 143) {\n  return std::to_string(fault_three);\n} else {\n\
    \  return {\"Unknown\"};\n}"
  filters:
  - map:
    - 0 -> OK
    - 1 -> E0
    - 2 -> E1
    - 3 -> E2
    - 4 -> E3
    - 5 -> E4
    - 6 -> E5
    - 7 -> E6
    - 8 -> E7
    - 9 -> E8
    - 10 -> E9
    - 11 -> EA
    - 12 -> Eb
    - 13 -> Ec
    - 14 -> Ed
    - 15 -> EE
    - 20 -> P0
    - 21 -> P1
    - 23 -> P3
    - 24 -> P4
    - 25 -> P5
    - 26 -> P6
    - 31 -> Pb
    - 33 -> Pd
    - 38 -> PP
    - 39 -> H0
    - 40 -> H1
    - 41 -> H2
    - 42 -> H3
    - 43 -> H4
    - 44 -> H5
    - 45 -> H6
    - 46 -> H7
    - 47 -> H8
    - 48 -> H9
    - 49 -> HA
    - 50 -> Hb
    - 52 -> Hd
    - 53 -> HE
    - 54 -> HF
    - 55 -> HH
    - 57 -> HP
    - 65 -> C7
    - 112 -> bH
    - 116 -> F1
    - 134 -> L0
    - 135 -> L1
    - 136 -> L2
    - 138 -> L4
    - 139 -> L5
    - 141 -> L7
    - 142 -> L8
    - 143 -> L9
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Operating Mode
  id: ${devicename}_operating_mode
  icon: mdi:state-machine
  register_type: holding
  address: 101
  response_size: 2
  lambda: 'int idx = item->offset;

    uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);

    std::string output = "Unknown: ";

    output += to_string(rawdata);

    if (rawdata == 0) output = "OFF";

    else if (rawdata == 2) output = "Cooling";

    else if (rawdata == 3) output = "Heating";

    else if (rawdata == 5) output = "DHW Heating";

    // ESP_LOGI("Register 101","Operating mode %s (%d)", output.c_str(), rawdata);

    return output;'
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Home Appliance Type
  id: ${devicename}_home_appliance_type
  icon: mdi:state-machine
  register_type: holding
  address: 200
  response_size: 2
  raw_encode: HEXBYTES
  lambda: "int idx = item->offset;\nstd::string z = \"\";\nuint16_t rawdata = (uint16_t(data[idx])\
    \ << 8) + uint16_t(data[idx + 1]);\n// ESP_LOGI(\"Register 200\", \"The home appliance\
    \ type is 0x%x\", rawdata);\nif ((rawdata >> 8) == 7) {\n  z = \"Air to water\
    \ heat pump\";\n} else {\n  z = std::to_string(data[idx]);\n}\nreturn {z};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Home Appliance Sub Type
  id: ${devicename}_home_appliance_sub_type
  icon: mdi:information-box-outline
  register_type: holding
  address: 200
  response_size: 2
  raw_encode: HEXBYTES
  lambda: "int idx = item->offset;\nstd::string z = \"\";\nuint16_t rawdata = (uint16_t(data[idx])\
    \ << 8) + uint16_t(data[idx + 1]);\n// ESP_LOGI(\"Register 200\", \"The home appliance\
    \ sub type is 0x%x\", rawdata);\nif (((rawdata & 0x000F) ) == 2) {\n  z = \"R32\"\
    ;\n} else {\n  z = std::to_string(rawdata & 0x0F) ;\n}\nreturn {z};"
- platform: modbus_controller
  modbus_controller_id: ${devicename}
  name: Home Appliance Product Code
  id: ${devicename}_home_appliance_product_code
  icon: mdi:information-box-outline
  register_type: holding
  response_size: 2
  raw_encode: HEXBYTES
  address: 200
  lambda: "int idx = item->offset;\nstd::string z = \"\";\nuint16_t rawdata = (uint16_t(data[idx])\
    \ << 8) + uint16_t(data[idx + 1]);\n// ESP_LOGI(\"Register 200\", \"The home appliance\
    \ product code is 0x%x rawdata \", rawdata);\nif (((rawdata & 0x00F0) >> 4) ==\
    \ 4) {\n  z = \"4\";\n} else {\n  z = std::to_string((rawdata & 0x00F0) >> 4);\n\
    }\nreturn {z};"
- platform: template
  name: SM Recovery Heating DHW time at
  id: ${devicename}_recovery_heating_dhw_time_at
  icon: mdi:clock
  entity_category: diagnostic
  update_interval: 15s
  lambda: "time_t dur = id(manually_disabled_dhw_heating_timestamp) + (time_t)(id(${devicename}_restore_time_heat_dhw_after_turn_off).state\
    \ * 60);// - (id(esptime).now().timestamp - id(manually_disabled_dhw_heating_timestamp));\n\
    char time_str[30];\nESP_LOGI(\"text_sensor\", \"dur: %li, manually_disabled_dhw_heating_timestamp:\
    \ %li, _restore_time_heat_dhw_after_turn_off: %li, stan: %s:%s\", (long int)dur,\
    \ (long int)id(manually_disabled_dhw_heating_timestamp),  (long int)id(${devicename}_restore_time_heat_dhw_after_turn_off).state,\
    \ id(Restore_enable_DHW)?\"ON\":\"OFF\", id(${devicename}_enable_recoverytime_enable_dhw).state?\"\
    Yes\":\"No\");\nif (dur > (id(${devicename}_restore_time_heat_dhw_after_turn_off).state\
    \ * 60) and id(Restore_enable_DHW)) {\n  time_t time_at = dur;\n  strftime(time_str,\
    \ sizeof(time_str), \"%H:%M\", localtime(&time_at));  //%Y-%m-%d \n} else sprintf(time_str,\
    \ \"N/D\");\nESP_LOGI(\"text_sensor\", \"recovery_heating_dhw_time_at: %s Enable\
    \ Recovery mode: %s\", time_str, id(${devicename}_enable_recoverytime_enable_dhw).state?\"\
    Yes\":\"No\");\nreturn {time_str};"
- platform: template
  name: SM Recovery Heating/Cooling Zone1 time at
  id: ${devicename}_recovery_heating_cooling_zone1_time_at
  icon: mdi:clock
  entity_category: diagnostic
  update_interval: 15s
  lambda: "time_t dur = id(manually_disabled_zone1_heating_timestamp) + (time_t)(id(${devicename}_restore_time_heat_zone1_after_turn_off).state*60);\
    \ \nchar time_str[30];\nif (dur > (id(${devicename}_restore_time_heat_zone1_after_turn_off).state\
    \ * 60) and id(Restore_enable_Zone1)) {\n  time_t time_at = dur;\n  strftime(time_str,\
    \ sizeof(time_str), \"%H:%M\", localtime(&time_at));  //%Y-%m-%d \n} else sprintf(time_str,\
    \ \"N/D\");\nESP_LOGI(\"text_sensor\", \"recovery_heating_cooling_zone1_time_at:\
    \ %s Enable Recovery mode: %s\", time_str, id(${devicename}_enable_recoverytime_enable_zone1).state?\"\
    Yes\":\"No\");\nreturn {time_str};"
- platform: template
  name: SM Recovery Heating/Cooling Zone2 time at
  id: ${devicename}_recovery_heating_cooling_zone2_time_at
  icon: mdi:clock
  entity_category: diagnostic
  update_interval: 15s
  lambda: "time_t dur = id(manually_disabled_zone2_heating_timestamp) + (time_t)(id(${devicename}_restore_time_heat_zone2_after_turn_off).state\
    \ * 60);\nchar time_str[30];\nif (dur > (id(${devicename}_restore_time_heat_zone2_after_turn_off).state\
    \ * 60) and id(Restore_enable_Zone2)) {\n  time_t time_at = dur;\n  strftime(time_str,\
    \ sizeof(time_str), \"%H:%M\", localtime(&time_at));  //%Y-%m-%d \n} else sprintf(time_str,\
    \ \"N/D\");\nESP_LOGI(\"text_sensor\", \"recovery_heating_cooling_zone2_time_at:\
    \ %s Enable Recovery mode: %s\", time_str, id(${devicename}_enable_recoverytime_enable_zone2).state?\"\
    Yes\":\"No\");\nreturn {time_str};    "
- platform: template
  name: SM Last time PUMP_I Run At
  id: ${devicename}_water_pump_i_runtime_at
  icon: mdi:clock
  entity_category: diagnostic
  update_interval: 15s
  lambda: "time_t dur = id(timestamp_water_pump_timestamp_last_run);\nchar time_str[30];\n\
    if (dur > 0) {\n  time_t time_at = dur;\n  strftime(time_str, sizeof(time_str),\
    \ \"%H:%M\", localtime(&time_at));  //%Y-%m-%d \n} else sprintf(time_str, \"N/D\"\
    );\nESP_LOGI(\"text_sensor\", \"water_pump_i_runtime_at: %s\", time_str);\nreturn\
    \ {time_str};"
