substitutions:
  devicename: heatpump
  description: Heatpump Controller
  device_description: "${description} YORK YKF09CNC 9kW Monoblock via Modbus "
  modbus_address: "11"                              #modbus address of heatpump
  # id(${devicename}_temp_secure_antifreeze).state: '30'                      #activate antifreeze external pump under this temp T4 val if PUMP_I don't run for specific time
  # id(${devicename}_gl_dhw_minimal_temp: '32'                         #minimal DHW accepted temp -below is auto activate T5s DHW heat
  
  #Add this to secrets to update update key by ota and to enable api in homeassistant
  #heatpump_controller_ota_password: "OTA_PASSWORD"
  #heatpump_controller_api_encryption: "API_KEY"
  # wifi_ssid: "WIFI_SSID"
  # wifi_password: "WIFI_PASSWORD"
  # wifi_ap_password: "wifi_captive_accessPoint_password"
  # web_server_username: "web_panel_username"
  # web_server_password: "web_panel_password"
  # #built-in led intervals light on/light off makes blinks
  # led_light_slow1s_on: "500ms"
  # led_light_slow1s_off: "1000ms"
  # led_light_slow_on: "500ms"
  # led_light_slow_off: "500ms"
  # led_light_fast_on:  "200ms"
  # led_light_fast_off":  "200ms"
  ##And update modbus_tx_pin, modbus_rx_pin and flow_control_pin in uart: modbus: and modbus_controller: sections

globals:
  - id: unmasked_value_register_0
    type: uint16_t
    restore_value: true
    # initial_value: '0'
  - id: unmasked_value_register_5
    type: uint16_t
    restore_value: true
    # initial_value: '0'
  - id: unmasked_value_register_210
    type: uint16_t
    restore_value: true
    # initial_value: '0'
  - id: unmasked_value_register_211
    type: uint16_t
    restore_value: true
    # initial_value: '0'    
  - id: unmasked_value_water_temperature_t1s
    type: uint16_t
    restore_value: true
    # initial_value: '0'    
  - id: unmasked_curve_selection
    type: uint16_t
    restore_value: true
    # initial_value: '0'    
  - id: unmasked_value_register_270
    type: uint16_t          #this is modbus so better is use uint16_t than int
    restore_value: true
    # initial_value: '0'    
  - id: unmasked_value_register_272
    type: uint16_t
    restore_value: true
    # initial_value: '0'
  - id: manually_disabled_dhw_heating_timestamp
    type: int32_t
    restore_value: true
    # initial_value: '0'
  - id: manually_disabled_zone1_heating_timestamp
    type: int32_t
    restore_value: true
    # initial_value: '0'
  - id: manually_disabled_zone2_heating_timestamp
    type: int32_t
    restore_value: true    
    # initial_value: '0'
  - id: timestamp_water_pump_timestamp_last_run
    type: int32_t
    restore_value: true
    # initial_value: '0'

  - id: tempereture_avg_last_hour
    type: float
    restore_value: true
    # initial_value: '0'
  - id: tempereture_avg_last_24h
    type: float
    restore_value: true
    # initial_value: '0'
  - id: relay1_start
    type: int32_t
    restore_value: true
    # initial_value: '0'
  - id: relay2_start
    type: int32_t
    restore_value: true
    # initial_value: '0'
  - id: external_temp_sensor_avg_rooms_temp_saved
    type: float
    restore_value: true
    # initial_value: '0'
  - id: Restore_enable_DHW
    type: bool
    initial_value: 'true'
    restore_value: true
    # initial_value: '0'
  - id: Restore_enable_Zone1
    type: bool
    restore_value: true
    # initial_value: '0'
  - id: Restore_enable_Zone2
    type: bool
    restore_value: true
    # initial_value: "0"    
  - id: Restore_time_dhw
    type: uint16_t
    restore_value: true    
    # initial_value: '210'
  - id: Restore_time_zone1
    type: uint16_t
    restore_value: true    
    # initial_value: "210"
  - id: Restore_time_zone2
    type: uint16_t
    restore_value: true    
    # initial_value: "210"    

esphome:
  name: "${devicename}"
  comment: "${device_description}"
  friendly_name: "${description}"
  project:
    name: !secret "Project_info"
    version: 4.0.3
  on_boot:
    ## configure controller settings at setup
    priority: 500
    then:
      - lambda: id(${devicename}_outdoor_ambient_temperature_hourly).publish_state(id(tempereture_avg_last_hour));
      - lambda: id(${devicename}_outdoor_ambient_temperature_daily).publish_state(id(tempereture_avg_last_24h));
      - lambda: 'id(${devicename}_enable_recoverytime_enable_dhw).publish_state(true);' #Restore_enable_DHW));
      - lambda: 'id(${devicename}_enable_recoverytime_enable_zone1).publish_state(true);' #id(Restore_enable_Zone1));
      - lambda: 'id(${devicename}_enable_recoverytime_enable_zone2).publish_state(false);' #id(Restore_enable_Zone2));
    #this allow change ota password for next upload
    #id(my_ota).set_auth_password(!secret "heatpump_controller_ota_password");
esp32:
  board: wemos_d1_mini32 #esp32dev
  framework:
    type: esp-idf  #arduino
    # restore_from_flash: true  #for Eesp8266
    

preferences:
  flash_write_interval: 55min
  


# Enable logging
logger:
  level: INFO
  # level: NONE, WARN, INFO, DEBUG
  # hardware_uart: UART1
  baud_rate: 0 #disables HW logger to avoid conflicts with modbus communication
 
# Enable Home Assistant API
api:
  encryption:
    key: !secret "heatpump_controller_api_encryption"
  on_client_connected:
    - if:
        condition:
          lambda: 'return (0 == client_info.find("Home Assistant "));' 
        then:
          - light.turn_on: 
              id: wifi_led
              effect: blink_slow1s
          
  on_client_disconnected:
    - if:
        condition:
          lambda: 'return (0 == client_info.find("Home Assistant "));' 
        then:
          - light.turn_on: 
              id: wifi_led
              effect: blink_fast   #wifi_led
################################################################################################################################
web_server:
  port: 80
  log: true
  auth:
    username: !secret web_server_username
    password: !secret web_server_password
  include_internal: true
  version: 3
  local: true
################################################################################################################################
ota:
  platform: esphome
  id: "my_ota"
  password: !secret "heatpump_controller_ota_password"
################################################################################################################################
wifi:
  ssid: !secret "wifi_ssid"
  password: !secret "wifi_password"
  use_address: 10.48.18.61
  enable_on_boot: true
  power_save_mode: none
  on_connect: 
    then: 
      - light.turn_on:
          id: wifi_led
          effect: blink_slow

  on_disconnect: 
    then: 
      light.turn_off: wifi_led

  ap:
    ssid: "${devicename}-setup"
    password: !secret "wifi_ap_password"
################################################################################################################################
captive_portal:
################################################################################################################################
uart:
  id: mod_bus
  tx_pin: GPIO3 #"17"
  rx_pin: GPIO1 #"16"
  baud_rate: 9600
  data_bits: 8
  parity: NONE # NONE, EVEN, ODD.
  stop_bits: 1
################################################################################################################################
modbus:
  #flow_control_pin: 5
  id: heatpump_modbus
  send_wait_time: 500ms
  #read_wait_time: 200ms
  role: client
################################################################################################################################
modbus_controller:
  - id: "${devicename}"
    ## the Modbus device addr
    address: ${modbus_address}
    modbus_id: heatpump_modbus
    setup_priority: -10
    update_interval: 30s
    offline_skip_updates: 0
################################################################################################################################
output:
    #platform: slow_pwm
  - platform: gpio
    pin: GPIO2
    id: blue_led
    #period: 1500ms
    inverted: false
################################################################################################################################
light:
  - platform: binary
    id: "wifi_led"
    output: "blue_led"
    internal: true
    icon: mdi:led-on
    entity_category: "diagnostic"
    effects:
      - strobe:
          name: "blink_slow1s"
          colors:
            - state: true
              duration: !secret "led_light_slow1s_on" #500ms
            - state: false
              duration: !secret "led_light_slow1s_off" #1000ms
      - strobe:
          name: "blink_slow"
          colors:
            - state: true
              duration: !secret "led_light_slow_on" #500ms
            - state: false
              duration: !secret "led_light_slow_off" #500ms
      - strobe:
          name: "blink_fast"
          colors:
            - state: true
              duration: !secret "led_light_fast_on"  #200ms
            - state: false
              duration: !secret "led_light_fast_off"  #200ms
################################################################################################################################
button:
  - platform: restart
    name: "Restart"
    id: "${devicename}_restart"
    icon: mdi:lock-reset
    entity_category: "diagnostic"
  - platform: factory_reset
    name: "Restart with Controller Factory Default Settings -not Heat Pump"
    id: "${devicename}_factory_reset_and_restart"
    icon: mdi:lock-reset
    entity_category: "diagnostic"
################################################################################################################################
time:
  - platform: homeassistant
    id: esptime
    on_time_sync: 
      then:
        - logger.log: "Synchronized System Clock from HomeAssisatnt"
    on_time:
      - months: 1-4, 10-12
        hours: /8
        minutes: 35
        seconds: 0
        then:
            - lambda: |-
                  auto m1_mode = id( ${devicename}_operational_mode).make_call();
                  m1_mode.set_option("Heat");
                  m1_mode.perform();
                  ESP_LOGE("time","Change to HEAT and update deltas");
                  float new_delta = 5.0F;
                  auto delta_dt1s5 = id(${devicename}_dt1s5).make_call();
                  delta_dt1s5.set_value(new_delta);
                  delta_dt1s5.perform();
                  auto delta_dt1sh = id(${devicename}_dt1sh).make_call();
                  delta_dt1sh.set_value(new_delta);
                  delta_dt1sh.perform();
                  auto delta_dtsh = id(${devicename}_dtsh).make_call();
                  delta_dtsh.set_value(new_delta);
                  delta_dtsh.perform();  
              #add in 1h interval set T1s depends on T4 ambient temp from calculation
            - logger.log: "Enable Winter Mode -change behavior to HEATING"
      - months: 5-9
        hours: /8
        minutes: 35
        seconds: 0
        then:
            - lambda: |-
                auto m1_mode = id( ${devicename}_operational_mode).make_call();
                m1_mode.set_option("Cool");
                m1_mode.perform();
                ESP_LOGE("time","Change to COOL and update deltas");
                float new_delta = 7.0F;
                auto delta_dt1s5 = id(${devicename}_dt1s5).make_call();
                delta_dt1s5.set_value(new_delta);
                delta_dt1s5.perform();
                auto delta_dt1sc = id(${devicename}_dt1sc).make_call();
                delta_dt1sc.set_value(new_delta);
                delta_dt1sc.perform();
                auto delta_dtsc = id(${devicename}_dtsc).make_call();
                delta_dtsc.set_value(new_delta);
                delta_dtsc.perform();
            #change T1 set temp to 5 ;)
            - logger.log: "Enable Summer Mode -change behavior to COOLING"
      - hours: 6
        minutes: /14
        seconds: 0
        then:
            - number.set: 
                  #set delta DHW to 5degree for day
                  id: ${devicename}_dt5_on
                  value: !lambda "return float( ( (id(esptime).now().month > 9) or (id(esptime).now().month < 5) )? 7 : 5);"
                  #for winter return delta 7, for summer delta 5
                  #value: 5
            - logger.log: "CHANGE DELTA FOR DHW WATER HEATING for day to 5deg"
      - hours: 18
        minutes: /14
        seconds: 0
        then:
            - number.set: 
                  #set delta DHW to reach minimum wanted DHW temp to allow drop
                  id: ${devicename}_dt5_on
                  value: !lambda "return (float(id(${devicename}_set_dhw_tank_temperature_t5s).state) - float(id(${devicename}_gl_dhw_minimal_temp).state) + 1);"
            - logger.log: "CHANGE DELTA FOR DHW WATER HEATING to ~32deg for night (Actual set DHW temp to which is heated - minimal accepted temp for DHW + 1)"        
################################################################################################################################
interval:
  - interval: 1min
    then:
      - lambda: |-
            if (!id(esptime).is_failed()) {
              //Check at start if dhw or heat/cool zone 1&2 is disabled
              if (!id(${devicename}_power_dhw_t5s).state and id(manually_disabled_dhw_heating_timestamp) == 0 and id(Restore_enable_DHW)==1) id(manually_disabled_dhw_heating_timestamp) = id(esptime).now().timestamp;
              if (!id(${devicename}_water_flow_temperature_control_zone_1).state and id(manually_disabled_zone1_heating_timestamp) == 0 and id(Restore_enable_Zone1)==1) id(manually_disabled_zone1_heating_timestamp) = id(esptime).now().timestamp;;
              if (!id(${devicename}_water_flow_temperature_control_zone_2).state and id(manually_disabled_zone2_heating_timestamp) == 0 and id(Restore_enable_Zone2)==1) id(manually_disabled_zone2_heating_timestamp) = id(esptime).now().timestamp;;
              //check when dhw or zone1 or zone2 heat is disabled -enable if timer to enable elapsed
              int32_t duration_dhw_timer_elapsed = 0;
              if (id(manually_disabled_dhw_heating_timestamp) > 0 and id(Restore_enable_DHW)==1) {
                duration_dhw_timer_elapsed = id(esptime).now().timestamp - id(manually_disabled_dhw_heating_timestamp);
                if (duration_dhw_timer_elapsed > (id(${devicename}_restore_time_heat_dhw_after_turn_off).state * 60)) {
                  id(${devicename}_power_dhw_t5s).turn_on();
                  ESP_LOGE("TIMER 1h", "Enable DHW Heating");
                }
              }
              int32_t duration_zone1_timer_elapsed = 0;
              if (id(manually_disabled_zone1_heating_timestamp) > 0 and id(Restore_enable_Zone1)==1) {
                duration_zone1_timer_elapsed = id(esptime).now().timestamp - (int32_t)id(manually_disabled_zone1_heating_timestamp);
                if (duration_zone1_timer_elapsed > (id(${devicename}_restore_time_heat_zone1_after_turn_off).state * 60)) {
                  id(${devicename}_water_flow_temperature_control_zone_1).turn_on();
                  ESP_LOGE("TIMER 1h", "Enable Zone1 Heating/cooling");
                }
              }
              int32_t duration_zone2_timer_elapsed = 0;
              if (id(manually_disabled_zone2_heating_timestamp) > 0 and id(Restore_enable_Zone2)==1) {
                duration_zone2_timer_elapsed = id(esptime).now().timestamp - (int32_t)id(manually_disabled_zone2_heating_timestamp);
                if (duration_zone2_timer_elapsed > (id(${devicename}_restore_time_heat_zone2_after_turn_off).state * 60)) {
                  id(${devicename}_water_flow_temperature_control_zone_2).turn_on();
                  ESP_LOGE("TIMER 1h", "Enable Zone2 Heating/cooling");
                }
              }

              //Secure heatpump from pipe freeze -if pump_i don't run in last hour start external pump for eg. 5 minutes and add when load PUMP_I is active disable relay
              float ext_t4_temp = id(${devicename}_outdoor_ambient_temperature).state;
              bool pump_i_status = id(${devicename}_load_output_water_pump_pump_i).state;
              int32_t duration_pump_i_lastrun = 0;
              ESP_LOGI("time","PUMP_I last run now:%li, pump_ts %i, duration: %i, outside temp %f", id(esptime).now().timestamp, id(timestamp_water_pump_timestamp_last_run), duration_pump_i_lastrun, ext_t4_temp);
              if (id(timestamp_water_pump_timestamp_last_run) > 0) {
                duration_pump_i_lastrun = id(esptime).now().timestamp - id(timestamp_water_pump_timestamp_last_run);
                if (duration_pump_i_lastrun > ((int32_t)id(${devicename}_pump_i_antifrize_check_last_run_interval).state * 60) and !pump_i_status and ext_t4_temp < float(id(${devicename}_temp_secure_antifreeze).state) ) {
                  //start external relay if pump_i not active in last hour with external temp under declared val
                  ESP_LOGE("time start relay pump","PROCEDURE START RELAY PUMP");
                  id(${devicename}_relay1_external_pump).turn_on();  //#################
                  id(${devicename}_relay2_external_pump).turn_on();   //###################
                }
              }
              //check how long external switch was on -if more than 5 minutes -turn off
              int32_t duration_relay1_active = id(esptime).now().timestamp - (int32_t)id(relay1_start);
              if (duration_relay1_active > (id(${devicename}_output_external_pump_for_antifreeze_relay1).state * 60) and id(relay1_start) > 0) {
                ESP_LOGI("timestamp relay","Relay1 Stops %um", duration_relay1_active);
                id(${devicename}_relay1_external_pump).turn_off();   //#########################
              }
              int32_t duration_relay2_active = id(esptime).now().timestamp - (int32_t)id(relay2_start);
              if (duration_relay2_active > (id(${devicename}_external_relay_timer).state * 60) and id(relay2_start) > 0) {
                ESP_LOGI("timestamp relay","Relay2 Stops %u", duration_relay2_active);
                id(${devicename}_relay2_external_pump).turn_off();   //#################
              }
            }
  - interval: 15min
    then:
      - lambda: |-
                if (!id(esptime).is_failed()) {

                  //calculate curve and set T1s
                  //${devicename}_temperature_t1s_zone1      set_water_temperature_t1s_zone_1
                  auto operation_state = id(${devicename}_operational_mode).state;
                  ESP_LOGI("TIME", "Setting temp for mode .%s. compare: %s", operation_state.c_str(), (operation_state == "Cool")?"YES":"NO");
                    
                    //calculae curve
                    float ext_t4_temp = id(${devicename}_outdoor_ambient_temperature).state;
                    float calculated_temp = 35;
                    float avg_temp;
                    if (${devicename}_outdoor_ambient_temperature_daily != 0) {
                      avg_temp = id(${devicename}_outdoor_ambient_temperature_daily).state;
                    } else if (${devicename}_outdoor_ambient_temperature_hourly != 0) {
                      avg_temp = id(${devicename}_outdoor_ambient_temperature_hourly).state;
                    } else avg_temp = id(${devicename}_outdoor_ambient_temperature).state;
                    //Arduino map implementation 
                    //long map(long xx, long in_min, long in_max, long out_min, long out_max){
                    //return (xx - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;}
                    float xx, in_min, in_max, out_min, out_max;
                    //float temp_floorheat = map(avg_temp, -20, 15, 50, 25); //zmapuj zakres zewnatrz gdy -20 to grzej 50 a gdy zewnatrz 15 grzej 15
                    xx = avg_temp;
                    in_min = -20;
                    in_max = 15;
                    out_min = 50;
                    out_max = 25;
                    float temp_floorheat = (xx - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
                    xx = temp_floorheat;
                    in_min = 50;
                    in_max = 25;
                    out_min = 50;
                    out_max = 35;                    
                    //calculated_temp = map(temp_floorheat, 50, 25, 50, 35);
                    calculated_temp = (xx - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;

                    if (calculated_temp < 30) calculated_temp = 30;
                    calculated_temp *= 0.2;
                    ESP_LOGI("interval5min", "Calculated curve for heating my without room temps is %f", calculated_temp);
                    id(${devicename}_calculated_curve).publish_state(calculated_temp);


                    float baseTemp = calculated_temp; // Flow temperature at 0°C outdoor
                    float tempChangePerDegree = 1.0; // Flow temperature increase per degree drop in outdoor temperature
                    // Calculate temperature difference from desired room temperature
                    float tempDifference = 22.0 - float(id(${devicename}_external_temp_sensor_avg_rooms_temp).state);    //22 is wanted room temp
                    if (avg_temp < 0) {
                       calculated_temp = baseTemp + (-avg_temp) * tempChangePerDegree + (tempDifference * 1.5);
                    } else {
                      calculated_temp = baseTemp - avg_temp * (tempChangePerDegree / 2) + (tempDifference * 1.5);
                    }

                      //float temp_floorheat = map(srednia, -20, 15, 50, 25); //zmapuj zakres zewnatrz gdy -20 to grzej 50 a gdy zewnatrz 15 grzej 15
                      //float setT1STempZone1 = map(temp_floorheat, 50, 25, 50, 35);
                      //*0.2
                    ESP_LOGI("interval5min", "Calculated curve for heating is %f", calculated_temp);
                    id(${devicename}_calculated_curve2).publish_state(calculated_temp);
                    //arduino map implementation
                    xx = id(${devicename}_external_temp_sensor_avg_rooms_temp).state;
                    in_min = 19.5;
                    in_max = 22;
                    out_min = 45;
                    out_max = 28;                    
                    float temp_curve = (xx - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
                    //float temp_curve = map(id(${devicename}_external_temp_sensor_avg_rooms_temp).state, 19.5, 22, 45, 28);

                    calculated_temp = temp_curve;
                    ESP_LOGI("interval5min", "Calculated curve 3 for heating is %f", temp_curve);
                    id(${devicename}_calculated_curve3).publish_state(temp_curve);


                  //Set Heating/Cooling temp of Zone 1 calculated
                  if (operation_state == "Cool") {
                    auto t1s_zone_1 = id(${devicename}_set_water_temperature_t1s_zone_1).make_call();
                    t1s_zone_1.set_value(5);
                    t1s_zone_1.perform(); 
                    ESP_LOGI("TIME", "Setting temp for Cool mode %d", 5);
                  } else if (operation_state == "Heat" or operation_state == "Auto") {
                    auto t1s_zone_1 = id(${devicename}_set_water_temperature_t1s_zone_1).make_call();
                    if (calculated_temp < 29) calculated_temp = 29;
                    t1s_zone_1.set_value(calculated_temp);
                    t1s_zone_1.perform();
                    ESP_LOGI("TIME", "Setting temp for Heat mode %f Out Temp %f", calculated_temp, ext_t4_temp);
                  }
                }
  - interval: 2h
    then:
        #neccesserry default values turn on
        #maybe: Make heat pump silent at night between 22 and 6 am  YorkM5functionMOde   bitSet(tmptemp, 6);    //SilentMode              bitClear(tmptemp, 7);  //SuperSilent      
        #I use only zone 1 -actually this is buffer -not directly to radiators -this is much better choice, in cooling i cool buffer. Enabling air conditioner is different functionallity ;(
        #after setting any of values below heat pump turn off heating/cooling
      - lambda: |-
          bool essential_changed = false;
          if (!id(${devicename}_p_s_1_heating_and_cooling_first_or_water_first).state) {
            id(${devicename}_p_s_1_heating_and_cooling_first_or_water_first).publish_state(true);
            essential_changed = true;
            ESP_LOGI("interval12h", "Set p_s_1_heating_and_cooling_first_or_water_first");
          }
          if (!id(${devicename}_p_s_1_enable_heating).state) {
            id(${devicename}_p_s_1_enable_heating).publish_state(true);
            essential_changed = true;
            ESP_LOGI("interval12h", "Set p_s_1_enable_heating");
          }
          if (!id(${devicename}_p_s_1_enable_cooling).state) {
            id(${devicename}_p_s_1_enable_cooling).publish_state(true);
            essential_changed = true;
            ESP_LOGI("interval12h", "Set p_s_1_enable_cooling");
          }
          if (!id(${devicename}_p_s_1_enable_water_heating).state) {
            id(${devicename}_p_s_1_enable_water_heating).publish_state(true);
            essential_changed = true;
            ESP_LOGI("interval12h", "Set p_s_1_enable_water_heating");
          }
          //#update heat and cool end for zone 1 -i use buffer to cool so I need to set for cool "Fan Coil Unit" which enables temp range 5-25 degree
          auto zone1_cooling_end_state = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;
          if (zone1_cooling_end_state != "Fan Coil Unit") {
            auto zone1_cooling_end = id(${devicename}_zone_1_end_cooling_mode_emission_type).make_call();
            zone1_cooling_end.set_option("Fan Coil Unit");
            zone1_cooling_end.perform();
            essential_changed = true;
            ESP_LOGI("interval12h", "Set Zone 1 Cooling to Fan Coil Unit was: %s", zone1_cooling_end_state.c_str());
          }
          //#Radiator and Fan Coil Unit enables temp range 35 to 65degree i want below 35 ;)
          auto zone1_heating_end_state = id(${devicename}_zone_1_end_heating_mode_emission_type).state;
          if (zone1_heating_end_state != "Underfloor Heating") {
            auto zone1_heating_end = id(${devicename}_zone_1_end_heating_mode_emission_type).make_call();
            zone1_heating_end.set_option("Underfloor Heating");
            zone1_heating_end.perform();
            essential_changed = true;
            ESP_LOGI("interval12h", "Set Zone 1 heating to Underfloor Heating was: %s", zone1_heating_end_state.c_str());
          }
          if (essential_changed) {
            //some essential parameter was chanagedd so Heat pump disable heat -so enable it now -this is not manual disable
            if (id(Restore_enable_DHW)==1) id(${devicename}_power_dhw_t5s).turn_on();
            if (id(Restore_enable_Zone1)==1) id(${devicename}_water_flow_temperature_control_zone_1).turn_on();
            if (id(Restore_enable_Zone2)==1) id(${devicename}_water_flow_temperature_control_zone_2).turn_on();
            ESP_LOGI("interval12h", "ReEnable %s%s%s Heat/Cool after change essentials (enable heating/cooling/DHW/DHW first/change emmissions...etc)", id(Restore_enable_DHW)?"DHW":"", id(Restore_enable_Zone1)?" and Zone1":"", id(Restore_enable_Zone2)?" and Zone2":"");
          }

################################################################################################################################
select:
  # Register: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Operational Mode"
    id: "${devicename}_operational_mode"
    icon: "mdi:fan"
    address: 0x1
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Heat": 3
      "Cool": 2
      "Auto": 1
  # Register: 269, default: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Input Limitation to"
    id: "${devicename}_power_input_limitation_type"
    address: 0x10d
    value_type: U_WORD
    optimistic: true
    icon: mdi:state-machine
    optionsmap:
      "None": 0
      "1": 1
      "2": 2
      "3": 3
      "4": 4
      "5": 5
      "6": 6
      "7": 7
      "8": 8
  # Register: 272 (bits 0-3), default: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 1 End Heating Mode Emission Type"
    id: "${devicename}_zone_1_end_heating_mode_emission_type"
    address: 0x110
    value_type: U_WORD
    optimistic: true
    icon: mdi:heat-wave
    optionsmap:
      "Fan Coil Unit": 0
      "Radiator": 1
      "Underfloor Heating": 2
    lambda: |-
      // Update the global var unmasked_value_register_272
      id(unmasked_value_register_272) = x;

      // ESP_LOGI("","unmasked_value_register_272: %d",id(unmasked_value_register_272));

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      //ESP_LOGI("","zone2_c_emission is %d, zone1_c_emission is %d, zone2_h_emission is %d, zone1_h_emission is %d", zone2_c_emission, zone1_c_emission, zone2_h_emission, zone1_h_emission);

      // Map/dictionary with the possible values
      std::map<int, std::string> emission_options;
      emission_options[0] = "Fan Coil Unit";
      emission_options[1] = "Radiator";
      emission_options[2] = "Underfloor Heating";

      return emission_options[zone1_h_emission];
    write_lambda: |-
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte;                            // New byte value with the heating emission type for zone 1
      if (x ==  "Fan Coil Unit") value_byte = 0;                            // New byte value with the heating emission type for zone 1
      else if (x ==  "Radiator") value_byte = 1;
      else if (x ==  "Underfloor Heating") value_byte = 2;
      else value_byte = 0;
      ESP_LOGI("zone1_h_emission", "Set option to %s (%d)", x.c_str(), value_byte);
      new_value &= 0xFFF0;     // Clear the first 4 bits
      new_value |= value_byte; // Set the first 4 bits with the new value

      ESP_LOGI("zone1_h_emission", "Set option to %s, Original value: %d New value: %d", x.c_str(), id(unmasked_value_register_272), new_value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  # Register: 272 (bits 4-7), default: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 End Heating Mode Emission Type"
    id: "${devicename}_zone_2_end_heating_mode_emission_type"
    address: 0x110
    value_type: U_WORD
    optimistic: true
    icon: mdi:heat-wave
    optionsmap:
      "Fan Coil Unit": 0
      "Radiator": 1
      "Underfloor Heating": 2
    lambda: |-
      // Updating the global var unmasked_value_register_272 is already done
      // in the first part of this register
      // ESP_LOGI("","unmasked_value_register_272: %d",id(unmasked_value_register_272));
      id(unmasked_value_register_272) = x;

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      //ESP_LOGI("","zone2_c_emission is %d, zone1_c_emission is %d, zone2_h_emission is %d, zone1_h_emission is %d", zone2_c_emission, zone1_c_emission, zone2_h_emission, zone1_h_emission);

      // Map/dictionary with the possible values
      std::map<int, std::string> emission_options;
      emission_options[0] = "Fan Coil Unit";
      emission_options[1] = "Radiator";
      emission_options[2] = "Underfloor Heating";

      return emission_options[zone2_h_emission];
    write_lambda: |-
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte;
      if (x ==  "Fan Coil Unit") value_byte = 0;                            // New byte value with the heating emission type for zone 1
      else if (x ==  "Radiator") value_byte = 1;
      else if (x ==  "Underfloor Heating") value_byte = 2;
      else value_byte = 0;
      ESP_LOGI("zone2_h_emission", "Set option to %s (0x%x)", x.c_str(), value_byte);


      new_value &= 0xFF0F;             // Clear the second pair of 4 bits
      new_value |= (value_byte << 4);  // Set the second pair of 4 bits with the new value

      ESP_LOGI("zone2_h_emission", "Set option to %s, Original value: %d New value: %d", x.c_str(), id(unmasked_value_register_272), new_value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  # Register: 272 (bits 8-11), default: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 1 End Cooling Mode Emission Type"
    id: "${devicename}_zone_1_end_cooling_mode_emission_type"
    address: 0x110
    value_type: U_WORD
    optimistic: true
    icon: mdi:heat-wave
    optionsmap:
      "Fan Coil Unit": 0
      "Radiator": 1
      "Underfloor Heating": 2
    lambda: |-
      // Updating the global var unmasked_value_register_272 is already done
      // in the first part of this register
      // ESP_LOGI("","unmasked_value_register_272: %d",id(unmasked_value_register_272));
      id(unmasked_value_register_272) = x;

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      //ESP_LOGI("","zone2_c_emission is %d, zone1_c_emission is %d, zone2_h_emission is %d, zone1_h_emission is %d", zone2_c_emission, zone1_c_emission, zone2_h_emission, zone1_h_emission);

      // Map/dictionary with the possible values
      std::map<int, std::string> emission_options;
      emission_options[0] = "Fan Coil Unit";
      emission_options[1] = "Radiator";
      emission_options[2] = "Underfloor Heating";

      return emission_options[zone1_c_emission];
    write_lambda: |-
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte;
      if (x ==  "Fan Coil Unit") value_byte = 0;                            // New byte value with the heating emission type for zone 1
      else if (x ==  "Radiator") value_byte = 1;
      else if (x ==  "Underfloor Heating") value_byte = 2;
      else value_byte = 0;
      ESP_LOGI("zone1_c_emission", "Set option to %s (%d)", x.c_str(), value_byte);

      new_value &= 0xF0FF;             // Clear the third pair of 4 bits
      new_value |= (value_byte << 8);  // Set the third pair of 4 bits with the new value

      ESP_LOGI("zone1_h_emission", "Set option to %s, Original value: %d New value: %d", x.c_str(), id(unmasked_value_register_272), new_value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  # Register: 272 (bits 12-15), default: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 End Cooling Mode Emission Type"
    id: "${devicename}_zone_2_end_cooling_mode_emission_type"
    address: 0x110
    value_type: U_WORD
    optimistic: true
    icon: mdi:heat-wave
    optionsmap:
      "Fan Coil Unit": 0
      "Radiator": 1
      "Underfloor Heating": 2
    lambda: |-
      // Updating the global var unmasked_value_register_272 is already done
      // in the first part of this register
      //ESP_LOGI("","unmasked_value_register_272: 0x%x", id(unmasked_value_register_272);
      id(unmasked_value_register_272) = x;

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      //ESP_LOGI("","zone2_c_emission is %d, zone1_c_emission is %d, zone2_h_emission is %d, zone1_h_emission is %d", zone2_c_emission, zone1_c_emission, zone2_h_emission, zone1_h_emission);

      // Map/dictionary with the possible values
      std::map<int, std::string> emission_options;
      emission_options[0] = "Fan Coil Unit";
      emission_options[1] = "Radiator";
      emission_options[2] = "Underfloor Heating";

      return emission_options[zone2_c_emission];
    write_lambda: |-
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte;
      if (x ==  "Fan Coil Unit") value_byte = 0;                            // New byte value with the heating emission type for zone 1
      else if (x ==  "Radiator") value_byte = 1;
      else if (x ==  "Underfloor Heating") value_byte = 2;
      else value_byte = 0;
      new_value &= 0x0FFF;              // Clear the fourth pair of 4 bits
      new_value |= (value_byte << 12);  // Set the fourth pair of 4 bits with the new value

      ESP_LOGI("write zone2_c_emission", "Set option to %s, Original value: %d New value: 0x%x", x.c_str(), id(unmasked_value_register_272), new_value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);

      return {};
################################################################################################################################
sensor:
  ##############REMOTE SENSORS#############################################
  - platform: homeassistant
    name: "External Temp Sensor of avg Rooms temp"
    id: "${devicename}_external_temp_sensor_avg_rooms_temp"
    entity_id: sensor.wanas_m7_temp_pomieszcz_2
    internal: true
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    on_value: 
      then:
        lambda: |-
          // Update the global var to save last read
          id(external_temp_sensor_avg_rooms_temp_saved) = x;
  ##############LOCAL SENSORS#####################################################################################
  - platform: uptime
    id: ${devicename}_uptime_sec
    name: Uptime
    unit_of_measurement: s
    icon: mdi:clock-start
    entity_category: "diagnostic"
    on_value: 
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = x;
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              std::string result;
              if ( days > 3650 ) {
                result = "Starting up";
              } else if ( days ) {
                result = (std::to_string(days) +"d " + std::to_string(hours) +"h " + std::to_string(minutes) +"m "+ std::to_string(seconds) +"s");
              } else if ( hours ) {
                result = (std::to_string(hours) +"h " + std::to_string(minutes) +"m "+ std::to_string(seconds) + "s");
              } else if ( minutes ) {
                result = (std::to_string(minutes) +"m "+ std::to_string(seconds) +"s");
              } else {
                result = (std::to_string(seconds) +"s");
              }
              return result;
  - platform: wifi_signal
    name: WiFi Signal
    id: ${devicename}_wifi_signal
    update_interval: 60s
    entity_category: "diagnostic"
    icon: mdi:wifi
  ###########APPEND SENSORS #################
  - platform: template
    name: "SM Last time PUMP_I Run"
    id: ${devicename}_water_pump_i_runtime
    entity_category: "diagnostic"
    unit_of_measurement: s
    icon: mdi:clock
    update_interval: 15s
    lambda: "if (id(timestamp_water_pump_timestamp_last_run)==0) return 0; else return id(esptime).now().timestamp - id(timestamp_water_pump_timestamp_last_run);"
  - platform: template
    name: "SM Recovery Heating DHW time in"
    id: ${devicename}_recovery_heating_dhw_time_in
    entity_category: "diagnostic"
    unit_of_measurement: s
    icon: mdi:clock
    update_interval: 15s
    internal: true
    lambda: "if (id(manually_disabled_dhw_heating_timestamp)==0 or !id(Restore_enable_DHW)) {return 0;} else {return (id(${devicename}_restore_time_heat_dhw_after_turn_off).state * 60) - id(esptime).now().timestamp - id(manually_disabled_dhw_heating_timestamp);}"
  - platform: template
    name: "SM Recovery Heating/Cooling Zone1 time in"
    id: ${devicename}_recovery_heating_cooling_zone1_time_in
    entity_category: "diagnostic"
    unit_of_measurement: s
    icon: mdi:clock
    update_interval: 15s
    internal: true
    lambda: "if (id(manually_disabled_zone1_heating_timestamp)==0 or !id(Restore_enable_Zone1)) return 0; else return (id(${devicename}_restore_time_heat_zone1_after_turn_off).state * 60) - id(esptime).now().timestamp - id(manually_disabled_zone1_heating_timestamp);"
  - platform: template
    name: "SM Recovery Heating/Cooling Zone2 time in"
    id: ${devicename}_recovery_heating_cooling_zone2_time_in
    entity_category: "diagnostic"
    unit_of_measurement: s
    icon: mdi:clock
    update_interval: 15s
    internal: true
    lambda: "if (id(manually_disabled_zone2_heating_timestamp)==0 or !id(Restore_enable_Zone2)) return 0; else return (id(${devicename}_restore_time_heat_zone2_after_turn_off).state * 60) - id(esptime).now().timestamp - id(manually_disabled_zone2_heating_timestamp);"
  - platform: template
    name: "SM Averange Hourly outside temp"
    id: "${devicename}_outdoor_ambient_temperature_hourly"
    icon: mdi:temperature-celsius
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - sliding_window_moving_average:
          window_size: 120
          send_every: 1
          send_first_at: 1
    on_value: 
      then:
        - lambda: "id(tempereture_avg_last_hour) = x;"
    # web_server_sorting_weight: 190
  - platform: template
    name: "SM Averange Daily outside temp"
    id: "${devicename}_outdoor_ambient_temperature_daily"
    icon: mdi:temperature-celsius
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    # update_interval: 30min
    lambda: >
      return id(${devicename}_outdoor_ambient_temperature_hourly).state;
    filters:
      - sliding_window_moving_average:
          window_size: 48
          send_every: 1
          send_first_at: 1
    on_value: 
      then:
        - lambda: "id(tempereture_avg_last_24h) = x;"
  - platform: template
    name: "SM Calculated Curve"
    id: ${devicename}_calculated_curve
    unit_of_measurement: °C
    icon: mdi:temperature-celsius
  - platform: template
    name: "SM Calculated Curve2"
    id: ${devicename}_calculated_curve2
    unit_of_measurement: °C
    icon: mdi:temperature-celsius
  - platform: template
    name: "SM Calculated Curve3"
    id: ${devicename}_calculated_curve3
    unit_of_measurement: °C
    icon: mdi:temperature-celsius
  ############# YORK #############
  - platform: template
    id: "${devicename}_cop"
    name: "COP"
    icon: mdi:copyleft
    accuracy_decimals: 2
    lambda: |-
      if (id(${devicename}_electricity_consumption).state != 0) {
        return id(${devicename}_power_output).state / id(${devicename}_electricity_consumption).state;
      } else return {};
  # Register: 0 -> Config is present as select, but now we need get value from heatpump and save it as global var
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 0 switches"
    id: "${devicename}_register_0_switches"
    internal: true
    register_type: holding
    address: 0x0
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_0
      id(unmasked_value_register_0) = x;
      return x;
  # Register: 1 -> Is present in this config as a 'select'
  # Register: 2 -> Is present in this config as a 'number'
  # Register: 3
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Air Temperature Ts"
    id: "${devicename}_air_temperature_ts"
    register_type: holding
    address: 0x3
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    filters:
      - multiply: 0.5
  # Register: 4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DHW Tank Temperature T5s"
    id: "${devicename}_dhw_tank_temperature_t5s"
    register_type: holding
    address: 0x4
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 5 -> Config is present as select, but now we need get value from heatpump and save it as global var
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 5 switches"
    id: "${devicename}_register_5_switches"
    internal: true
    register_type: holding
    address: 0x5
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_5
      id(unmasked_value_register_5) = x;
      return x;
  # Register: 6 -> Is present in this config as a 'number'
  # Register: 7 -> Is present in this config as a 'switch' for configuration
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Forced Water Tank Heater On/Off helper"
    id: "${devicename}_forced_water_tank_heater_on_off_helper"
    icon: mdi:fire-alert
    address: 0x7
    register_type: holding
    internal: true
    lambda: |-
      ESP_LOGI("FUNC7","value of x: %f", x);
      if (x == 1) {
        id(${devicename}_forced_water_tank_heater_on_off).publish_state(true);
      } 
      else {
        id(${devicename}_forced_water_tank_heater_on_off).publish_state(false);
      }
      return {};

  # Register: 8 -> Is present in this config as a 'switch' for configuration
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Forced Tank Backup Heater helper"
    id: "${devicename}_forced_tbh_helper"
    icon: mdi:fire-alert
    address: 0x8
    register_type: holding
    internal: true
    lambda: |-
      ESP_LOGI("FUNC8","value of x: %f", x);
      if (x == 1) {
        id(${devicename}_forced_tbh).publish_state(true);
      } 
      else {
        id(${devicename}_forced_tbh).publish_state(false);
      }
      return {};    

  # Register: 9 -> Is present in this config as a 'switch' for configuration
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Forced Hydraulic Module Rear Electric Heater 1"
    id: "${devicename}_forced_hydraulic_module_rear_electric_heater_1_helper"
    icon: mdi:fire-alert
    address: 0x9
    register_type: holding
    internal: true
    lambda: |-
      ESP_LOGI("FUNC9","value of x: %f", x);
      if (x == 1) {
        id(${devicename}_forced_hydraulic_module_rear_electric_heater_1).publish_state(true);
      } 
      else {
        id(${devicename}_forced_hydraulic_module_rear_electric_heater_1).publish_state(false);
      }
      return {};    

  # Register: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t_SG_MAX or Reserved"
    id: "${devicename}_t_sg_max"
    register_type: holding
    address: 0xa
    value_type: U_WORD
    unit_of_measurement: hr
    icon: mdi:clock

  # Register: 100
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Operating Frequency"
    id: "${devicename}_compressor_operating_frequency"
    register_type: holding
    address: 0x64
    value_type: U_WORD
    unit_of_measurement: Hz
    icon: mdi:sine-wave
  # Register: 101 -->moved text_sensor
  # Register: 102
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fan Speed"
    id: "${devicename}_fan_speed"
    register_type: holding
    address: 0x66
    unit_of_measurement: "r/min"
    value_type: U_WORD
    icon: mdi:fan
  # Register: 103
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "PMV Openness"
    id: "${devicename}_pmv_openness"
    register_type: holding
    address: 0x67
    value_type: U_WORD
    icon: mdi:valve
    unit_of_measurement: "%"
    filters: 
    - calibrate_linear:  #York have movement 0-480
      - 0 -> 0.0
      - 480 -> 100.0
  # Register: 104
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Inlet Temperature"
    id: "${devicename}_water_inlet_temperature"
    register_type: holding
    address: 0x68
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 105
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Outlet Temperature"
    id: "${devicename}_water_outlet_temperature"
    register_type: holding
    address: 0x69
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 106
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Condensor Temperature T3"
    id: "${devicename}_condensor_temperature_t3"
    register_type: holding
    address: 0x6a
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 107
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Ambient Temperature"
    id: "${devicename}_outdoor_ambient_temperature"
    register_type: holding
    address: 0x6B
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    value_type: S_WORD
    on_value: 
      then: 
        lambda: |-
          //Send actual outside temp to calculate avg hourly
          id(${devicename}_outdoor_ambient_temperature_hourly).publish_state(x);
  # Register: 108
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Discharge Temperature"
    id: "${devicename}_discharge_temperature"
    register_type: holding
    address: 0x6c
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 109
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Return Air Temperature"
    id: "${devicename}_return_air_temperature"
    register_type: holding
    address: 0x6d
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 110
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total Water Outlet Temperature T1"
    id: "${devicename}_total_water_outlet_temperature_t1"
    register_type: holding
    address: 0x6e
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 111
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "System Total Water Outlet Temperature T1B"
    id: "${devicename}_system_total_water_outlet_temperature_t1b"
    register_type: holding
    address: 0x6f
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 112
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Refrigerant Liquid Side Temperature T2"
    id: "${devicename}_refrigerant_liquid_side_temperature_t2"
    register_type: holding
    address: 0x70
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 113
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Refrigerant Gas Side Temperature T2B"
    id: "${devicename}_refrigerant_gas_side_temperature_t2b"
    register_type: holding
    address: 0x71
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 114
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Room Temperature Ta"
    id: "${devicename}_room_temperature_ta"
    register_type: holding
    address: 0x72
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 115
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Tank Temperature T5"
    id: "${devicename}_water_tank_temperature_t5"
    register_type: holding
    address: 0x73
    unit_of_measurement: "°C"
    value_type: S_WORD
    icon: mdi:thermometer-water
    on_value_range:
      - below: !lambda "return float(id(${devicename}_gl_dhw_minimal_temp).state);"
        then:
          #enable DHW heating if DHW temp is too low
          - switch.turn_on: ${devicename}_power_dhw_t5s
          - logger.log: "TURN ON WATER HEATING -TEMP BELOW id(${devicename}_gl_dhw_minimal_temp).state=~32DEG"
  # Register: 116
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit High Pressure"
    id: "${devicename}_outdoor_unit_high_pressure"
    register_type: holding
    address: 0x74
    value_type: U_WORD
    unit_of_measurement: kPA
    icon: mdi:car-brake-worn-linings
  # Register: 117
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: " Outdoor Unit Low Pressure"
    id: "${devicename}_outdoor_unit_low_pressure"
    register_type: holding
    address: 0x75
    value_type: U_WORD
    unit_of_measurement: kPA
    icon: mdi:car-brake-low-pressure
  # Register: 118
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Current"
    id: "${devicename}_outdoor_unit_current"
    register_type: holding
    address: 0x76
    value_type: U_WORD
    unit_of_measurement: A
    icon: mdi:alpha-a
  # Register: 119
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Voltage"
    id: "${devicename}_outdoor_unit_voltage"
    register_type: holding
    address: 0x77
    value_type: U_WORD
    unit_of_measurement: V
    icon: mdi:alpha-v
  # Register: 120
  # Midea: Tbt1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Hydraulic Module Current 1 or tbt1"
    id: "${devicename}_hydraulic_module_current_1_tbt1"
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    register_type: holding
    address: 0x78
    value_type: U_WORD
  # Register: 121
  # Midea: Tbt2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Hydraulic Module Current 2 or tbt2"
    id: "${devicename}_hydraulic_module_current_2_tbt2"
    disabled_by_default: true
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    register_type: holding
    address: 0x79
    value_type: U_WORD
    
  # Register: 122
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Operation Time"
    id: "${devicename}_compressor_operation_time"
    register_type: holding
    address: 0x7a
    value_type: U_WORD
    unit_of_measurement: hr
    icon: mdi:av-timer
  # Register: 123
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Unit Capacity"
    id: "${devicename}_unit_capacity"
    register_type: holding
    address: 0x7b
    value_type: U_WORD
    icon: mdi:lightning-bolt-circle
    unit_of_measurement: "kWh"
  # Register: 124
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Current Fault"
    id: "${devicename}_current_fault"
    register_type: holding
    entity_category: diagnostic
    address: 0x7c
    value_type: U_WORD
    icon: mdi:alert-circle
  # Register: 125
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 1"
    id: "${devicename}_fault_1"
    register_type: holding
    entity_category: diagnostic
    address: 0x7d
    value_type: U_WORD
    icon: mdi:alert-circle
  # Register: 126
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 2"
    id: "${devicename}_fault_2"
    register_type: holding
    entity_category: diagnostic
    address: 0x7e
    value_type: U_WORD
    icon: mdi:alert-circle
  # Register: 127
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 3"
    id: "${devicename}_fault_3"
    register_type: holding
    entity_category: diagnostic
    address: 0x7f
    value_type: U_WORD
    icon: mdi:alert-circle
  # Register: 130
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Software Version"
    id: "${devicename}_software_version"
    register_type: holding
    address: 0x82
    value_type: U_WORD
    icon: mdi:information
  # Register: 131
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Wired Controller Version Number"
    id: "${devicename}_wired_controller_version_number"
    register_type: holding
    address: 0x83
    value_type: U_WORD
    icon: mdi:information
  # Register: 132
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Target Frequency"
    id: "${devicename}_compressor_target_frequency"
    register_type: holding
    address: 0x84
    value_type: U_WORD
    unit_of_measurement: Hz
    icon: mdi:sine-wave
  # Register: 133
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DC Bus Current"
    id: "${devicename}_dc_bus_current"
    register_type: holding
    address: 0x85
    value_type: U_WORD
    unit_of_measurement: A
    icon: mdi:alpha-a
  # Register: 134
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DC Bus Voltage"
    id: "${devicename}_dc_bus_voltage"
    register_type: holding
    address: 0x86
    value_type: U_WORD
    unit_of_measurement: V
    icon: mdi:alpha-v
    filters:
      - multiply: 10
  # Register: 135
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "TF module temperature"
    id: "${devicename}_tf_module_temperature"
    register_type: holding
    address: 0x87
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    value_type: S_WORD
  # Register: 136
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Climate Curve T1S Calculated Value 1"
    id: "${devicename}_climate_curve_t1s_calculated_value_1"
    register_type: holding
    address: 0x88
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 137
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Climate Curve T1S Calculated Value 2"
    id: "${devicename}_climate_curve_t1s_calculated_value_2"
    register_type: holding
    address: 0x89
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 138
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Flow"
    id: "${devicename}_water_flow"
    icon: mdi:waves-arrow-right
    register_type: holding
    address: 0x8a
    value_type: U_WORD
    unit_of_measurement: m3/H
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  # Register: 139
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Limit Scheme Of Outdoor Unit Current"
    id: "${devicename}_limit_scheme_of_outdoor_unit_current"
    register_type: holding
    address: 0x8b
    value_type: U_WORD
    icon: mdi:eye
    unit_of_measurement: "kW"
  # Register: 140
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ability Of Hydraulic Module"
    id: "${devicename}_ability_of_hydraulic_module"
    register_type: holding
    address: 0x8c
    value_type: U_WORD
    unit_of_measurement: kW
    icon: mdi:lightning-bolt
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  # Register: 141
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Tsolar"
    id: "${devicename}_tsolar"
    register_type: holding
    address: 0x8d
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:thermometer
  # Register: 143 and 144
  # U_DWORD combines this register with the next one
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Electricity Consumption"
    id: "${devicename}_electricity_consumption"
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x8f
    value_type: U_DWORD
    icon: mdi:lightning-bolt-outline
  # Register: 145 and 146
  # U_DWORD combines this register with the next one
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Output"
    id: "${devicename}_power_output"
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x91
    value_type: U_DWORD
    icon: mdi:lightning-bolt-outline

  # The following register address 200-208 can only use 03H (Read register) function code.
  # Register address 209 and after can use 03H, 06H (write single register), 10H (write multiple register).
  # Register: 200 ->moved to text_sensor
  # Register: 201 (Low), default: 25, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Cooling Zone 1"
    id: "${devicename}_temperature_upper_limit_of_t1s_cooling_zone_1"
    register_type: holding
    address: 0xc9
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0x00FF
  # Register: 201 (High), default: 25, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Cooling Zone 2"
    id: "${devicename}_temperature_upper_limit_of_t1s_cooling_zone_2"
    disabled_by_default: true
    
    register_type: holding
    address: 0xc9
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0xFF00
  # Register: 202 (Low), default: 5, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Cooling Zone 1"
    id: "${devicename}_temperature_lower_limit_of_t1s_cooling_zone_1"
    register_type: holding
    address: 0xca
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0x00FF
  # Register: 202 (High), default: 5, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Cooling Zone 2"
    id: "${devicename}_temperature_lower_limit_of_t1s_cooling_zone_2"
    register_type: holding
    address: 0xca
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0xFF00
  # Register: 203 (Low), default: 55, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Heating Zone 1"
    id: "${devicename}_temperature_upper_limit_of_t1s_heating_zone_1"
    register_type: holding
    address: 0xcb
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0x00FF
  # Register: 203 (High), default: 55, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Heating Zone 2"
    id: "${devicename}_temperature_upper_limit_of_t1s_heating_zone_2"
    register_type: holding
    address: 0xcb
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0xFF00
  # Register: 204 (Low), default: 25, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Heating Zone 1"
    id: "${devicename}_temperature_lower_limit_of_t1s_heating_zone_1"
    register_type: holding
    address: 0xcc
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0x00FF
  # Register: 204 (High), default: 25, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Heating Zone 2"
    id: "${devicename}_temperature_lower_limit_of_t1s_heating_zone_2"
    register_type: holding
    address: 0xcc
    value_type: S_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    bitmask: 0xFF00
  # Register: 205
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of TS Setting"
    id: "${devicename}_temperature_upper_limit_of_ts_setting"
    register_type: holding
    address: 0xcd
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    filters:
      - multiply: 0.5
  # Register: 206
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of TS Setting"
    id: "${devicename}_temperature_lower_limit_of_ts_setting"
    register_type: holding
    address: 0xce
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    filters:
      - multiply: 0.5
  # Register: 207
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of water Heating"
    id: "${devicename}_temperature_upper_limit_of_water_heating"
    register_type: holding
    address: 0xcf
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 208
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of Water Heating"
    id: "${devicename}_temperature_lower_limit_of_water_heating"
    register_type: holding
    address: 0xd0
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
  # Register: 209 -> Is present in this config as a 'number'
  # Register: 210 -> Config is present as select, but now we need get value from heatpump and save it as global var
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Parameter Settings 1"
    id: "${devicename}_parameter_settings_1"
    internal: true
    register_type: holding
    address: 210
    value_type: U_WORD
    icon: mdi:state-machine
    lambda: |-
      // Update the global var unmasked_value_register_210
      id(unmasked_value_register_210) = x;
      return x;
  # Register: 211 -> Config is present as select, but now we need get value from heatpump and save it as global var
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Parameter Settings 2"
    id: "${devicename}_parameter_settings_2"
    internal: true
    register_type: holding
    address: 211
    value_type: U_WORD
    icon: mdi:state-machine
    lambda: |-
      // Update the global var unmasked_value_register_211
      id(unmasked_value_register_211) = x;
      return x;
  # Register: 212 -> Is present in this config as a 'number'
  # Register: 213 -> Is present in this config as a 'number'
  # Register: 214 -> Is present in this config as a 'number'
  # Register: 215 -> Is present in this config as a 'number'
  # Register: 216 -> Is present in this config as a 'number'
  # Register: 217 -> Is present in this config as a 'number'
  # Register: 218 -> Is present in this config as a 'number'
  # Register: 219 -> Is present in this config as a 'number'
  # Register: 220 -> Is present in this config as a 'number'
  # Register: 221 -> Is present in this config as a 'number'
  # Register: 222 -> Is present in this config as a 'number'
  # Register: 223 -> Is present in this config as a 'number'
  # Register: 224 -> Is present in this config as a 'number'
  # Register: 225 -> Is present in this config as a 'number'
  # Register: 226 -> Is present in this config as a 'number'
  # Register: 227 -> Is present in this config as a 'number'
  # Register: 228 -> Is present in this config as a 'number'
  # Register: 229 -> Is present in this config as a 'number'
  # Register: 230 -> Is present in this config as a 'number'
  # Register: 231 -> Is present in this config as a 'number'
  # Register: 232 -> Is present in this config as a 'number'
  # Register: 233 -> Is present in this config as a 'number'
  # Register: 234 -> Is present in this config as a 'number'
  # Register: 235 -> Is present in this config as a 'number'
  # Register: 237 -> Is present in this config as a 'number'
  # Register: 238 -> Is present in this config as a 'number'
  # Register: 240 -> Is present in this config as a 'number'
  # Register: 241 -> Is present in this config as a 'number'
  # Register: 242 -> Is present in this config as a 'number'
  # Register: 243 -> Is present in this config as a 'number'
  # Register: 244 -> Is present in this config as a 'number'
  # Register: 245 -> Is present in this config as a 'number'
  # Register: 246 -> Is present in this config as a 'number'
  # Register: 247 -> Is present in this config as a 'number'
  # Register: 248 -> Is present in this config as a 'number'
  # Register: 249 -> Is present in this config as a 'number'
  # Register: 250 -> Is present in this config as a 'number'
  # Register: 251 -> Is present in this config as a 'number'
  # Register: 252 -> Is present in this config as a 'number'
  # Register: 253 -reserved is not for use
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Comfort Parameter Reserved 3"
  #   id: "${devicename}_comfort_parameter_3"
  #   register_type: holding
  #   address: 0xfd
  #   value_type: U_WORD
  # Register: 254 -reserved is not for use
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Comfort Parameter Reserved 4"
  #   id: "${devicename}_comfort_parameter_4"
  #   register_type: holding
  #   address: 0xfe
  #   value_type: U_WORD
  # Register: 255 -> Is present in this config as a 'number'
  # Register: 256 -> Is present in this config as a 'number'
  # Register: 257 -> Is present in this config as a 'number'
  # Register: 258 -> Is present in this config as a 'number'
  # Register: 259 -> Is present in this config as a 'number'
  # Register: 260 -> Is present in this config as a 'number'
  # Register: 261 -> Is present in this config as a 'number'
  # Register: 262 -> Is present in this config as a 'number'
  # Register: 263 -> Is present in this config as a 'number' 0
  # Register: 264 -> Is present in this config as a 'number'
  # Register: 265 -> Is present in this config as a 'number'
  # Register: 266 -> Is present in this config as a 'number'
  # Register: 267 -> Is present in this config as a 'number'
  # Register: 268 -> Is present in this config as a 'number'
  # Register: 269 -> Is present in this config as a 'select'
  # Register: 270 -> Is present in this config as a 'number'
  # Register: 271 -> Is present in this config as a 'number'
  # Register: 272 -> Is present in this config as a 'select'

  # Template sensor to get the T1S value for DHW (T1S=T5+dT1S5).
  - platform: template
    name: "T1S DHW"
    id: "${devicename}_t1s_dhw"
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    lambda: |-
      int dt1s5 = id(${devicename}_dt1s5).state;
      int t5 = id(${devicename}_water_tank_temperature_t5).state;
      int t1s_dhw = t5 + dt1s5;
      return t1s_dhw;
################################################################################################################################
binary_sensor:
  ###################################MARM MY SENSOR EXTERNAL HEAT SOURCE ###########################
  - platform: homeassistant
    name: "MARM20 Pump Working Disable HeatPump from Heating and DHW"
    entity_id: input_boolean.scene_daytime
    id: "marm20_m28_outs_20_pump_is_running"
    internal: true
    icon: mdi:eye
    on_state:
      then:
        #if state from HA other source pump is running means heating so diable heatpump
        - switch.turn_off: "${devicename}_power_dhw_t5s"
        - switch.turn_off: "${devicename}_water_flow_temperature_control_zone_1"
        - switch.turn_off: "${devicename}_water_flow_temperature_control_zone_2"
        - logger.log: "MARM20 HA Sensor: Disable DHW and Floor Heating on HeatPump...."
        - lambda: |-
            ESP_LOGI("bin_Sensor","MARM20 HA Sensor: Disable DHW and Floor Heating on HeatPump....");
            id(manually_disabled_dhw_heating_timestamp) = id(esptime).now().timestamp;
            id(manually_disabled_zone1_heating_timestamp) = id(esptime).now().timestamp;
            id(manually_disabled_zone2_heating_timestamp) = id(esptime).now().timestamp;


  ################################### YORK ###########################
  # Register: 0
  # Bit: 0 -> Is present in this config as a 'switch'
  # Bit: 1 -> Is present in this config as a 'switch'
  # Bit: 2 -> Is present in this config as a 'switch'
  # Bit: 3 -> Is present in this config as a 'switch'
  # Bit: 4  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 4"
  #   id: "${devicename}_power_reserved_bit_4"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x10
  # Bit: 5  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 5"
  #   id: "${devicename}_power_reserved_bit_5"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x20
  # Bit: 6  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 6"
  #   id: "${devicename}_power_reserved_bit_6"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x40
  # Bit: 7  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 7"
  #   id: "${devicename}_power_reserved_bit_7"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x80
  # Bit: 8  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 8"
  #   id: "${devicename}_power_reserved_bit_8"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x100
  # Bit: 9  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 9"
  #   id: "${devicename}_power_reserved_bit_9"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x200
  # Bit: 10  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 10"
  #   id: "${devicename}_power_reserved_bit_10"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x400
  # Bit: 11  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 11"
  #   id: "${devicename}_power_reserved_bit_11"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x800
  # Bit: 12  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 12"
  #   id: "${devicename}_power_reserved_bit_12"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x1000
  # Bit: 13  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 13"
  #   id: "${devicename}_power_reserved_bit_13"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x2000
  # Bit: 14  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 14"
  #   id: "${devicename}_power_reserved_bit_14"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x4000
  # Bit: 15  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Power Reserved BIT 15"
  #   id: "${devicename}_power_reserved_bit_15"
  #   register_type: holding
  #   address: 0x0
  #   bitmask: 0x8000

  # Register: 5 -> moved to switch without these marked as reserved_bit
  # Bit: 0  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Function Setting Reserved BIT 0"
  #   id: "${devicename}_function_setting_reserved_bit_0"
  #   register_type: holding
  #   address: 0x5
  #   bitmask: 0x1
  # Bit: 1  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Function Setting Reserved BIT 1"
  #   id: "${devicename}_function_setting_reserved_bit_1"
  #   register_type: holding
  #   address: 0x5
  #   bitmask: 0x2
  # Bit: 2  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Function Setting Reserved BIT 2"
  #   id: "${devicename}_function_setting_reserved_bit_2"
  #   register_type: holding
  #   address: 0x5
  #   bitmask: 0x4
  # Bit: 3
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Function Setting Reserved BIT 3"
  #   id: "${devicename}_function_setting_reserved_bit_3"
  #   register_type: holding
  #   address: 0x5
  #   bitmask: 0x8
  # Bit: 4  #for future use maybe
  # Bit: 5 -> Is present in this config as a 'switch'
  # Bit: 6 -> Is present in this config as a 'switch'
  # Bit: 7 -> Is present in this config as a 'switch'
  # Bit: 8 -> Is present in this config as a 'switch'
  # Bit: 9 -> Is present in this config as a 'switch'
  # Bit: 10 -> Is present in this config as a 'switch'
  # Bit: 11 -> Is present in this config as a 'switch'
  # Bit: 12 -> Is present in this config as a 'switch'
  # Bit: 13 -> Is present in this config as a 'switch'
  # Bit: 14  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Function Setting Reserved BIT 14"
  #   id: "${devicename}_function_setting_reserved_bit_14"
  #   register_type: holding
  #   address: 0x5
  #   bitmask: 0x4000
  # Bit: 15  #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Function Setting Reserved BIT 15"
  #   id: "${devicename}_function_setting_reserved_bit_15"
  #   register_type: holding
  #   address: 0x5
  #   bitmask: 0x8000

  # Register: 128
  # Bit: 0   #for future use maybe
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Status BIT 1 Reserved BIT 0"
  #   id: "${devicename}_status_bit_1_reserved_bit_0"
  #   register_type: holding
  #   address: 0x80
  #   bitmask: 0x1
  # Bit: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Defrosting"
    id: "${devicename}_status_bit_1_defrosting"
    register_type: holding
    address: 0x80
    bitmask: 0x2
    icon: mdi:eye
  # Bit: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Anti Freezing"
    id: "${devicename}_status_bit_1_anti_freezing"
    register_type: holding
    address: 0x80
    bitmask: 0x4
    icon: mdi:eye
  # Bit: 3
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Oil Return"
    id: "${devicename}_status_bit_1_oil_return"
    register_type: holding
    address: 0x80
    bitmask: 0x8
    icon: mdi:eye
  # Bit: 4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Remote On/Off"
    id: "${devicename}_status_bit_1_remote_on_off"
    register_type: holding
    address: 0x80
    bitmask: 0x10
    icon: mdi:eye
  # Bit: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Outdoor Unit Test Mode Mark"
    id: "${devicename}_status_bit_1_outdoor_unit_test_mode_mark"
    register_type: holding
    address: 0x80
    bitmask: 0x20
    icon: mdi:eye
  # Bit: 6
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Heating Mode Set By Room Thermostat"
    id: "${devicename}_status_bit_1_heating_mode_set_by_room_thermostat"
    register_type: holding
    address: 0x80
    bitmask: 0x40
    icon: mdi:eye
  # Bit: 7
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Cooling Mode Set By Room Thermostat"
    id: "${devicename}_status_bit_1_cooling_mode_set_by_room_thermostat"
    register_type: holding
    address: 0x80
    bitmask: 0x80
    icon: mdi:eye
  # Bit: 8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Solar Energy Signal Input"
    id: "${devicename}_status_bit_1_solar_energy_signal_input"
    register_type: holding
    address: 0x80
    bitmask: 0x100
    icon: mdi:eye
  # Bit: 9
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Anti Freezing Operation For Water Tank"
    id: "${devicename}_status_bit_1_anti_freezing_operation_for_water_tank"
    register_type: holding
    address: 0x80
    bitmask: 0x200
    icon: mdi:eye
  # Bit: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 SG"
    id: "${devicename}_status_bit_1_sg"
    register_type: holding
    address: 0x80
    bitmask: 0x400
    icon: mdi:eye
  # Bit: 11
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 EUV"
    id: "${devicename}_status_bit_1_euv"
    register_type: holding
    address: 0x80
    bitmask: 0x800
    icon: mdi:eye
  # Bit: 12
  - platform: modbus_controller
    name: "Status BIT 1 Reserved BIT 12"
    modbus_controller_id: "${devicename}"
    id: "${devicename}_status_bit_1_reserved_bit_12"
    register_type: holding
    address: 0x80
    bitmask: 0x1000
    icon: mdi:eye
  # Bit: 13
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Request Serial Number Code"
    id: "${devicename}_status_bit_1_request_serial_number_code"
    register_type: holding
    address: 0x80
    bitmask: 0x2000
    icon: mdi:eye
  # Bit: 14
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Request Software Version"
    id: "${devicename}_status_bit_1_request_software_version"
    register_type: holding
    address: 0x80
    bitmask: 0x4000
    icon: mdi:eye
  # Bit: 15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Request Operation Parameter"
    id: "${devicename}_status_bit_1_request_operation_parameter"
    register_type: holding
    address: 0x80
    bitmask: 0x8000
    icon: mdi:eye

  # Register: 129
  # Bit: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Electric Heater IBH 1"
    id: "${devicename}_load_output_electric_heater_ibh1"
    register_type: holding
    address: 0x81
    bitmask: 0x1
    icon: mdi:eye
  # Bit: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Electric Heater IBH 2"
    id: "${devicename}_load_output_reserved"
    register_type: holding
    address: 0x81
    bitmask: 0x2
    icon: mdi:eye
  # Bit: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Electric Heater TBH"
    id: "${devicename}_load_output_electric_heater_tbh"
    register_type: holding
    address: 0x81
    bitmask: 0x4
    icon: mdi:eye
  # Bit: 3
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Water Pump PUMP_I"
    id: "${devicename}_load_output_water_pump_pump_i"
    register_type: holding
    address: 0x81
    bitmask: 0x8
    icon: mdi:pump
    on_press: 
      then:
        - lambda: |-
            id(${devicename}_relay1_external_pump).turn_off();  //#XXXXXXX
            id(${devicename}_relay2_external_pump).turn_off();  //#XXXXXXX
            ESP_LOGI("PUMP_I Status","turn off relay 1 and 2");  //#XXXXXXX 
            id(timestamp_water_pump_timestamp_last_run) = 0;
    on_release: 
      # calculate the total time = (old total time) + (current epoch time) - (stored on_press epoch time)
      # and publish in the template sensor
      then:
        - lambda: |-
            id(timestamp_water_pump_timestamp_last_run) = id(esptime).now().timestamp;
            ESP_LOGI("PUMP_I Status","Set global timestamp last pump run and turn off");    
  # Bit: 4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output SV1 -DHW"
    id: "${devicename}_load_output_sv1"
   
    register_type: holding
    address: 0x81
    bitmask: 0x10
    icon: mdi:eye
  # Bit: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Reserved BIT 5"
    id: "${devicename}_load_output_reserved_bit_5"
    register_type: holding
    address: 0x81
    bitmask: 0x20
    icon: mdi:eye
  # Bit: 6
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output External Water Pump P_o"
    id: "${devicename}_load_output_external_water_pump_p_o"
    register_type: holding
    address: 0x81
    bitmask: 0x40
    icon: mdi:pump
  # Bit: 7
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Water Return Water P_d"
    id: "${devicename}_load_output_water_return_water_p_d"
    register_type: holding
    address: 0x81
    bitmask: 0x80
    icon: mdi:pump
  # Bit: 8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Mixed Water Pump P_c"
    id: "${devicename}_load_output_mixed_water_pump_p_c"
    register_type: holding
    address: 0x81
    bitmask: 0x100
    icon: mdi:pump
  # Bit: 9
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output SV 2"
    id: "${devicename}_load_output_sv2"
    register_type: holding
    address: 0x81
    bitmask: 0x200
    icon: mdi:eye
  # Bit: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output HEAT 4"
    id: "${devicename}_load_output_heat4"
    register_type: holding
    address: 0x81
    bitmask: 0x400
    icon: mdi:eye
  # Bit: 11
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Solar Water Pump"
    id: "${devicename}_load_output_solar_water_pump"
    register_type: holding
    address: 0x81
    bitmask: 0x800
    icon: mdi:eye
  # Bit: 12
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output ALARM"
    id: "${devicename}_load_output_alarm"
    register_type: holding
    entity_category: diagnostic
    address: 0x81
    bitmask: 0x1000
    icon: mdi:eye
  # Bit: 13
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output RUN"
    id: "${devicename}_load_output_run"
    register_type: holding
    address: 0x81
    bitmask: 0x2000
    icon: mdi:eye
  # Bit: 14
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Auxiliary Heat Source"
    id: "${devicename}_load_output_auxiliary_heat_source"
    register_type: holding
    address: 0x81
    bitmask: 0x4000
    icon: mdi:eye
  # Bit: 15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output DEFROST"
    id: "${devicename}_load_output_defrost"
    register_type: holding
    address: 0x81
    bitmask: 0x8000
    icon: mdi:eye
  # Bit: 0

  # Register: 142
  # Bit: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit Online Status: Reserved BIT 0"
    id: "${devicename}_slave_unit_online_status_reserved_bit_0"
    register_type: holding
    address: 0x8e
    bitmask: 0x1
    icon: mdi:eye
  # Bit: 1  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 1 Online Status"
  #   id: "${devicename}_slave_unit_1_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x2
  #   icon: mdi:eye
  # Bit: 2  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 2 Online Status"
  #   id: "${devicename}_slave_unit_2_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x4
  #   icon: mdi:eye
  # Bit: 3  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 3 Online Status"
  #   id: "${devicename}_slave_unit_3_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x8
  #   icon: mdi:eye
  # Bit: 4  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 4 Online Status"
  #   id: "${devicename}_slave_unit_4_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x10
  #   icon: mdi:eye
  # Bit: 5  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 5 Online Status"
  #   id: "${devicename}_slave_unit_5_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x20
  #   icon: mdi:eye
  # Bit: 6  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 6 Online Status"
  #   id: "${devicename}_slave_unit_6_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x40
  #   icon: mdi:eye
  # Bit: 7  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 7 Online Status"
  #   id: "${devicename}_slave_unit_7_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x80
  #   icon: mdi:eye
  # Bit: 8  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 8 Online Status"
  #   id: "${devicename}_slave_unit_8_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x100
  #   icon: mdi:eye
  # Bit: 9  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 9 Online Status"
  #   id: "${devicename}_slave_unit_9_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x200
  #   icon: mdi:eye
  # Bit: 10  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 10 Online Status"
  #   id: "${devicename}_slave_unit_10_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x400
  #   icon: mdi:eye
  # Bit: 11  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 11 Online Status"
  #   id: "${devicename}_slave_unit_11_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x800
  #   icon: mdi:eye
  # Bit: 12  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 12 Online Status"
  #   id: "${devicename}_slave_unit_12_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x1000
  #   icon: mdi:eye
  # Bit: 13  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 13 Online Status"
  #   id: "${devicename}_slave_unit_13_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x2000
  #   icon: mdi:eye
  # Bit: 14  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 14 Online Status"
  #   id: "${devicename}_slave_unit_14_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x4000
  #   icon: mdi:eye
  # Bit: 15  -> registered for future use multiblock modules
  # - platform: modbus_controller
  #   modbus_controller_id: "${devicename}"
  #   name: "Slave Unit 15 Online Status"
  #   id: "${devicename}_slave_unit_15_online_status"
  #   register_type: holding
  #   address: 0x8e
  #   bitmask: 0x8000
  #   icon: mdi:eye

  # Register: 210, default: true, TODO: verify default  -> moved to switch
  # Bit: 0 -> moved to switch
  # Bit: 1, default: false, TODO: verify default -> moved to switch
  # Bit: 2, default: false, TODO: verify default -> moved to switch
  # Bit: 3, default: true, TODO: verify default -> moved to switch
  # Bit: 4, default: false, TODO: verify default -> moved to switch
  # Bit: 5, default: false, TODO: verify default -> moved to switch
  # Midea: PUMPI silent mode, 1; valid, 0: invalid -> moved to switch
  # Bit: 6, default: false, TODO: verify default -> moved to switch
  # Bit: 7, default: true, TODO: verify default -> moved to switch
  # Bit: 8, default: false, TODO: verify default -> moved to switch
  # Bit: 9, default: true, TODO: verify default -> moved to switch
  # Bit: 10, default: false, TODO: verify default -> moved to switch
  # Bit: 11, default: false, TODO: verify default -> moved to switch
  # Bit: 12, default: false, TODO: verify default -> moved to switch
  # Bit: 13, default: true, TODO: verify default -> moved to switch
  # Bit: 14, default: true, TODO: verify default -> moved to switch
  # Bit: 15, default: true, TODO: verify default -> moved to switch

  # Register: 211  -> moved to switch
  # Bit: 0, default: false, TODO: verify default  -> moved to switch
  # Bit: 1, default: false, TODO: verify default  -> moved to switch
  # Bit: 2, default: false, TODO: verify default -> moved to switch
  # Bit: 3, default: false, TODO: verify default -> moved to switch
  # Bit: 4, default: false, TODO: verify default -> moved to switch
  # Bit: 5, default: false, TODO: verify default -> moved to switch
  # Bit: 6, default: false, TODO: verify default -> moved to switch
  # Midea: T1B sensor enable -> moved to switch
  # Bit: 7, default: false, TODO: verify default -> moved to switch
  # Bit: 8, default: false, TODO: verify default -> moved to switch
  # Bit: 9, default: false, TODO: verify default -> moved to switch
  # Bit: 10, default: false, TODO: verify default -> moved to switch
  # Bit: 11, default: false, TODO: verify default -> moved to switch
  # Bit: 12, default: false, TODO: verify default -> moved to switch
  # Bit: 13, default: false, TODO: verify default -> moved to switch
  # Bit: 14, default: false, TODO: verify default -> moved to switch
  # Bit: 15, default: false, TODO: verify default -> moved to switch
  # Template binary sensor which shows if the heat pump is running
  - platform: template
    name: "Heat pump running"
    id: "${devicename}_heat_pump_running"
    entity_category: "diagnostic"
    device_class: plug
    icon: mdi:power    
    lambda: |-
      int fan_speed = id(${devicename}_fan_speed).state;
      int compressor_frequency = id(${devicename}_compressor_operating_frequency).state;
      bool external_water_pump_on = false; //id(${devicename}_load_output_external_water_pump_p_o).state;   //disabled
      bool internal_water_pump_I_on = id(${devicename}_load_output_water_pump_pump_i).state;
      //rather water_pump_i is better to check -external pump almost always run when Heatpump is idle, but most often nobody have it

      // If fan_speed is above 0, compressor_frequency is above 0 or external_water_pump_on is true or rather internal pump_i is true,
      // then the outside unit of the heat pump system is running
      if (fan_speed > 0 || compressor_frequency > 0 || external_water_pump_on || internal_water_pump_I_on) {
          return true;
      } else {
          return false;
      }

switch:
  #######################SECURE ANTIFREEZE##############################
  - platform: gpio
    name: "Relay 1 External Pump"
    id: "${devicename}_relay1_external_pump"
    pin: GPIO12
    icon: mdi:toggle-switch-off-outline
    on_turn_on: 
      then:
        lambda: |-
          if (id(${devicename}_load_output_water_pump_pump_i).state) {
          //turn off when pump_i active
            id(${devicename}_relay1_external_pump).turn_off();
            ESP_LOGI("TAG", "load_output_water_pump_pump_i is ON. Disable relay1 %d", id(relay1_start));
          } else {
            id(relay1_start) = id(esptime).now().timestamp;
            ESP_LOGI("TAG", "relay1_external_pump ON %d", id(relay1_start));
          }
    on_turn_off: 
      then:
        lambda: |-
          id(relay1_start) = 0;
          id(timestamp_water_pump_timestamp_last_run) = id(esptime).now().timestamp;
          ESP_LOGI("TAG", "relay1 OFF %d and save new time for last work PUMP_I", id(relay1_start));
    entity_category: "diagnostic"
   
  - platform: gpio
    name: "Relay 2 External Pump"
    id: "${devicename}_relay2_external_pump"
    pin: GPIO13
    icon: mdi:toggle-switch-off-outline
    on_turn_on: 
      then:
        lambda: |-
          if (id(${devicename}_load_output_water_pump_pump_i).state) {
          //turn off when pump_i active
            id(${devicename}_relay2_external_pump).turn_off();
          } else {
            id(relay2_start) = id(esptime).now().timestamp;
            ESP_LOGI("TAG", "relay2_external2 %d", id(relay2_start));
          }
    on_turn_off: 
        lambda: |-
          id(relay2_start) = 0;
          ESP_LOGE("TAG", "relay2 OFF %d", id(relay2_start));
    entity_category: "diagnostic"
  #########################################YORK###############################  
  # Register: 0 -> Bit 0
  # When Room Temperature Control is enabled, the temperature sensor in the remote controller
  # will be used to define when the heatpump should be turned (powered) on or off
  - platform: template
    name: "Room Temperature Control by FanCoilUnit"
    id: "${devicename}_room_temperature_control"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_0) & 0x1) == 0x1;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to on power_air_conditioner_zone_1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to off power_air_conditioner_zone_1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Register: 0 -> Bit 1
  # When Water Flow Temperature Control is enabled for thise zone, the target outlet water temperature
  # will be used to define when the heatpump should be turned (powered) on or off
  #
  # If room thermostat is enabled, controlling this switch will be done by the heatpump. In other words,
  # the room thermostat will decide when this will be on or off.
  - platform: template
    name: "Water Flow Temperature Control Zone 1"
    id: "${devicename}_water_flow_temperature_control_zone_1"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_0) & 0x2) == 0x2;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to on water_flow_temperature_control_zone_1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          id(manually_disabled_zone1_heating_timestamp) = 0;
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to off water_flow_temperature_control_zone_1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          id(manually_disabled_zone1_heating_timestamp) = id(esptime).now().timestamp;
  # Register: 0 -> Bit 2
  - platform: template
    name: "Power DHW T5S"
    id: "${devicename}_power_dhw_t5s"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda:  |-
        bool state_dhw = (id(unmasked_value_register_0) & 0x4) == 0x4;
        if (state_dhw) id(manually_disabled_dhw_heating_timestamp) = 0; else if (id(manually_disabled_dhw_heating_timestamp) == 0) id(manually_disabled_dhw_heating_timestamp) = id(esptime).now().timestamp;
        return state_dhw;
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to on power_dhw_t5s 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          id(manually_disabled_dhw_heating_timestamp) = 0;
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to off power_dhw_t5s 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          id(manually_disabled_dhw_heating_timestamp) = id(esptime).now().timestamp;
  # Register: 0 -> Bit 3
  # When Water Flow Temperature Control is enabled for thise zone, the target outlet water temperature
  # will be used to define when the heatpump should be turned (powered) on or off
  #
  # If room thermostat is enabled, controlling this switch will be done by the heatpump. In other words,
  # the room thermostat will decide when this will be on or off.
  - platform: template
    name: "Water Flow Temperature Control Zone 2" #this is for cooling with Fan Coil Unit!
    id: "${devicename}_water_flow_temperature_control_zone_2"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_0) & 0x8) == 0x8;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to on power_air_conditioner_zone_2 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          id(manually_disabled_zone2_heating_timestamp) = 0;
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          
          if ((new_value) != id(unmasked_value_register_0)) {
            ESP_LOGI("unmasked_value_register_0", "Set option to off power_air_conditioner_zone_2 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
          id(manually_disabled_zone2_heating_timestamp) = id(esptime).now().timestamp;
  # Register: 5 -> Bit: 4
  - platform: template
    name: "F.S. Disinfect"
    id: "${devicename}_f_s_disinfect"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x10) == 0x10;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_disinfect 0x%x -> 0x%xs", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_disinfect 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Register: 5 -> Bit: 5
  - platform: template
    name: "F.S. Holiday Away"
    id: "${devicename}_f_s_holiday_away"
    disabled_by_default: true
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x20) == 0x20;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_holiday_away 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_holiday_away 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Register: 5 -> Bit: 6
  - platform: template
    name: "F.S. Silent Mode"
    id: "${devicename}_f_s_silent_mode"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x40) == 0x40;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_silent_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_silent_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Register: 5 -> Bit: 7
  - platform: template
    name: "F.S. Silent Mode Level 1 or 2"
    id: "${devicename}_f_s_silent_mode_level"
    icon: mdi:eye
    #address: 5
    #bitmask: 0x80
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x80) == 0x80;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_silent_mode_level 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_silent_mode_level 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Register: 5 -> Bit: 8
  - platform: template
    name: "F.S. Holiday Home"
    id: "${devicename}_f_s_holiday_home"
    disabled_by_default: true
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x100) == 0x100;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_holiday_home 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_holiday_home 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  #Register: 5 -> Bit 9 at binary sensor
  # Register: 5 -> Bit: 10
  - platform: template
    name: "F.S. ECO Mode"
    id: "${devicename}_f_s_eco_mode"
    disabled_by_default: true
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x400) == 0x400;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_eco_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_eco_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Register: 5 -> Bit: 11
  - platform: template
    name: "F.S. DHW Pumps Running Constant Temperature Water Recycling"
    id: "${devicename}_f_s_dhw_pumps_running_constant_temperature_water_recycling"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x800) == 0x800;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on f_s_dhw_pumps_running_constant_temperature_water_recycling 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off f_s_dhw_pumps_running_constant_temperature_water_recycling 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Register: 5 -> Bit 12
  - platform: template
    name: "Weather Compensation Zone 1"
    id: "${devicename}_weather_compensation_zone_1"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x1000) == 0x1000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on weather_compensation_zone_1 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off weather_compensation_zone_1 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Register: 5 -> Bit 13
  - platform: template
    name: "Weather Compensation Zone 2"
    id: "${devicename}_weather_compensation_zone_2"
    disabled_by_default: true
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_5) & 0x2000) == 0x2000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to on weather_compensation_zone_2 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            ESP_LOGI("unmasked_value_register_5", "Set option to off weather_compensation_zone_2 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Register: 7
  - platform: template
    name: "Forced Water Tank Heater On/Off"
    id: "${devicename}_forced_water_tank_heater_on_off"
    icon: mdi:fire-alert
    #address: 0x7
    #register_type: holding
    entity_category: config
    #optimistic: true
    turn_on_action: 
      then:
        - lambda: |-
            uint16_t value = 1;
            ESP_LOGI("main", "Set forced water tank Heater ON");
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x7, value);
            ${devicename}->queue_command(set_payload_command);
            id(${devicename}_forced_water_tank_heater_on_off).publish_state(true);
    turn_off_action:
      then:
        - lambda: |-
            uint16_t value = 0; //documentation says 2
            ESP_LOGI("main", "Set forced water tank Heater OFF");
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x7, value);
            ${devicename}->queue_command(set_payload_command);
            id(${devicename}_forced_water_tank_heater_on_off).publish_state(false);
  # Register: 8
  - platform: template
    name: "Forced Tank Buffer Heater"
    id: "${devicename}_forced_tbh"
    icon: mdi:fire-alert
    entity_category: config
    #optimistic: true
    turn_on_action: 
      then:
        - lambda: |-
            uint16_t value = 1;
            ESP_LOGI("main", "Set Forced Tank Buffer Heater ON");
            //disble forced -restricted that TBH and IBH1/IBH2 cant run together
            id(${devicename}_forced_hydraulic_module_rear_electric_heater_1).publish_state(false);
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x8, value);
            ${devicename}->queue_command(set_payload_command);
            id(${devicename}_forced_tbh).publish_state(true);
    turn_off_action:
      then:
        - lambda: |-
            uint16_t value = 0; //documentation says 2
            ESP_LOGI("main", "Set Forced Tank Buffer Heater OFF");
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x8, value);
            ${devicename}->queue_command(set_payload_command);
            id(${devicename}_forced_tbh).publish_state(false);
  # # Register: 9
  - platform: template
    name: "Forced Hydraulic Module Rear Electric Heater 1"
    id: "${devicename}_forced_hydraulic_module_rear_electric_heater_1"
    icon: mdi:fire-alert
    entity_category: config
    optimistic: true
    on_turn_on: 
      then:
        - lambda: |-
            uint16_t value = 1;
            ESP_LOGI("main", "Forced Hydraulic Module Rear Electric Heater 1");
            //disble forced -restricted that TBH and IBH1/IBH2 cant run together
            id(${devicename}_forced_tbh).publish_state(false);
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x9, value);
            ${devicename}->queue_command(set_payload_command);
            id(${devicename}_forced_hydraulic_module_rear_electric_heater_1).publish_state(true);
    on_turn_off:
      then:
        - lambda: |-
            uint16_t value = 0; //documentation says 2
            ESP_LOGI("main", "Forced Hydraulic Module Rear Electric Heater 1");
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x9, value);
            ${devicename}->queue_command(set_payload_command);
            id(${devicename}_forced_hydraulic_module_rear_electric_heater_1).publish_state(false);

  # Register: 210, default: true, TODO: verify default
  # Bit: 0
  - platform: template
    name: "PS1 Heating And Cooling First Or Water First"
    id: "${devicename}_p_s_1_heating_and_cooling_first_or_water_first"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x1) == 0x1;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_heating_and_cooling_first_or_water_first 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_heating_and_cooling_first_or_water_first 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 1, default: false, TODO: verify default
  - platform: template
    name: "PS1 Dual Room Thermostat Supported"
    id: "${devicename}_p_s_1_dual_room_thermostat_supported"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x2) == 0x2;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_dual_room_thermostat_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_dual_room_thermostat_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 2, default: false, TODO: verify default
  - platform: template
    name: "PS1 Room Thermostat"
    id: "${devicename}_p_s_1_room_thermostat"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x4) == 0x4;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 3, default: true, TODO: verify default
  - platform: template
    name: "PS1 Supports Room Thermostat"
    id: "${devicename}_p_s_1_supports_room_thermostat"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x8) == 0x8;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_supports_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_supports_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 4, default: false, TODO: verify default
  - platform: template
    name: "PS1 Supports Room Temperature Sensor Ta"
    id: "${devicename}_p_s_1_supports_room_temperature_sensor_ta"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x10) == 0x10;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_supports_room_temperature_sensor_ta 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_supports_room_temperature_sensor_ta 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 5, default: false, TODO: verify default
  # Midea: PUMPI silent mode, 1; valid, 0: invalid
  - platform: template
    name: "PS1 Silent Mode PUMP I,"
    id: "${devicename}_p_s_1_silent_mode_pump_i"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x20) == 0x20;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_silent_mode_pump_i 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_silent_mode_pump_i 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 6, default: false, TODO: verify default
  - platform: template
    name: "PS1 T1S Heating High Low Temperature Settings RO?"
    id: "${devicename}_p_s_1_t1s_heating_high_low_temperature_settings"
    icon: mdi:eye
    restore_mode: DISABLED
    #entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x40) == 0x40;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_t1s_heating_high_low_temperature_settings 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_t1s_heating_high_low_temperature_settings 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 7, default: true, TODO: verify default
  - platform: template
    name: "PS1 Enable Heating"
    id: "${devicename}_p_s_1_enable_heating"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x80) == 0x80;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_enable_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_enable_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 8, default: false, TODO: verify default
  - platform: template
    name: "PS1 T1s Cooling High Low Temperature Settings RO?"
    id: "${devicename}_p_s_1_t1s_cooling_high_low_temperature_settings"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x100) == 0x100;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_t1s_cooling_high_low_temperature_settings 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_t1s_cooling_high_low_temperature_settings 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 9, default: true, TODO: verify default
  - platform: template
    name: "PS1 Enable Cooling"
    id: "${devicename}_p_s_1_enable_cooling"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x200) == 0x200;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_enable_cooling 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_enable_cooling 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 10, default: false, TODO: verify default
  - platform: template
    name: "PS1 DHW Pump Supports Pipe Disinfect"
    id: "${devicename}_p_s_1_dhw_pump_supports_pipe_disinfect"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x400) == 0x400;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_dhw_pump_supports_pipe_disinfect 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_dhw_pump_supports_pipe_disinfect 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  #bit11 is in binary_sensor
  # Bit: 12, default: false, TODO: verify default
  - platform: template
    name: "PS1 DHW Pump Supported"
    id: "${devicename}_p_s_1_dhw_pump_supported"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x1000) == 0x1000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_dhw_pump_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_dhw_pump_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 13, default: true, TODO: verify default
  - platform: template
    name: "PS1 Supports Disinfection"
    id: "${devicename}_p_s_1_supports_disinfection"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x2000) == 0x2000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_supports_disinfection 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_supports_disinfection 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 14, default: true, TODO: verify default
  - platform: template
    name: "PS1 Supports Water Tank Electric Heater TBH RO?"
    id: "${devicename}_p_s_1_supports_water_tank_electric_heater_tbh"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x4000) == 0x4000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x4000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_supports_disinfection 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x4000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_supports_disinfection 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 15, default: true, TODO: verify default
  - platform: template
    name: "PS1 Enable Water Heating"
    id: "${devicename}_p_s_1_enable_water_heating"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_210) & 0x8000) == 0x8000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x8000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_enable_water_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x8000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_enable_water_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Register: 211
  # Bit: 0, default: false, TODO: verify default
  - platform: template
    name: "PS2 IBH AHS Installation Position"
    #0: pipe
    id: "${devicename}_p_s_2_ibh_ahs_installation_position"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x1) == 0x1;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 1, default: false, TODO: verify default
  - platform: template
    name: "PS2 Tbt Sensor Enable"
    id: "${devicename}_p_s_2_tbt_sensor_enable"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x2) == 0x2;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_tbt_sensor_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_tbt_sensor_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 2, default: false, TODO: verify default
  - platform: template
    name: "PS2 Ta Sensor Position"
    id: "${devicename}_p_s_2_ta_sensor_position"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x4) == 0x4;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_ta_sensor_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_ta_sensor_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Bit: 3, default: false, TODO: verify default
  - platform: template
    name: "PS2 Double Zone Setting Is Valid"
    id: "${devicename}_p_s_2_double_zone_setting_is_valid"
    disabled_by_default: true
    icon: mdi:eye
    #bitmask: 0x8
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x8) == 0x8;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Bit: 4, default: false, TODO: verify default
  - platform: template
    name: "PS2 Setting The High Low Temperature Of Heating Mode T1S"
    id: "${devicename}_p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x10) == 0x10;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Bit: 5, default: false, TODO: verify default
  - platform: template
    name: "PS2 Setting The High Low Temperature Of Cooling Mode T1S"
    id: "${devicename}_p_s_2_setting_the_high_low_temperature_of_cooling_mode_t1s"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x20) == 0x20;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_setting_the_high_low_temperature_of_cooling_mode_t1s 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_setting_the_high_low_temperature_of_cooling_mode_t1s 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }  
  # Bit: 6, default: false, TODO: verify default
  # Midea: T1B sensor enable -buffer sensor
  - platform: template
    name: "PS2 Tw2 T1B Enabled"
    id: "${devicename}_p_s_2_tw2_enabled"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x40) == 0x40;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_tw2_enabled 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_tw2_enabled 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 7, default: false, TODO: verify default
  - platform: template
    name: "PS2 Smart Grid"
    id: "${devicename}_p_s_2_smart_grid"
    disabled_by_default: true
    icon: mdi:eye
    #bitmask: 0x80
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x80) == 0x80;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }    
  # Bit: 8, default: false, TODO: verify default
  - platform: template
    name: "PS2 Port 0-OnOff_1-DHW heater"
    id: "${devicename}_p_s_2_port_definition"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x100) == 0x100;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 9, default: false, TODO: verify default
  - platform: template
    name: "PS2 Solar Energy Kit Enable"
    id: "${devicename}_p_s_2_solar_energy_kit_enable"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x200) == 0x200;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_solar_energy_kit_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_solar_energy_kit_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 10, default: false, TODO: verify default
  - platform: template
    name: "PS2 Solar Energy Input Port"
    #Solar energy input port 1: CN18 0: CN11
    id: "${devicename}_p_s_2_solar_energy_input_port"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x400) == 0x400;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 11, default: false, TODO: verify default
  - platform: template
    name: "PS2 Piping Length Selection"
    id: "${devicename}_p_s_2_piping_length_selection"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x800) == 0x800;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_piping_length_selection 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_piping_length_selection 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          } 
  # Bit: 12, default: false, TODO: verify default
  - platform: template
    name: "PS2 Tbt2 Sensor Is Valid"
    id: "${devicename}_p_s_2_tbt2_sensor_is_valid"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x1000) == 0x1000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_tbt2_sensor_is_valid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_tbt2_sensor_is_valid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 13, default: false, TODO: verify default
  - platform: template
    name: "PS2 Enable Temperature Collection Kit"
    id: "${devicename}_p_s_2_enable_temperature_collection_kit"
    disabled_by_default: true
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x2000) == 0x2000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_enable_temperature_collection_kit 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_enable_temperature_collection_kit 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  # Bit: 14, default: false, TODO: verify default
  - platform: template
    name: "PS2 M1M2 Is Used For AHS Control"
    id: "${devicename}_p_s_2_m1m2_is_used_for_ahs_control"
    disabled_by_default: true
    icon: mdi:eye
    #bitmask: 0x4000
    restore_mode: DISABLED
    entity_category: config
    optimistic : true
    lambda: "return (id(unmasked_value_register_211) & 0x4000) == 0x4000;"
    on_turn_on:
      #- logger.log: "Switch Turned On!"
      - lambda: |-
          uint16_t checked_bit = 0x4000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_m1m2_is_used_for_ahs_control 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      #- logger.log: "Switch Turned Off!"    
      - lambda: |-
          uint16_t checked_bit = 0x4000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;         //Clear and set
          
          if ((new_value) != id(unmasked_value_register_211)) {
            ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_m1m2_is_used_for_ahs_control 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  #BIT15 is in binary_sensor as reserved  


  - platform: template
    name: "SM Enable RecoverTime enable DHW"
    id: "${devicename}_enable_recoverytime_enable_dhw"
    #optimistic: true
    entity_category: "config"
    icon: mdi:switch
    #update global with value to save
    turn_on_action: 
      then:
        lambda: 'id(Restore_enable_DHW) = true; ESP_LOGI("Enable RecoverTime enable DHW"," is ON state: %d", id(Restore_enable_DHW)); id(${devicename}_enable_recoverytime_enable_dhw).publish_state(id(Restore_enable_DHW));'
    turn_off_action: 
      then:
        lambda: 'id(Restore_enable_DHW) = false; ESP_LOGI("Enable RecoverTime enable DHW"," is OFF state: %d", id(Restore_enable_DHW)); id(${devicename}_enable_recoverytime_enable_dhw).publish_state(id(Restore_enable_DHW));'
  - platform: template
    name: "SM Enable RecoverTime enable Zone1"
    id: "${devicename}_enable_recoverytime_enable_zone1"
    #optimistic: true
    entity_category: "config"
    icon: mdi:switch
    #update global with value to save
    turn_on_action: 
      then:
        lambda: 'id(Restore_enable_Zone1) = true; ESP_LOGI("Enable RecoverTime enable ZONE1"," is ON state: %d", id(Restore_enable_Zone1)); id(${devicename}_enable_recoverytime_enable_zone1).publish_state(id(Restore_enable_Zone1));'
    turn_off_action: 
      then:
        lambda: 'id(Restore_enable_Zone1) = false; ESP_LOGI("Enable RecoverTime enable Zone1"," is OFF state: %d", id(Restore_enable_Zone1)); id(${devicename}_enable_recoverytime_enable_zone1).publish_state(id(Restore_enable_Zone1));'
  - platform: template
    name: "SM Enable RecoverTime enable Zone2"
    id: "${devicename}_enable_recoverytime_enable_zone2"
    #optimistic: true
    entity_category: "config"
    icon: mdi:switch
    #update global with value to save
    turn_on_action: 
      then:
        lambda: 'id(Restore_enable_Zone2) = true; ESP_LOGI("Enable RecoverTime enable Zone2"," is ON state: %d", id(Restore_enable_Zone2)); id(${devicename}_enable_recoverytime_enable_zone2).publish_state(id(Restore_enable_Zone2));'
    turn_off_action: 
      then:
        lambda: 'id(Restore_enable_Zone2) = false; ESP_LOGI("Enable RecoverTime enable Zone2"," is OFF state: %d", id(Restore_enable_Zone2)); id(${devicename}_enable_recoverytime_enable_zone2).publish_state(id(Restore_enable_Zone2));'
################################################################################################################################
number:
  # Register: 2 (Zone 1, Low)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set Water Temperature T1S Zone 1"
    id: "${devicename}_set_water_temperature_t1s_zone_1"
    register_type: holding
    address: 0x2
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    entity_category: config
    min_value: 5
    max_value: 65
    mode: slider
    lambda: |-
      // Update the global var unmasked_value_water_temperature_t1s
      id(unmasked_value_water_temperature_t1s) = x;

      // ESP_LOGI("","unmasked_value_water_temperature_t1s: %d",id(unmasked_value_water_temperature_t1s));

      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)

      auto operation_state = id(${devicename}_operational_mode).state;
      auto end_heating_unit = id(${devicename}_zone_1_end_heating_mode_emission_type).state;
      auto end_cooling_unit = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;
      uint8_t x_tmp = value_bytes[1];
      if (operation_state == "Cool") {
        if (x_tmp < 5 and end_cooling_unit == "Fan Coil Unit") value_bytes[1] = 5;
        if (x_tmp < 18 and end_cooling_unit != "Fan Coil Unit") value_bytes[1] = 18;
        if (x_tmp > 25) value_bytes[1] = 25;
      } else if (operation_state == "Heat") {
        if (x_tmp < 25 and end_heating_unit == "Underfloor Heating") value_bytes[1] = 25;
        if (x_tmp > 55 and end_heating_unit == "Underfloor Heating") value_bytes[1] = 55;
        if (x_tmp < 35 and end_heating_unit == "Radiator") value_bytes[1] = 35;
        if (x_tmp > 65 and end_heating_unit == "Radiator") value_bytes[1] = 65;
      }
      // ESP_LOGI("Register 2Low","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);

      return value_bytes[1];
    write_lambda: |-
      uint16_t value = id(unmasked_value_water_temperature_t1s); // The original unmasked value
      uint8_t value_byte = x;                                    // New byte value with the new temp for zone 1
      auto operation_state = id(${devicename}_operational_mode).state;
      auto end_heating_unit = id(${devicename}_zone_1_end_heating_mode_emission_type).state;
      auto end_cooling_unit = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;
      
      if (operation_state == "Cool") {
        if (x < 5 and end_cooling_unit == "Fan Coil Unit") value_byte = 5;
        if (x < 18 and end_cooling_unit != "Fan Coil Unit") value_byte = 18;
        if (x > 25) value_byte = 25;
      } else if (operation_state == "Heat" or operation_state == "Auto") {
        if (x < 25 and end_heating_unit == "Underfloor Heating") value_byte = 25;
        if (x > 55 and end_heating_unit == "Underfloor Heating") value_byte = 55;
        if (x < 35 and end_heating_unit == "Radiator") value_byte = 35;
        if (x > 65 and end_heating_unit == "Radiator") value_byte = 65;
      }
      value &= 0xFF00;      // Clear the lower byte of the value
      value |= value_byte;  // Update the lower byte with the new byte value

      ESP_LOGI("Register 6Low, set_water_temperature_t1s_zone_1", "Set option to %f, Original value 0x%x New value: 0x%x", float(x), id(unmasked_value_water_temperature_t1s), value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x2, value);
      ${devicename}->queue_command(set_payload_command);
      id(unmasked_value_water_temperature_t1s) = value;
      return {};

  # Register: 2 (Zone 2, High)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set Water Temperature T1S Zone 2"
    id: "${devicename}_set_water_temperature_t1s_zone_2"
    register_type: holding
    address: 0x2
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    entity_category: config
    min_value: 5
    max_value: 65
    mode: slider
    lambda: |-
      // The global var unmasked_value_water_temperature_t1s is already
      // updated in the previous, where the low byte variant is executed
      // id(unmasked_value_water_temperature_t1s) = x;

      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)

      auto operation_state = id(${devicename}_operational_mode).state;
      auto end_heating_unit = id(${devicename}_zone_2_end_heating_mode_emission_type).state;
      auto end_cooling_unit = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;
      uint8_t x_tmp = value_bytes[0];
      if (operation_state == "Cool") {
        if (x_tmp < 5 and end_cooling_unit == "Fan Coil Unit") value_bytes[0] = 5;
        if (x_tmp < 18 and end_cooling_unit != "Fan Coil Unit") value_bytes[0] = 18;
        if (x_tmp > 25) value_bytes[0] = 25;
      } else if (operation_state == "Heat") {
        if (x_tmp < 25 and end_heating_unit == "Underfloor Heating") value_bytes[0] = 25;
        if (x_tmp < 35 and end_heating_unit == "Radiator") value_bytes[0] = 35;
        if (x_tmp > 55 and end_heating_unit == "Underfloor Heating") value_bytes[0] = 55;
        if (x_tmp > 65 and end_heating_unit == "Radiator") value_bytes[0] = 65;
      }
      //ESP_LOGI("Register 2High","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);
      return value_bytes[0];
    write_lambda: |-
      uint16_t value = id(unmasked_value_water_temperature_t1s); // The original unmasked value
      uint8_t value_byte = x;                                    // New byte value with the new temp for zone 2

      //apply minmax for standard temp
      auto operation_state = id(${devicename}_operational_mode).state;
      auto end_heating_unit = id(${devicename}_zone_2_end_heating_mode_emission_type).state;
      auto end_cooling_unit = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;
      if (operation_state == "Cool") {
        if (x < 5 and end_cooling_unit == "Fan Coil Unit") value_byte = 5;
        if (x < 18 and end_cooling_unit != "Fan Coil Unit") value_byte = 18;
        if (x >25) value_byte = 25;
      } else if (operation_state == "Heat") {
        if (x < 25 and end_heating_unit == "Underfloor Heating") value_byte = 25;
        if (x > 55 and end_heating_unit == "Underfloor Heating") value_byte = 55;
        if (x < 35 and end_heating_unit == "Radiator") value_byte = 35;
        if (x > 65 and end_heating_unit == "Radiator") value_byte = 65;
      }
      value &= 0x00FF;             // Clear the upper byte of the value
      value |= (value_byte << 8);  // Update the upper byte with the new byte value

      ESP_LOGI("set_water_temperature_t1s_zone_2", "Set option to %f, Original value 0x%x New value: 0x%x", float(x), id(unmasked_value_water_temperature_t1s), value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x2, value);
      ${devicename}->queue_command(set_payload_command);
      id(unmasked_value_water_temperature_t1s) = value;
      return {};

  # Register: 4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set DHW Tank Temperature T5s"
    id: "${devicename}_set_dhw_tank_temperature_t5s"
    register_type: holding
    address: 0x4
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:temperature-celsius
    entity_category: config
    min_value: 20
    max_value: 65
    mode: slider

  # Register: 6 (Zone 1, Low)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Weather Compensation Curve Zone 1"
    id: "${devicename}_weather_compensation_curve_zone_1"
    register_type: holding
    address: 0x6
    value_type: U_WORD
    entity_category: config
    icon: mdi:eye
    min_value: 1
    max_value: 9
    mode: slider
    lambda: |-
      // Update the global var unmasked_curve_selection
      id(unmasked_curve_selection) = x;

      // ESP_LOGI("","unmasked_curve_selection: %d",id(unmasked_curve_selection));

      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)

      // ESP_LOGI("Register 6Low","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);

      return value_bytes[1];
    write_lambda: |-
      uint16_t value = id(unmasked_curve_selection); // The original unmasked value
      uint8_t value_byte = x;                        // New byte value with the new temp for zone 1

      value &= 0xFF00;      // Clear the lower byte of the value
      value |= value_byte;  // Update the lower byte with the new byte value

      ESP_LOGI("Register 6Low", "Original value: %d, New value: %d", id(unmasked_curve_selection), value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x6, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  # Register: 6 (Zone 2, High)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Weather Compensation Curve Zone 2"
    id: "${devicename}_weather_compensation_curve_zone_2"
    register_type: holding
    address: 0x6
    value_type: U_WORD
    entity_category: config
    icon: mdi:eye
    min_value: 1
    max_value: 9
    mode: slider
    lambda: |-
      // The global var unmasked_curve_selection is already
      // updated in the previous, where the low byte variant is executed
      // id(unmasked_curve_selection) = x;

      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)

      return value_bytes[0];
    write_lambda: |-
      uint16_t value = id(unmasked_curve_selection); // The original unmasked value
      uint8_t value_byte = x;                        // New byte value with the new temp for zone 2

      value &= 0x00FF;             // Clear the upper byte of the value
      value |= (value_byte << 8);  // Update the upper byte with the new byte value
      ESP_LOGI("Register 6High", "Original value: %d, New value: %d", id(unmasked_curve_selection), value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x6, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
# Register: 10
#  - platform: modbus_controller
#    modbus_controller_id: "${devicename}"
#    name: "Reserved"
#    id: "${devicename}_reserved"
#    register_type: holding
#    address: 10
#    value_type: U_WORD
#    entity_category: "config"
  #  web_server_sorting_weight: 5
  # Register: 11
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature T1s Zone1"
    id: "${devicename}_temperature_t1s_zone1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 11
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: "config"
    min_value: 5
    max_value: 65
    mode: slider
    # web_server_sorting_weight: 5
    lambda: |-
        float value = x;
        auto operation_state = id(${devicename}_operational_mode).state;
        auto end_heating_unit = id(${devicename}_zone_1_end_heating_mode_emission_type).state;
        auto end_cooling_unit = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;
        if (operation_state == "Cool") {
          if (x < 5 and end_cooling_unit == "Fan Coil Unit") value = 5;
          if (x < 18 and end_cooling_unit != "Fan Coil Unit") value = 18;
          if (x > 25) value = 25;
        } else if (operation_state == "Heat") {
          if (x < 25 and end_heating_unit == "Underfloor Heating") value = 25;
          if (x > 55 and end_heating_unit == "Underfloor Heating") value = 55;
          if (x < 35 and end_heating_unit == "Radiator") value = 35;
          if (x > 65 and end_heating_unit == "Radiator") value = 65;
        }
        return value;
    write_lambda: |-
        //return{}; //maybe this duplicate write?
        uint16_t value = x;
        auto operation_state = id(${devicename}_operational_mode).state;
        auto end_heating_unit = id(${devicename}_zone_1_end_heating_mode_emission_type).state;
        auto end_cooling_unit = id(${devicename}_zone_1_end_cooling_mode_emission_type).state;
        if (operation_state == "Cool") {
          if (x < 5 and end_cooling_unit == "Fan Coil Unit") value = 5;
          if (x < 18 and end_cooling_unit != "Fan Coil Unit") value = 18;
          if (x > 25) value = 25;
        } else if (operation_state == "Heat") {
          if (x < 25 and end_heating_unit == "Underfloor Heating") value = 25;
          if (x > 55 and end_heating_unit == "Underfloor Heating") value = 55;
          if (x < 35 and end_heating_unit == "Radiator") value = 35;
          if (x > 65 and end_heating_unit == "Radiator") value = 65;
        }
        ESP_LOGI("temperature_t1s_zone1", "Set option to %f, New value: %d", float(x), value);
        esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 11, value);
        ${devicename}->queue_command(set_payload_command);
        return {};

  # Register: 12
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature T1s Zone2"
    id: "${devicename}_temperature_t1s_zone2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 12
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 5
    max_value: 65
    mode: slider
    # web_server_sorting_weight: 5
    lambda: |-
        float value = x;
        auto operation_state = id(${devicename}_operational_mode).state;
        auto end_heating_unit = id(${devicename}_zone_2_end_heating_mode_emission_type).state;
        auto end_cooling_unit = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;
        if (operation_state == "Cool") {
          if (x < 5 and end_cooling_unit == "Fan Coil Unit") value = 5;
          if (x < 18 and end_cooling_unit != "Fan Coil Unit") value = 18;
          if (x >25) value = 25;
        } else if (operation_state == "Heat") {
          if (x < 25 and end_heating_unit == "Underfloor Heating") value = 25;
          if (x > 55 and end_heating_unit == "Underfloor Heating") value = 55;
          if (x < 35 and end_heating_unit == "Radiator") value = 35;
          if (x > 65 and end_heating_unit == "Radiator") value = 65;
        }
        return value;
    write_lambda: |-
      //return{}; //maybe this duplicate write?
      uint16_t value = x;
      auto operation_state = id(${devicename}_operational_mode).state;
      auto end_heating_unit = id(${devicename}_zone_2_end_heating_mode_emission_type).state;
      auto end_cooling_unit = id(${devicename}_zone_2_end_cooling_mode_emission_type).state;
      if (operation_state == "Cool") {
        if (x < 5 and end_cooling_unit == "Fan Coil Unit") value = 5;
        if (x < 18 and end_cooling_unit != "Fan Coil Unit") value = 18;
        if (x >25) value = 25;
      } else if (operation_state == "Heat") {
        if (x < 25 and end_heating_unit == "Underfloor Heating") value = 25;
        if (x > 55 and end_heating_unit == "Underfloor Heating") value = 55;
        if (x < 35 and end_heating_unit == "Radiator") value = 35;
        if (x > 65 and end_heating_unit == "Radiator") value = 65;
      }
      ESP_LOGI("temperature_t1s_zone2", "Set option to %f, New value: %d", float(x), value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 12, value);
      ${devicename}->queue_command(set_payload_command);
      return {};
  # Register: 209, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DHW Pump Return Running Time"
    id: "${devicename}_dhw_pump_return_running_time"
    register_type: holding
    address: 0xd1
    value_type: U_WORD
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 5
    max_value: 120
  # Register: 212, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT5_On"
    id: "${devicename}_dt5_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd4
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 2
    max_value: 30
  # Register: 213, default: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT1S5"
    id: "${devicename}_dt1s5"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd5
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 5
    max_value: 40
  # Register: 214, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T Interval DHW"
    id: "${devicename}_t_interval_dhw"
    register_type: holding
    address: 0xd6
    value_type: U_WORD
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 5
    max_value: 30
  # Register: 215, default: 43
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4 DHW max"
    id: "${devicename}_t4_dhw_max"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd7
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 35
    max_value: 43
  # Register: 216, default: -10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4 DHW min"
    id: "${devicename}_t4dhwmin"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd8
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -25
    max_value: 5
  # Register: 217, default: 30
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t TBH Delay"
    id: "${devicename}_t_tbh_delay"
    icon: mdi:camera-timer
    register_type: holding
    address: 0xd9
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 0
    max_value: 240
    step: 5
  # Register: 218, default: 5
  # Also known as dT5S TBH Off (dt5s_tbh_off)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT5 TBH Off"
    id: "${devicename}_dt5_tbh_off"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xda
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 0
    max_value: 10
  # Register: 219, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4 TBH On"
    id: "${devicename}_t4_tbh_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xdb
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 20
  # Register: 220, default: 65
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature For Disinfection Operation"
    id: "${devicename}_t5s_di"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xdc
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 60
    max_value: 70
  # Register: 221, default: 210
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Maximum Disinfection Duration"
    id: "${devicename}_t_di_max"
    disabled_by_default: true
    register_type: holding
    address: 0xdd
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 90
    max_value: 300
  # Register: 222, default: 15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Disinfection High Temperature Duration"
    id: "${devicename}_t_di_hightemp"
    disabled_by_default: true
    register_type: holding
    address: 0xde
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 5
    max_value: 60
  # Register: 223, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Time Interval Of Compressor Startup In Cooling mode"
    id: "${devicename}_t_interval_c"
    register_type: holding
    address: 0xdf
    value_type: U_WORD
    unit_of_measurement: min
    icon: mdi:clock
    entity_category: config
    min_value: 5
    max_value: 30
  # Register: 224, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT1SC"
    id: "${devicename}_dt1sc"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe0
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 2
    max_value: 10
  # Register: 225, default: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dTSC"
    id: "${devicename}_dtsc"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe1
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 1
    max_value: 10
  # Register: 226, default: 43
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4cmax"
    id: "${devicename}_t4cmax"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe2
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 35
    max_value: 46
  # Register: 227, default: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4cmin"
    id: "${devicename}_t4cmin"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe3
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 25
  # Register: 228, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Time Interval Of Compressor Startup In Heating mode"
    id: "${devicename}_t_interval_h"
    register_type: holding
    address: 0xe4
    value_type: U_WORD
    unit_of_measurement: min
    icon: mdi:clock
    entity_category: config
    min_value: 5
    max_value: 60
  # Register: 229, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT1SH"
    id: "${devicename}_dt1sh"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe5
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 2
    max_value: 10
  # Register: 230, default: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dTSH"
    id: "${devicename}_dtsh"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe6
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 1
    max_value: 10
  # Register: 231, default: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4hmax"
    id: "${devicename}_t4hmax"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe7
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 20
    max_value: 35
  # Register: 232, default: -15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4hmin"
    id: "${devicename}_t4hmin"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe8
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -25
    max_value: 5
  # Register: 233, default: -5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ambient Temperature For Enabling Hydraulic Module Auxiliary Electric Heating IBH"
    id: "${devicename}_t4_ibh_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe9
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -15
    max_value: 10
  # Register: 234, default: 5, TODO: verify min/max value
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Return Difference For Enabling The Hydraulic Module Auxiliary IBH"
    id: "${devicename}_dt1_ibh_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xea
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 1
    max_value: 7
  # Register: 235, default: 30
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Delay Time Of Enabling The Hydraulic Module Auxiliary Electric Heating IBH"
    id: "${devicename}_t_ibh_delay"
    disabled_by_default: true
    icon: mdi:camera-timer
    register_type: holding
    address: 0xeb
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 15
    max_value: 120
  # Register: 237, default: 10, TODO: verify default
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ambient Temperature Trigger For AHS"
    id: "${devicename}_t4_ahs_on"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xed
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -15
    max_value: 10
  # Register: 238, default: 5, TODO: verify max/max value
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Trigger Temperature Difference Between T1S And Current Heat for AHS"
    id: "${devicename}_dt1_ahs_on"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xee
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 1
    max_value: 7
  # Register: 240, default: 30
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Delay Time for Enabling AHS"
    id: "${devicename}_t_ahs_delay"
    disabled_by_default: true
    icon: mdi:camera-timer
    register_type: holding
    address: 0xf0
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 5
    max_value: 120
  # Register: 241, default: 120
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Heating Max Duration"
    id: "${devicename}_t_dhwhp_max"
    register_type: holding
    address: 0xf1
    value_type: U_WORD
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 10
    max_value: 600
  # Register: 242, default: 30
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T DHWHP Restrict"
    id: "${devicename}_t_dhwhp_restrict"
    register_type: holding
    address: 0xf2
    value_type: U_WORD
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 10
    max_value: 600
  # Register: 243, default: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4autocmin"
    id: "${devicename}_t4autocmin"
    register_type: holding
    address: 0xf3
    value_type: U_WORD
    unit_of_measurement: "°C"
    icon: mdi:thermometer
    entity_category: config
    min_value: 20
    max_value: 29
  # Register: 244, default: 17
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4autohmax"
    id: "${devicename}_t4autohmax"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xf4
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 10
    max_value: 17
  # Register: 245, default: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Heating Or Cooling Temperature When Holiday Mode Is Active"
    id: "${devicename}_t1s_h_a_h"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xf5
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 20
    max_value: 29
  # Register: 246, default: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Domestic Hot Water Temperature When Holiday Mode is Active"
    id: "${devicename}_t5s_h_a_dhw"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xf6
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 20
    max_value: 25
  # Register: 247, default: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "PER START Ratio"
    id: "${devicename}_per_start_ratio"
    register_type: holding
    address: 0xf7
    value_type: U_WORD
    entity_category: config
    icon: mdi:eye
    min_value: 10
    max_value: 100
    step: 10
  # Register: 248, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "TIME ADJUST"
    id: "${devicename}_time_adjust"
    disabled_by_default: true
    register_type: holding
    address: 0xf8
    value_type: U_WORD
    entity_category: config
    min_value: 1
    max_value: 60
  # Register: 249, default: 15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DTbt2"
    id: "${devicename}_dtbt2"
    disabled_by_default: true
    register_type: holding
    address: 0xf9
    value_type: U_WORD
    icon: mdi:temperature-celsius
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 0
    max_value: 50
  # Register: 250, default: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "IBH1 Power"
    id: "${devicename}_ibh1_power"
    disabled_by_default: true
    icon: mdi:alpha-w
    register_type: holding
    address: 0xfa
    value_type: U_WORD
    unit_of_measurement: W
    multiply: 0.01
    entity_category: config
    min_value: 0
    max_value: 20000
  # Register: 251, default: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "IBH2 Power"
    id: "${devicename}_ibh2_power"
    disabled_by_default: true
    icon: mdi:alpha-w
    register_type: holding
    address: 0xfb
    value_type: U_WORD
    unit_of_measurement: W
    multiply: 0.01
    entity_category: config
    min_value: 0
    max_value: 20000
  # Register: 252, default: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "TBH Power"
    id: "${devicename}_tbh_power"
    disabled_by_default: true
    icon: mdi:alpha-w
    register_type: holding
    address: 0xfc
    value_type: U_WORD
    unit_of_measurement: W
    multiply: 0.01
    entity_category: config
    min_value: 0
    max_value: 20000
  # Register: 255, default: 8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Rise Day Number"
    id: "${devicename}_t_dryup"
    disabled_by_default: true
    register_type: holding
    address: 0xff
    value_type: U_WORD
    entity_category: config
    min_value: 4
    max_value: 15
  # Register: 256, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Drying Day Number"
    id: "${devicename}_t_highpeak"
    disabled_by_default: true
    register_type: holding
    address: 0x100
    value_type: U_WORD
    entity_category: config
    min_value: 3
    max_value: 7
  # Register: 257, default: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Drop Day Number"
    id: "${devicename}_t_dryd"
    disabled_by_default: true
    register_type: holding
    address: 0x101
    value_type: U_WORD
    entity_category: config
    min_value: 4
    max_value: 15
  # Register: 258, default: 45
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Highest Drying Temperature"
    id: "${devicename}_t_drypeak"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x102
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 30
    max_value: 55
  # Register: 259, default: 72
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Running Time Of Floor Heating For The First Time"
    id: "${devicename}_t_firstfh"
    disabled_by_default: true
    register_type: holding
    address: 0x103
    value_type: U_WORD
    unit_of_measurement: hr
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 48
    max_value: 96
  # Register: 260, default: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1S Of Floor Heating For The First Time"
    id: "${devicename}_t1s_firstfh"
    disabled_by_default: true
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x104
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 25
    max_value: 35
  # Register: 261, default: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetC1"
    id: "${devicename}_t1setc1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x105
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 5
    max_value: 25
  # Register: 262, default: 16
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetC2"
    id: "${devicename}_t1setc2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x106
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 5
    max_value: 25
  # Register: 263, default: 35
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4C1"
    id: "${devicename}_t4c1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x107
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 46
  # Register: 264, default: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4C2"
    id: "${devicename}_t4c2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x108
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 46
  # Register: 265, default: 35
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetH1"
    id: "${devicename}_t1seth1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x109
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 25
    max_value: 65
  # Register: 266, default: 28
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetH2"
    id: "${devicename}_t1seth2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x10a
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 25
    max_value: 65
  # Register: 267, default: -5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4H1"
    id: "${devicename}_t4h1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x10b
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -25
    max_value: 30
  # Register: 268, default: 7
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4H2"
    id: "${devicename}_t4h2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x10c
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -25
    max_value: 30
  # Register: 270 (Low, heating), default: 0.5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t_T4 FRESH_H"
    id: "${devicename}_t_t4_fresh_h"
    register_type: holding
    address: 0x10e
    value_type: U_WORD
    unit_of_measurement: hr
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 0.5
    max_value: 6.0
    step: 0.5
    mode: slider
    lambda: |-
      // Update the global var unmasked_value_register_270
      id(unmasked_value_register_270) = x;

      float value_floats[2];
      uint16_t value = x;

      // Extracting the high byte (Cooling) and storing it as a float
      value_floats[0] = (float)(value >> 8) * 0.5;

      // Extracting the low byte (Heating) and storing it as a float
      value_floats[1] = (float)(value & 0x00FF) * 0.5;

      // ESP_LOGI("","t_T4 FRESH_H is %f", value_floats[1]);
      // ESP_LOGI("","t_T4 FRESH_C is %f", value_floats[0]);

      return value_floats[1];
    write_lambda: |-
      uint16_t value = id(unmasked_value_register_270); // The original unmasked value
      float input = x * 2.0;                            // Multiply x (the input from the slider) by 2

      // Multiply the input from the slider (x) by by
      // and convert to uint8_t
      uint8_t input_byte = static_cast<uint8_t>(x * 2.0);

      value &= 0xFF00;      // Clear the lower byte of the value
      value |= input_byte;  // Update the lower byte with the new byte value

      ESP_LOGI("Register _t_t4_fresh_h", "Original value: %d, New value: %d", id(unmasked_curve_selection), value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x10e, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  # Register: 270 (High, cooling), default: 0.5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t_T4 FRESH_C"
    id: "${devicename}_t_t4_fresh_c"
    register_type: holding
    address: 0x10e
    value_type: U_WORD
    unit_of_measurement: hr
    icon: mdi:clock-check-outline
    entity_category: config
    min_value: 0.5
    max_value: 6.0
    step: 0.5
    mode: slider
    lambda: |-
      // Update the global var unmasked_value_register_270
      id(unmasked_value_register_270) = x;

      float value_floats[2];
      uint16_t value = x;

      // Extracting the high byte (Cooling) and storing it as a float
      value_floats[0] = (float)(value >> 8) * 0.5;

      // Extracting the low byte (Heating) and storing it as a float
      value_floats[1] = (float)(value & 0x00FF) * 0.5;

      return value_floats[1];
    write_lambda: |-
      uint16_t value = id(unmasked_value_register_270); // The original unmasked value
      float input = x * 2.0;                            // Multiply x (the input from the slider) by 2

      // Multiply the input from the slider (x) by by
      // and convert to uint8_t
      uint8_t input_byte = static_cast<uint8_t>(x * 2.0);

      value &= 0x00FF;             // Clear the upper byte of the value
      value |= (input_byte << 8);  // Update the upper byte with the new byte value

      ESP_LOGI("Register 10e _t_t4_fresh_c", "Original value: %d, New value: %d", id(unmasked_curve_selection), value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x10e, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  # Register: 271, default: 2
  # In modbus register this is called T_PUMPI_DELAY, in the menu this is called t_DELAY_PUMP
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Built-in Circulating Pump Delay"
    id: "${devicename}_t_delay_pump"
    icon: mdi:camera-timer
    register_type: holding
    address: 0x10f
    value_type: U_WORD
    unit_of_measurement: min
    multiply: 2.0
    entity_category: config
    min_value: 2.0
    max_value: 20.0
    step: 0.5
  ######################################## OUTSIDE IMPLEMENTATIONS ############################################      
  - platform: template
    name: "SM Restore DHW Heat after time"
    id: "${devicename}_restore_time_heat_dhw_after_turn_off"
    min_value: 0
    max_value: 1440
    step: 5
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 210
    on_value: 
      then:
        lambda: 'ESP_LOGI("Restore DHW Heat after time","Restore DHW Heat after time: %f min", x);'
  - platform: template
    name: "SM Restore Zone1 Heat/Cool after time"
    id: "${devicename}_restore_time_heat_zone1_after_turn_off"
    min_value: 0
    max_value: 1440
    step: 5
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 210
    on_value: 
      then:
        lambda: 'ESP_LOGI("Restore Zone1 Heat after time","Restore Zone1 Heat after time: %f min", x);'
  - platform: template
    name: "SM Restore Zone2 Heat after time"
    id: "${devicename}_restore_time_heat_zone2_after_turn_off"
    min_value: 0
    max_value: 1440
    step: 5
    unit_of_measurement: min
    icon: mdi:clock-check-outline
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 210
    on_value: 
      then:
        lambda: 'ESP_LOGI("Restore Zone2 Heat after time","Restore Zone2 Heat after time: %f min", x);'
  - platform: template  #activate antifreeze external pump under this temp T4 val if PUMP_I don't run for specific time
    name: "SM Antifreeze time temp treshold"
    id: "${devicename}_temp_secure_antifreeze"
    min_value: -1
    max_value: 30
    step: 1
    icon: mdi:temperature-celsius
    unit_of_measurement: "°C"
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 3
    on_value: 
      then:
        lambda: 'ESP_LOGI("SM Antifreeze time temp treshold","Actual value: %f °C", x);'
  - platform: template
    name: "SM Minimal DHW Temp Allow to drop"
    id: "${devicename}_gl_dhw_minimal_temp"
    min_value: 25
    max_value: 50
    step: 1
    icon: mdi:temperature-celsius
    unit_of_measurement: "°C"
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 32
    on_value: 
      then:
        lambda: 'ESP_LOGI("SM Minimal DHW Temp Allow to drop","Actual value: %f °C", x);'        
  - platform: template
    name: "SM Antifreeze protect between PUMP_I run"
    #pump_i_antifrize_check_last_run_interval: '(60*60)'  #interval to check if this time was pump_i not run to secure from antifreeze
    id: "${devicename}_pump_i_antifrize_check_last_run_interval"
    min_value: 1
    max_value: 120
    step: 1
    icon: mdi:clock
    unit_of_measurement: "min"
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 60
    on_value: 
      then:
        lambda: 'ESP_LOGI("SM Antifreeze protect between PUMP_I run","Actual value: %f min", x);'       

  - platform: template
    name: "SM Output External pump for antifreeze"
    #  output_external_pump_for_antifreeze_relay1: '(5 * 60)'         #time to run external pump for antifrize pipes after pump_i stopped for defined time pump_i_antifrize_check_last_run_interval
    id: "${devicename}_output_external_pump_for_antifreeze_relay1"
    min_value: 1
    max_value: 15
    step: 1
    icon: mdi:clock
    unit_of_measurement: "min"
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 5
    on_value: 
      then:
        lambda: 'ESP_LOGI("SM Output External pump for antifreeze","Actual value: %f min", x);'       
  - platform: template
    name: "SM Output External pump -spare"
    #  external_relay_timer: '(5 * 60)'         #time to run external pump for antifrize pipes after pump_i stopped for defined time pump_i_antifrize_check_last_run_interval
    id: "${devicename}_external_relay_timer"
    min_value: 1
    max_value: 15
    step: 1
    icon: mdi:clock
    unit_of_measurement: "min"
    entity_category: "config"
    optimistic: true
    restore_value: true
    initial_value: 5
    on_value: 
      then:
        lambda: 'ESP_LOGI("SM Output External pump for antifreeze -spare","Actual value: %f min", x);'                        
  
################################################################################################################################
text_sensor:
  - platform: version
    name: ESPHome Version
    hide_timestamp: true
    entity_category: "diagnostic"
    icon: mdi:information-variant-circle-outline
  - platform: template
    name: Uptime HR
    id: uptime_human
    icon: mdi:clock-start
    entity_category: "diagnostic"
  - platform: wifi_info
    ip_address:
      name: IP
      entity_category: "diagnostic"
      icon: mdi:ip-network
    ssid:
      name: SSID
      entity_category: "diagnostic"
      icon: mdi:wifi
    bssid:
      name: BSSID
      entity_category: "diagnostic"
      icon: mdi:wifi-alert
  # Active State
  - platform: template
    name: "Active State"
    id: "${devicename}_active_state"
    entity_category: "diagnostic"
    icon: mdi:power
    lambda: |-
      if (id(${devicename}_load_output_run).state) {
        // The heat pump is on
        if (id(${devicename}_status_bit_1_defrosting).state) {
          return {"Defrosting"};
        } else if (id(${devicename}_load_output_sv1).state) {
          return {"DHW"};
        } else if (id(${devicename}_status_bit_1_heating_mode_set_by_room_thermostat).state 
          || id(${devicename}_water_flow_temperature_control_zone_1).state) {
          return {"Heating"};
        } else if (id(${devicename}_status_bit_1_cooling_mode_set_by_room_thermostat).state
          || id(${devicename}_room_temperature_control).state
          || id(${devicename}_water_flow_temperature_control_zone_2).state) {
          return {"Cooling"};
        } else {
          return {"Unknown"};
        }
      } else {
        // The heat pump is off
        return {"Inactive"};
      }
  # Current fault mapped to error code
  - platform: template
    name: "Current Fault Error Code"
    id: "${devicename}_current_fault_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int current_fault = id(${devicename}_current_fault).state;

      // ESP_LOGI("main", "Current fault: %d", current_fault);

      if (current_fault >= 0 && current_fault <= 143) {
        return std::to_string(current_fault);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
        - 0 -> OK
        - 1 -> E0
        - 2 -> E1
        - 3 -> E2
        - 4 -> E3
        - 5 -> E4
        - 6 -> E5
        - 7 -> E6
        - 8 -> E7
        - 9 -> E8
        - 10 -> E9
        - 11 -> EA
        - 12 -> Eb
        - 13 -> Ec
        - 14 -> Ed
        - 15 -> EE
        - 20 -> P0
        - 21 -> P1
        - 23 -> P3
        - 24 -> P4
        - 25 -> P5
        - 26 -> P6
        - 31 -> Pb
        - 33 -> Pd
        - 38 -> PP
        - 39 -> H0
        - 40 -> H1
        - 41 -> H2
        - 42 -> H3
        - 43 -> H4
        - 44 -> H5
        - 45 -> H6
        - 46 -> H7
        - 47 -> H8
        - 48 -> H9
        - 49 -> HA
        - 50 -> Hb
        - 52 -> Hd
        - 53 -> HE
        - 54 -> HF
        - 55 -> HH
        - 57 -> HP
        - 65 -> C7
        - 112 -> bH
        - 116 -> F1
        - 134 -> L0
        - 135 -> L1
        - 136 -> L2
        - 138 -> L4
        - 139 -> L5
        - 141 -> L7
        - 142 -> L8
        - 143 -> L9
  # Current fault mapped to error code description
  - platform: template
    name: "Current Fault Error Code Description"
    id: "${devicename}_current_fault_error_code_description"
    icon: "mdi:alert-circle"
    lambda: |-
      int current_fault = id(${devicename}_current_fault).state;

      // ESP_LOGI("main", "Current fault: %d", current_fault);

      if (current_fault >= 0 && current_fault <= 143) {
        return std::to_string(current_fault);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
        - 0 -> OK
        - 1 -> Water flow fault(E8 displayed 3 times)
        - 2 -> Phase loss or neutral wire and live wire are connected reversely(only for three phase unit)
        - 3 -> Communication fault between controller and hydraulic module
        - 4 -> Final outlet water temp. sensor(T1) fault
        - 5 -> Water tank temp. sensor(T5) fault
        - 6 -> The condenser outlet refrigerant temperature sensor(T3) fault
        - 7 -> The ambient temperature sensor(T4) fault
        - 8 -> Buffer tank up temp. sensor(Tbt1) fault
        - 9 -> Water flow failure
        - 10 -> Suction temp. sensor (Th) fault
        - 11 -> Discharge temp. sensor (Tp) fault
        - 12 -> Solar temp. sensor(Tsolar) fault
        - 13 -> Buffer tank low temp. sensor(Tbt2) fault
        - 14 -> Inlet water temp. sensor(Tw_in) malfunction
        - 15 -> Hydraulic module EEprom failure
        - 20 -> Low pressure switch protection
        - 21 -> High pressure switch protection
        - 23 -> Compressor overcurrent protection
        - 24 -> High discharge temperature protection
        - 25 -> |Tw_out - Tw_in| value too big protection
        - 26 -> Inverter module protection
        - 31 -> Anti-freeze mode
        - 33 -> High temperature protection of refrigerant outlet temp. of condenser
        - 38 -> Tw_out - Tw_in unusual protection
        - 39 -> Communication fault between main board PCB B and main control board of hydraulic module
        - 40 -> Communication fault between inverter module PCB A and main control board PCB B
        - 41 -> Refrigerant liquid temp. sensor(T2) fault
        - 42 -> Refrigerant gas temp. sensor(T2B) fault
        - 43 -> Three times P6(L0/L1) protection
        - 44 -> Room temo. sensor (Ta) fault
        - 45 -> DC fan motor fault
        - 46 -> Voltage protection
        - 47 -> Pressure sensor fault
        - 48 -> Outlet water for zone 2 temp. sensor(Tw2) fault
        - 49 -> Outlet water temp. sensor(Tw_out) fault
        - 50 -> 3 times PP protection and Tw_out<7℃
        - 52 -> Communication fault between hydraulic module parallel
        - 53 -> Communication error between main board and thermostat transfer board
        - 54 -> Inverter module board EE PROM fault
        - 55 -> H6 display 10 times in 2 hours
        - 57 -> Low pressure protection (Pe<0.6) occurred 3 times in 1 hour
        - 65 -> Transducer module temperature too high protection
        - 112 -> PED PCB fault
        - 116 -> Low DC generatrix voltage protection
        - 134 -> Module protection
        - 135 -> DC generatrix low voltage protection
        - 136 -> DC generatrix high voltage protection
        - 138 -> MCE fault
        - 139 -> Zero speed protection
        - 141 -> Phase sequence fault
        - 142 -> Speed difference > 15Hz protection between the front and the back clock
        - 143 -> Speed difference > 15Hz protection between the real and the setting speed
  # Fault 1 mapped to error code
  - platform: template
    name: "Fault 1 Error Code"
    id: "${devicename}_fault_1_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_one = id(${devicename}_fault_1).state;

      if (fault_one >= 0 && fault_one <= 143) {
        return std::to_string(fault_one);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
        - 0 -> OK
        - 1 -> E0
        - 2 -> E1
        - 3 -> E2
        - 4 -> E3
        - 5 -> E4
        - 6 -> E5
        - 7 -> E6
        - 8 -> E7
        - 9 -> E8
        - 10 -> E9
        - 11 -> EA
        - 12 -> Eb
        - 13 -> Ec
        - 14 -> Ed
        - 15 -> EE
        - 20 -> P0
        - 21 -> P1
        - 23 -> P3
        - 24 -> P4
        - 25 -> P5
        - 26 -> P6
        - 31 -> Pb
        - 33 -> Pd
        - 38 -> PP
        - 39 -> H0
        - 40 -> H1
        - 41 -> H2
        - 42 -> H3
        - 43 -> H4
        - 44 -> H5
        - 45 -> H6
        - 46 -> H7
        - 47 -> H8
        - 48 -> H9
        - 49 -> HA
        - 50 -> Hb
        - 52 -> Hd
        - 53 -> HE
        - 54 -> HF
        - 55 -> HH
        - 57 -> HP
        - 65 -> C7
        - 112 -> bH
        - 116 -> F1
        - 134 -> L0
        - 135 -> L1
        - 136 -> L2
        - 138 -> L4
        - 139 -> L5
        - 141 -> L7
        - 142 -> L8
        - 143 -> L9
  # Fault 2 mapped to error code
  - platform: template
    name: "Fault 2 Error Code"
    id: "${devicename}_fault_2_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_two = id(${devicename}_fault_2).state;

      if (fault_two >= 0 && fault_two <= 143) {
        return std::to_string(fault_two);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
        - 0 -> OK
        - 1 -> E0
        - 2 -> E1
        - 3 -> E2
        - 4 -> E3
        - 5 -> E4
        - 6 -> E5
        - 7 -> E6
        - 8 -> E7
        - 9 -> E8
        - 10 -> E9
        - 11 -> EA
        - 12 -> Eb
        - 13 -> Ec
        - 14 -> Ed
        - 15 -> EE
        - 20 -> P0
        - 21 -> P1
        - 23 -> P3
        - 24 -> P4
        - 25 -> P5
        - 26 -> P6
        - 31 -> Pb
        - 33 -> Pd
        - 38 -> PP
        - 39 -> H0
        - 40 -> H1
        - 41 -> H2
        - 42 -> H3
        - 43 -> H4
        - 44 -> H5
        - 45 -> H6
        - 46 -> H7
        - 47 -> H8
        - 48 -> H9
        - 49 -> HA
        - 50 -> Hb
        - 52 -> Hd
        - 53 -> HE
        - 54 -> HF
        - 55 -> HH
        - 57 -> HP
        - 65 -> C7
        - 112 -> bH
        - 116 -> F1
        - 134 -> L0
        - 135 -> L1
        - 136 -> L2
        - 138 -> L4
        - 139 -> L5
        - 141 -> L7
        - 142 -> L8
        - 143 -> L9
  # Fault 3 mapped to error code
  - platform: template
    name: "Fault 3 Error Code"
    id: "${devicename}_fault_3_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_three = id(${devicename}_fault_3).state;

      if (fault_three >= 0 && fault_three <= 143) {
        return std::to_string(fault_three);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
        - 0 -> OK
        - 1 -> E0
        - 2 -> E1
        - 3 -> E2
        - 4 -> E3
        - 5 -> E4
        - 6 -> E5
        - 7 -> E6
        - 8 -> E7
        - 9 -> E8
        - 10 -> E9
        - 11 -> EA
        - 12 -> Eb
        - 13 -> Ec
        - 14 -> Ed
        - 15 -> EE
        - 20 -> P0
        - 21 -> P1
        - 23 -> P3
        - 24 -> P4
        - 25 -> P5
        - 26 -> P6
        - 31 -> Pb
        - 33 -> Pd
        - 38 -> PP
        - 39 -> H0
        - 40 -> H1
        - 41 -> H2
        - 42 -> H3
        - 43 -> H4
        - 44 -> H5
        - 45 -> H6
        - 46 -> H7
        - 47 -> H8
        - 48 -> H9
        - 49 -> HA
        - 50 -> Hb
        - 52 -> Hd
        - 53 -> HE
        - 54 -> HF
        - 55 -> HH
        - 57 -> HP
        - 65 -> C7
        - 112 -> bH
        - 116 -> F1
        - 134 -> L0
        - 135 -> L1
        - 136 -> L2
        - 138 -> L4
        - 139 -> L5
        - 141 -> L7
        - 142 -> L8
        - 143 -> L9
  # Register: 101
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Operating Mode"
    id: "${devicename}_operating_mode"
    register_type: holding
    address: 0x65
    response_size: 2
    icon: mdi:state-machine
    lambda: |-
        int idx = item->offset;
        uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
        std::string output = to_string(rawdata);
        ESP_LOGI("OPERATING MODE","Operating mode %d", rawdata);
        if (output == "0") output = "OFF";
        else if (output == "2") output = "Cooling";
        else if (output == "3") output = "CO Heating";
        else if (output == "5") output = "DHW Heating";
        return output;

# Register: 200 (High byte) ->moved to text_sensor
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Type"
    id: "${devicename}_home_appliance_type"
    register_type: holding
    address: 0xc8
    response_size: 2
    raw_encode: HEXBYTES
    icon: mdi:state-machine
    #value_type: U_WORD
    lambda: |-
         int idx = item->offset;
         std::string z = "";
         uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
         //ESP_LOGI("main", "The current version is 0x%x", rawdata);
         if ((rawdata >> 8) == 7) {
           z = "Air to water heat pump";
         } else {
           z = std::to_string(data[idx]);
         }
         return {z};
  # Register: 200 (Low byte, first 4 bits)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Sub Type"
    id: "${devicename}_home_appliance_sub_type"
    icon: "mdi:information-box-outline"
    register_type: holding
    address: 200
    response_size: 2
    raw_encode: HEXBYTES    
   # bitmask: 0xF000
    lambda: |-
         int idx = item->offset;
         std::string z = "";
         uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
         //ESP_LOGI("main", "The current version is 0x%x", rawdata);
         if (((rawdata & 0x0F) ) == 2) {
           z = "R32";
         } else {
           z = std::to_string(rawdata & 0x0F) ;
         }
         return {z};
  # Register: 200 (Low byte, second 4 bits)
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Product Code"
    id: "${devicename}_home_appliance_product_code"
    icon: "mdi:information-box-outline"
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES    
    address: 200
    #bitmask: 0x0F00
    lambda: |-
         int idx = item->offset;
         std::string z = "";
         uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
         ESP_LOGI("main", "The current version is 0x%x rawdata ", rawdata);
         if (((rawdata & 0x00F0) >> 4) == 4) {
           z = "4";
         } else {
           z = std::to_string((rawdata & 0x00F0) >> 4);
         }
         return {z};
  #########ADDED TIME PUMPS##############
  - platform: template
    name: "SM Recovery Heating DHW time at"
    id: ${devicename}_recovery_heating_dhw_time_at
    entity_category: "diagnostic"
    icon: mdi:clock
    update_interval: 15s
    lambda: |-
      time_t dur = id(manually_disabled_dhw_heating_timestamp) + (time_t)(id(${devicename}_restore_time_heat_dhw_after_turn_off).state * 60);// - (id(esptime).now().timestamp - id(manually_disabled_dhw_heating_timestamp));
      char time_str[30];
      if (dur > (id(${devicename}_restore_time_heat_dhw_after_turn_off).state * 60) and id(Restore_enable_DHW)) {
        time_t time_at = dur;
        strftime(time_str, sizeof(time_str), "%H:%M", localtime(&time_at));  //%Y-%m-%d 
      } else sprintf(time_str, "N/D");
      ESP_LOGI("text_sensor", "recovery_heating_dhw_time_at: %s Enable Recovery mode: %s", time_str, id(${devicename}_enable_recoverytime_enable_dhw).state?"Yes":"No");
      return {time_str};
    # web_server_sorting_weight: -190   
  - platform: template
    name: "SM Recovery Heating/Cooling Zone1 time at"
    id: ${devicename}_recovery_heating_cooling_zone1_time_at
    entity_category: "diagnostic"
    icon: mdi:clock
    update_interval: 15s
    lambda: |-
      time_t dur = id(manually_disabled_zone1_heating_timestamp) + (time_t)(id(${devicename}_restore_time_heat_zone1_after_turn_off).state*60); 
      char time_str[30];
      if (dur > (id(${devicename}_restore_time_heat_zone1_after_turn_off).state * 60) and id(Restore_enable_Zone1)) {
        time_t time_at = dur;
        strftime(time_str, sizeof(time_str), "%H:%M", localtime(&time_at));  //%Y-%m-%d 
      } else sprintf(time_str, "N/D");
      ESP_LOGI("text_sensor", "recovery_heating_cooling_zone1_time_at: %s Enable Recovery mode: %s", time_str, id(${devicename}_enable_recoverytime_enable_zone1).state?"Yes":"No");
      return {time_str};
    # web_server_sorting_weight: -190   
  - platform: template
    name: "SM Recovery Heating/Cooling Zone2 time at"
    id: ${devicename}_recovery_heating_cooling_zone2_time_at
    entity_category: "diagnostic"
    icon: mdi:clock
    update_interval: 15s
    lambda: |-
      time_t dur = id(manually_disabled_zone2_heating_timestamp) + (time_t)(id(${devicename}_restore_time_heat_zone2_after_turn_off).state * 60);
      char time_str[30];
      if (dur > (id(${devicename}_restore_time_heat_zone2_after_turn_off).state * 60) and id(Restore_enable_Zone2)) {
        time_t time_at = dur;
        strftime(time_str, sizeof(time_str), "%H:%M", localtime(&time_at));  //%Y-%m-%d 
      } else sprintf(time_str, "N/D");
      ESP_LOGI("text_sensor", "recovery_heating_cooling_zone2_time_at: %s Enable Recovery mode: %s", time_str, id(${devicename}_enable_recoverytime_enable_zone2).state?"Yes":"No");
      return {time_str};    
  - platform: template
    name: "SM Last time PUMP_I Run At"
    id: ${devicename}_water_pump_i_runtime_at
    entity_category: "diagnostic"
    icon: mdi:clock
    update_interval: 15s
    lambda: |-
      time_t dur = id(timestamp_water_pump_timestamp_last_run);
      char time_str[30];
      if (dur > 0) {
        time_t time_at = dur;
        strftime(time_str, sizeof(time_str), "%H:%M", localtime(&time_at));  //%Y-%m-%d 
      } else sprintf(time_str, "N/D");
      ESP_LOGI("text_sensor", "water_pump_i_runtime_at: %s", time_str);
      return {time_str};
