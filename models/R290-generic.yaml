substitutions:
  devicename: heatpump
  description: Heatpump Controller

globals:
  - id: unmasked_value_register_0
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_5
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_water_temperature_t1s
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_curve_selection
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_210
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_211
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_270
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_272
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_273
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_274
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_277
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: unmasked_value_register_278
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: compressor_start_count
    type: int
    restore_value: no
    initial_value: '0'

esphome:
  name: "${devicename}"
  comment: "${description}"
  friendly_name: "${description}"
  project:
    name: "${devicename}.${description}"
    version: 8.0.0

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO
  baud_rate: 0

# Enable Home Assistant API
api:

web_server:
  port: 80
  version: 3

ota:
  platform: esphome

wifi:
  power_save_mode: none
  ap:
    ssid: "${devicename}-setup"
    password: "heatpump"

captive_portal:

uart:
  id: mod_bus
  tx_pin: 17
  rx_pin: 16
  baud_rate: 9600
  stop_bits: 1

modbus:
  flow_control_pin: 5
  id: heatpump_modbus

modbus_controller:
  - id: "${devicename}"
    address: 0x1
    modbus_id: heatpump_modbus
    setup_priority: -10
    update_interval: 10s

select:
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Operational Mode"
    id: "${devicename}_operational_mode"
    icon: "mdi:fan"
    address: 0x1
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Heat": 3
      "Cool": 2
      "Auto": 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Input Limitation Type"
    id: "${devicename}_power_input_limitation_type"
    icon: mdi:state-machine
    address: 0x10d
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "None": 0
      "1": 1
      "2": 2
      "3": 3
      "4": 4
      "5": 5
      "6": 6
      "7": 7
      "8": 8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 1 End Heating Mode Emission Type"
    id: "${devicename}_zone_1_end_heating_mode_emission_type"
    icon: mdi:heat-wave
    address: 0x110
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Underfloor Heating": 0
      "Fan Coil Unit": 1
      "Radiator": 2
    lambda: |-
      // Update the global var unmasked_value_register_272
      id(unmasked_value_register_272) = x;

      // ESP_LOGI("Register 272","unmasked_value_register_272: %d",id(unmasked_value_register_272));

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      // ESP_LOGI("Register 272","zone1_h_emission is %d"zone2_h_emission);
      std::string string_result;
      if (zone1_h_emission == 0) {
        string_result = "Underfloor Heating";
      } else if (zone1_h_emission == 1) {
        string_result = "Fan Coil Unit";
      } else if (zone1_h_emission == 2) {
        string_result = "Radiator";
      } else {
        string_result = "Unknown: ";
        string_result += std::to_string(zone1_h_emission);
      }
      return string_result;
    write_lambda: |-
      // ESP_LOGD("Register 272", "zone1_h_emission Set option to %s (%lld)", x.c_str(), value);
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte = value;                            // New byte value with the heating emission type for zone 1
      new_value &= 0xFFF0;     // Clear the first 4 bits
      new_value |= value_byte; // Set the first 4 bits with the new value
      // ESP_LOGD("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272), new_value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 End Heating Mode Emission Type"
    id: "${devicename}_zone_2_end_heating_mode_emission_type"
    icon: mdi:heat-wave
    address: 0x110
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Underfloor Heating": 0
      "Fan Coil Unit": 1
      "Radiator": 2
    lambda: |-
      // Updating the global var unmasked_value_register_272 is already done
      // in the first part of this register
      // ESP_LOGD("","unmasked_value_register_272: %d",id(unmasked_value_register_272));

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      // ESP_LOGD("Register 272","zone2_h_emission is %d", zone2_h_emission);
      std::string string_result;
      if (zone2_h_emission == 0) {
        string_result = "Underfloor Heating";
      } else if (zone2_h_emission == 1) {
        string_result = "Fan Coil Unit";
      } else if (zone2_h_emission == 2) {
        string_result = "Radiator";
      } else {
        string_result = "Unknown: ";
        string_result += std::to_string(zone2_h_emission);
      }
      return string_result;
    write_lambda: |-
      // ESP_LOGD("Register 272", "zone2_h_emission Set option to %s (%lld)", x.c_str(), value);
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte = value;                            // New byte value with the heating emission type for zone 2
      new_value &= 0xFF0F;             // Clear the second pair of 4 bits
      new_value |= (value_byte << 4);  // Set the second pair of 4 bits with the new value
      // ESP_LOGI("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272), new_value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 1 End Cooling Mode Emission Type"
    id: "${devicename}_zone_1_end_cooling_mode_emission_type"
    icon: mdi:heat-wave
    address: 0x110
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Underfloor Heating": 0
      "Fan Coil Unit": 1
      "Radiator": 2
    lambda: |-
      // Updating the global var unmasked_value_register_272 is already done
      // in the first part of this register
      // ESP_LOGI("","unmasked_value_register_272: %d",id(unmasked_value_register_272));

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      // ESP_LOGD("Register 272","zone1_c_emission is %d", zone1_c_emission);
      std::string string_result;
      if (zone1_c_emission == 0) {
        string_result = "Underfloor Heating";
      } else if (zone1_c_emission == 1) {
        string_result = "Fan Coil Unit";
      } else if (zone1_c_emission == 2) {
        string_result = "Radiator";
      } else {
        string_result = "Unknown: ";
        string_result += std::to_string(zone1_c_emission);
      }
      return string_result;
    write_lambda: |-
      // ESP_LOGI("Register 272", "zone1_c_emission Set option to %s (%lld)", x.c_str(), value);
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte = value;                            // New byte value with the cooling emission type for zone 1
      new_value &= 0xF0FF;             // Clear the third pair of 4 bits
      new_value |= (value_byte << 8);  // Set the third pair of 4 bits with the new value
      // ESP_LOGI("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272), new_value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 End Cooling Mode Emission Type"
    id: "${devicename}_zone_2_end_cooling_mode_emission_type"
    icon: mdi:heat-wave
    address: 0x110
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "Underfloor Heating": 0
      "Fan Coil Unit": 1
      "Radiator": 2
    lambda: |-
      // Updating the global var unmasked_value_register_272 is already done
      // in the first part of this register
      // ESP_LOGI("Register 272","unmasked_value_register_272: 0x%x", id(unmasked_value_register_272);

      // Extracting 4-bit values
      uint8_t zone2_c_emission = (x >> 12) & 0xF;
      uint8_t zone1_c_emission = (x >> 8) & 0xF;
      uint8_t zone2_h_emission = (x >> 4) & 0xF;
      uint8_t zone1_h_emission = x & 0xF;

      // ESP_LOGI("Register 272","zone2_c_emission is %d", zone2_c_emission);
      std::string string_result;
      if (zone2_c_emission == 0) {
        string_result = "Underfloor Heating";
      } else if (zone2_c_emission == 1) {
        string_result = "Fan Coil Unit";
      } else if (zone2_c_emission == 2) {
        string_result = "Radiator";
      } else {
        string_result = "Unknown: ";
        string_result += std::to_string(zone2_c_emission);
      }
      return string_result;
    write_lambda: |-
      // ESP_LOGI("Register 272", "zone2_c_emission Set option to %s (%lld)", x.c_str(), value);
      uint16_t new_value = id(unmasked_value_register_272);  // The original unmasked value
      uint8_t value_byte = value;                            // New byte value with the cooling emission type for zone 2
      new_value &= 0x0FFF;              // Clear the fourth pair of 4 bits
      new_value |= (value_byte << 12);  // Set the fourth pair of 4 bits with the new value
      // ESP_LOGI("Register 272", "Original value: %d -> New value: %d", id(unmasked_value_register_272), new_value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x110, new_value);
      ${devicename}->queue_command(set_payload_command);
      return {};

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Solar Function Mode"
    id: "${devicename}_solar_function_mode"
    icon: mdi:solar-power-variant
    address: 0x111
    value_type: U_WORD
    optimistic: true
    optionsmap:
      "No Function": 0
      "Solar + Heat Pump": 1
      "Only Solar": 2
    lambda: |-
      // Update the global var unmasked_value_register_273
      id(unmasked_value_register_273) = x;

      // Extract bits 0-7 for Solar Function (the lower byte (8 bits))
      uint8_t solar_func_value = x & 0xFF;

      // Return the string that matches the optionsmap
      switch (solar_func_value) {
        case 1:
          return std::string("Solar + Heat Pump");
        case 2:
          return std::string("Only Solar");
        case 0:
        default:
          return std::string("No Function");
      }
    write_lambda: |-
      // 'value' is the numeric value from the selected option (example: 0, 1, or 2)
      uint16_t current_reg_val = id(unmasked_value_register_273); // Original register value
      uint8_t new_solar_func_byte = (uint8_t)value;

      uint16_t new_value = (current_reg_val & 0xFF00); // Clear bits 0-7 (Solar Function deel)
      new_value |= new_solar_func_byte;                // Set bits 0-7 to the new value

      esphome::modbus_controller::ModbusCommandItem set_payload_command =
        esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
          ${devicename},
          273,
          new_value
        );
      ${devicename}->queue_command(set_payload_command);
      return {};
sensor:
  - platform: template
    name: "Compressor Starts Per Hour"
    id: compressor_starts_per_hour
    unit_of_measurement: "starts/h"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      return id(compressor_start_count);

  - platform: uptime
    name: Uptime
    id: "${devicename}_uptime"
    icon: mdi:timelapse
  - platform: template
    name: "Coefficient of Performance"
    id: "${devicename}_coefficient_of_performance"
    icon: mdi:copyleft
    accuracy_decimals: 2
    unit_of_measurement: "COP"
    lambda: |-
      // Verify that electricity_consumption is <> 0 to avoid division by 0 error
      if (id(${devicename}_electricity_consumption).state != 0) {
        return id(${devicename}_power_output).state / id(${devicename}_electricity_consumption).state;
      } else return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 0 switches"
    id: "${devicename}_register_0_switches"
    internal: true
    register_type: holding
    address: 0x0
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_0
      id(unmasked_value_register_0) = x;
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Register 5 switches"
    id: "${devicename}_register_5_switches"
    internal: true
    register_type: holding
    address: 0x5
    value_type: U_WORD
    icon: mdi:eye
    lambda: |-
      // Update the global var unmasked_value_register_5
      id(unmasked_value_register_5) = x;
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Forced Hydraulic Module Rear Electric Heater 1"
    id: "${devicename}_forced_hydraulic_module_rear_electric_heater_1"
    icon: mdi:fire-alert
    register_type: holding
    address: 0x9
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t_SG_MAX"
    id: "${devicename}_t_sg_max"
    icon: mdi:clock
    register_type: holding
    address: 0xa
    value_type: U_WORD
    unit_of_measurement: hr

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Operating Frequency"
    id: "${devicename}_compressor_operating_frequency"
    icon: mdi:sine-wave
    register_type: holding
    address: 0x64
    value_type: U_WORD
    unit_of_measurement: Hz
    device_class: "frequency"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fan Speed"
    id: "${devicename}_fan_speed"
    icon: mdi:fan
    register_type: holding
    address: 0x66
    unit_of_measurement: "r/min"
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "PMV Openness"
    id: "${devicename}_pmv_openness"
    icon: mdi:valve
    register_type: holding
    address: 0x67
    value_type: U_WORD
    unit_of_measurement: "%"
    filters:
      - calibrate_linear:
          - 0 -> 0.0
          - 480 -> 100.0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Inlet Temperature"
    id: "${devicename}_water_inlet_temperature"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x68
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Outlet Temperature"
    id: "${devicename}_water_outlet_temperature"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x69
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Condenser Temperature T3"
    id: "${devicename}_condenser_temperature_t3"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x6a
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Ambient Temperature"
    id: "${devicename}_outdoor_ambient_temperature"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x6B
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    value_type: S_WORD
    filters:
      - lambda: |-
          if (x < -100 || x > 100) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Discharge Temperature"
    id: "${devicename}_discharge_temperature"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x6c
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Return Air Temperature"
    id: "${devicename}_return_air_temperature"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x6d
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total Water Outlet Temperature T1"
    id: "${devicename}_total_water_outlet_temperature_t1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x6e
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "System Total Water Outlet Temperature T1B"
    id: "${devicename}_system_total_water_outlet_temperature_t1b"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x6f
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Refrigerant Liquid Side Temperature T2"
    id: "${devicename}_refrigerant_liquid_side_temperature_t2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x70
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Refrigerant Gas Side Temperature T2B"
    id: "${devicename}_refrigerant_gas_side_temperature_t2b"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x71
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Room Temperature Ta"
    id: "${devicename}_room_temperature_ta"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x72
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -100 || x > 100) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Tank Temperature T5"
    id: "${devicename}_water_tank_temperature_t5"
    icon: mdi:thermometer-water
    register_type: holding
    address: 0x73
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    value_type: S_WORD
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit High Pressure"
    id: "${devicename}_outdoor_unit_high_pressure"
    icon: mdi:car-brake-worn-linings
    register_type: holding
    address: 0x74
    value_type: U_WORD
    unit_of_measurement: kPa
    device_class: "pressure"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -10000 || x > 10000) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Low Pressure"
    id: "${devicename}_outdoor_unit_low_pressure"
    icon: mdi:car-brake-low-pressure
    register_type: holding
    address: 0x75
    value_type: U_WORD
    unit_of_measurement: kPa
    device_class: "pressure"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -10000 || x > 10000) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Current"
    id: "${devicename}_outdoor_unit_current"
    icon: mdi:alpha-a
    register_type: holding
    address: 0x76
    value_type: U_WORD
    unit_of_measurement: A
    device_class: "current"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < 0 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Outdoor Unit Voltage"
    id: "${devicename}_outdoor_unit_voltage"
    icon: mdi:alpha-v
    register_type: holding
    address: 0x77
    value_type: U_WORD
    unit_of_measurement: V
    device_class: "voltage"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < 0 || x > 10000) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Tbt1"
    id: "${devicename}_tbt1"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    register_type: holding
    address: 0x78
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Tbt2"
    id: "${devicename}_tbt2"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    register_type: holding
    address: 0x79
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Operation Time"
    id: "${devicename}_compressor_operation_time"
    icon: mdi:av-timer
    register_type: holding
    address: 0x7a
    value_type: U_WORD
    unit_of_measurement: hr
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Unit Capacity"
    id: "${devicename}_unit_capacity"
    icon: mdi:lightning-bolt-circle
    register_type: holding
    address: 0x7b
    value_type: U_WORD
    unit_of_measurement: "kWh"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Current Fault"
    id: "${devicename}_current_fault"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7c
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 1"
    id: "${devicename}_fault_1"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7d
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 2"
    id: "${devicename}_fault_2"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7e
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fault 3"
    id: "${devicename}_fault_3"
    icon: mdi:alert-circle
    register_type: holding
    entity_category: diagnostic
    address: 0x7f
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Software Version"
    id: "${devicename}_software_version"
    icon: mdi:information
    register_type: holding
    address: 0x82
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Wired Controller Version Number"
    id: "${devicename}_wired_controller_version_number"
    icon: mdi:information
    register_type: holding
    address: 0x83
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Compressor Target Frequency"
    id: "${devicename}_compressor_target_frequency"
    icon: mdi:sine-wave
    register_type: holding
    address: 0x84
    value_type: U_WORD
    unit_of_measurement: Hz
    device_class: "frequency"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DC Bus Current"
    id: "${devicename}_dc_bus_current"
    icon: mdi:alpha-a
    register_type: holding
    address: 0x85
    value_type: U_WORD
    unit_of_measurement: A
    device_class: "current"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DC Bus Voltage"
    id: "${devicename}_dc_bus_voltage"
    icon: mdi:alpha-v
    register_type: holding
    address: 0x86
    value_type: U_WORD
    unit_of_measurement: V
    device_class: "voltage"
    state_class: "measurement"
    filters:
      - multiply: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "TF module temperature"
    id: "${devicename}_tf_module_temperature"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x87
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    value_type: S_WORD
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Climate Curve T1S Calculated Value 1"
    id: "${devicename}_climate_curve_t1s_calculated_value_1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x88
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Climate Curve T1S Calculated Value 2"
    id: "${devicename}_climate_curve_t1s_calculated_value_2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x89
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - lambda: |-
          if (x < -200 || x > 200) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Flow"
    id: "${devicename}_water_flow"
    icon: mdi:waves-arrow-right
    register_type: holding
    address: 0x8a
    value_type: U_WORD
    unit_of_measurement: m3/H
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Limit Scheme Of Outdoor Unit Current"
    id: "${devicename}_limit_scheme_of_outdoor_unit_current"
    icon: mdi:eye
    register_type: holding
    address: 0x8b
    value_type: U_WORD
    unit_of_measurement: "kW"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ability Of Hydraulic Module"
    id: "${devicename}_ability_of_hydraulic_module"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0x8c
    value_type: U_WORD
    unit_of_measurement: kW
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Tsolar"
    id: "${devicename}_tsolar"
    icon: mdi:thermometer
    register_type: holding
    address: 0x8d
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Electricity Consumption"
    id: "${devicename}_electricity_consumption"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x8f
    value_type: U_DWORD
    filters:
      - lambda: return x * 0.01;
    accuracy_decimals: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Output"
    id: "${devicename}_power_output"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x91
    value_type: U_DWORD

    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x > 6000000) return {};
          return x;
    accuracy_decimals: 2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Cooling Zone 1"
    id: "${devicename}_temperature_upper_limit_of_t1s_cooling_zone_1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xc9
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0x00FF
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Cooling Zone 2"
    id: "${devicename}_temperature_upper_limit_of_t1s_cooling_zone_2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xc9
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0xFF00
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Cooling Zone 1"
    id: "${devicename}_temperature_lower_limit_of_t1s_cooling_zone_1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xca
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0x00FF
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Cooling Zone 2"
    id: "${devicename}_temperature_lower_limit_of_t1s_cooling_zone_2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xca
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0xFF00
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Heating Zone 1"
    id: "${devicename}_temperature_upper_limit_of_t1s_heating_zone_1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xcb
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0x00FF
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of T1S Heating Zone 2"
    id: "${devicename}_temperature_upper_limit_of_t1s_heating_zone_2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xcb
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0xFF00
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Heating Zone 1"
    id: "${devicename}_temperature_lower_limit_of_t1s_heating_zone_1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xcc
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0x00FF
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of T1S Heating Zone 2"
    id: "${devicename}_temperature_lower_limit_of_t1s_heating_zone_2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xcc
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    bitmask: 0xFF00
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of TS Setting"
    id: "${devicename}_temperature_upper_limit_of_ts_setting"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xcd
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - multiply: 0.5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of TS Setting"
    id: "${devicename}_temperature_lower_limit_of_ts_setting"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xce
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    filters:
      - multiply: 0.5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Upper Limit Of water Heating"
    id: "${devicename}_temperature_upper_limit_of_water_heating"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xcf
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Lower Limit Of Water Heating"
    id: "${devicename}_temperature_lower_limit_of_water_heating"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd0
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Parameter Settings 1"
    id: "${devicename}_parameter_settings_1"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 210
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_210
      id(unmasked_value_register_210) = x;
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Parameter Settings 2"
    id: "${devicename}_parameter_settings_2"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 211
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_211
      id(unmasked_value_register_211) = x;
      return x;
  - platform: template
    name: "T1S DHW"
    id: "${devicename}_t1s_dhw"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    lambda: |-
      int dt1s5 = id(${devicename}_dt1s5).state;
      int t5 = id(${devicename}_water_tank_temperature_t5).state;
      int t1s_dhw = t5 + dt1s5;
      if (t1s_dhw < -200 || t1s_dhw > 200) return {};
      return t1s_dhw;

  - platform: template
    name: "Water Temperature Delta"
    id: "${devicename}_water_temperature_delta"
    icon: mdi:thermometer
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    lambda: |-
      int inlet = id(${devicename}_water_inlet_temperature).state;
      int outlet = id(${devicename}_water_outlet_temperature).state;
      int delta = outlet - inlet;
      if (delta < -200 || delta > 200) return {};
      return delta;

  - platform: template
    name: "Active State Map"
    id: "${devicename}_active_state_map"
    unit_of_measurement: ""
    accuracy_decimals: 0  # No decimals, value will show as integer
    lambda: |-
      static const std::map<std::string, int> status_map = {
        {"Inactive", 0},
        {"Heating", 1},
        {"Cooling", 2},
        {"DHW", 3},
        {"Defrosting", 4},
        {"Idle", 5}
      };

      auto state_item = status_map.find(id(${devicename}_active_state).state);
      if (state_item != status_map.end()) {
        return state_item->second; // Return integer value that matches the string value (Heating, Cooling, etc..)
      } else {
        return 99; // No mapping found
      }

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time heating Capacity"
    id: "${devicename}_realtime_heating_capacity"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0x94
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time renewable heating capacity"
    id: "${devicename}_realtime_renewable_heating_capacity"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0x95
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x < 0 || x > 50) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time heating power consumption"
    id: "${devicename}_realtime_heating_power_consumption"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0x96
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time heating COP"
    id: "${devicename}_realtime_heating_cop"
    icon: mdi:copyleft
    register_type: holding
    address: 0x97
    value_type: U_WORD
    unit_of_measurement: "COP"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x > 50) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total heating energy produced for system"
    id: "${devicename}_total_heating_energy_produced_for_system"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x98
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total heating renewable energy produced for system"
    id: "${devicename}_total_renewable_heating_energy_produced_for_system"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x9A
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total heating power consumed for system"
    id: "${devicename}_total_heating_power_consumed_for_system"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x9C
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total heating power produced for master unit"
    id: "${devicename}_total_heating_power_produced_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0x9E
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total renewable heating power produced for master unit"
    id: "${devicename}_total_renewable_heating_energy_produced_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xA0
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total heating power consumed for master unit"
    id: "${devicename}_total_heating_power_consumed_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xA2
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total COP in heating mode for master unit"
    id: "${devicename}_total_cop_in_heating_mode_for_master_unit"
    icon: mdi:copyleft
    register_type: holding
    address: 0xA4
    unit_of_measurement: "COP"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total cooling energy produced for master unit"
    id: "${devicename}_total_cooling_energy_produced_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xA5
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total cooling renewable energy produced for master unit"
    id: "${devicename}_total_cooling_renewable_energy_produced_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xA7
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total cooling power consumed for master unit"
    id: "${devicename}_total_cooling_power_consumed_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xA9
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total COP in cooling mode for master unit"
    id: "${devicename}_total_cop_in_cooling_mode_for_master_unit"
    icon: mdi:copyleft
    register_type: holding
    address: 0xAB
    unit_of_measurement: "COP"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total DHW energy produced for master unit"
    id: "${devicename}_total_dhw_energy_produced_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xAC
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total DHW renewable energy produced for master unit"
    id: "${devicename}_total_dhw_renewable_energy_produced_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xAE
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total DHW power consumed for master unit"
    id: "${devicename}_total_dhw_power_consumed_for_master_unit"
    icon: mdi:lightning-bolt-outline
    register_type: holding
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    address: 0xB0
    value_type: U_DWORD
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Total COP in DHW mode for master unit"
    id: "${devicename}_total_cop_in_dhw_mode_for_master_unit"
    icon: mdi:copyleft
    register_type: holding
    address: 0xB2
    unit_of_measurement: "COP"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time renewable cooling capacity"
    id: "${devicename}_realtime_renewable_cooling_capacity"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0xB3
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x < 0 || x > 50) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time cooling capacity"
    id: "${devicename}_realtime_cooling_capacity"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0xB4
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time cooling power consumption"
    id: "${devicename}_realtime_cooling_power_consumption"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0xB5
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time cooling EER"
    id: "${devicename}_realtime_cooling_eer"
    icon: mdi:copyleft
    register_type: holding
    address: 0xB6
    value_type: U_WORD
    unit_of_measurement: "COP"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x > 50) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time DHW heating capacity"
    id: "${devicename}_realtime_dhw_heating_capacity"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0xB7
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time renewable DHW heating capacity"
    id: "${devicename}_realtime_renewable_dhw_heating_capacity"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0xB8
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x < 0 || x > 50) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time DHW heating power consumption"
    id: "${devicename}_realtime_dhw_heating_power_consumption"
    icon: mdi:lightning-bolt
    register_type: holding
    address: 0xB9
    value_type: U_WORD
    unit_of_measurement: "kW"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x < 0 || x > 30) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Real-time DHW heating COP"
    id: "${devicename}_realtime_dhw_heating_cop"
    icon: mdi:copyleft
    register_type: holding
    address: 0xBA
    value_type: U_WORD
    unit_of_measurement: "COP"
    accuracy_decimals: 2
    filters:
      - lambda: return x * 0.01;
      - lambda: |-
          if (x > 50) return {};
          return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "TL Outdoor Refrigerant Pipe Temperature"
    id: "${devicename}_tl_outdoor_refrigerant_pipe_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0xBF
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Pump Internal PWM"
    id: "${devicename}_pump_internal_pwm"
    icon: mdi:pump
    register_type: holding
    address: 0xC0
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 1
    filters:
      - lambda: return x * 0.1;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T9i Second PHE Inlet Temperature"
    id: "${devicename}_t9i_second_phe_inlet_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0xC1
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    filters:
      - lambda: |-
          if (x == 0x7fff) return {};
          return x * 0.1;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T9o Second PHE Outlet Temperature"
    id: "${devicename}_t9o_second_phe_outlet_temperature"
    icon: mdi:thermometer
    register_type: holding
    address: 0xC2
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    filters:
      - lambda: |-
          if (x == 0x7fff) return {};
          return x * 0.1;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "EXV2 Expansion Valve Openness"
    id: "${devicename}_exv2_expansion_valve_openness"
    icon: mdi:valve
    register_type: holding
    address: 0xC3
    value_type: U_WORD
    unit_of_measurement: "P"
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "EXV3 Expansion Valve Openness"
    id: "${devicename}_exv3_expansion_valve_openness"
    icon: mdi:valve
    register_type: holding
    address: 0xC4
    value_type: U_WORD
    unit_of_measurement: "P"
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Fan2 Speed"
    id: "${devicename}_fan2_speed"
    icon: mdi:fan
    register_type: holding
    address: 0xC5
    value_type: U_WORD
    unit_of_measurement: "r/min"
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "register_273"
    id: "${devicename}_register_273"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 0x111
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_273
      id(unmasked_value_register_273) = x;
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "register_274"
    id: "${devicename}_register_274"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 0x112
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_274
      id(unmasked_value_register_274) = x;
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "register_277"
    id: "${devicename}_register_277"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 0x115
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_277
      id(unmasked_value_register_277) = x;
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "register_278"
    id: "${devicename}_register_278"
    icon: mdi:state-machine
    internal: true
    register_type: holding
    address: 0x116
    value_type: U_WORD
    lambda: |-
      // Update the global var unmasked_value_register_278
      id(unmasked_value_register_278) = x;
      return x;
binary_sensor:
  - platform: template
    name: "Compressor Running"
    id: compressor_running
    device_class: running
    lambda: |-
      return id(${devicename}_compressor_operating_frequency).state > 0;

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 4"
    id: "${devicename}_power_reserved_bit_4"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 5"
    id: "${devicename}_power_reserved_bit_5"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x20
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 6"
    id: "${devicename}_power_reserved_bit_6"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x40
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 7"
    id: "${devicename}_power_reserved_bit_7"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x80
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 8"
    id: "${devicename}_power_reserved_bit_8"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x100
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 9"
    id: "${devicename}_power_reserved_bit_9"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x200
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 10"
    id: "${devicename}_power_reserved_bit_10"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x400
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 11"
    id: "${devicename}_power_reserved_bit_11"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x800
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 12"
    id: "${devicename}_power_reserved_bit_12"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x1000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 13"
    id: "${devicename}_power_reserved_bit_13"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x2000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 14"
    id: "${devicename}_power_reserved_bit_14"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x4000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Power Reserved BIT 15"
    id: "${devicename}_power_reserved_bit_15"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x0
    bitmask: 0x8000

  - platform: template
    name: "Function Setting Reserved BIT 0"
    id: "${devicename}_function_setting_reserved_bit_0"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x01) == 0x01; // Return status bit1"
  - platform: template
    name: "Function Setting Reserved BIT 1"
    id: "${devicename}_function_setting_reserved_bit_1"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x02) == 0x02; // Return status bit1"
  - platform: template
    name: "Function Setting Reserved BIT 2"
    id: "${devicename}_function_setting_reserved_bit_2"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x04) == 0x04; // Return status bit2"
  - platform: template
    name: "Function Setting Reserved BIT 3"
    id: "${devicename}_function_setting_reserved_bit_3"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x08) == 0x08; // Return status bit3"
  - platform: template
    name: "Function Setting Holiday Away"
    id: "${devicename}_function_setting_holiday_away"
    icon: mdi:eye
    lambda: "return (id(unmasked_value_register_5) & 0x20) == 0x20; // Return status bit5"
  - platform: template
    name: "Function Setting Reserved BIT 9"
    id: "${devicename}_function_setting_reserved_bit_9"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x200) == 0x200; // Return status bit9"
  - platform: template
    name: "Function Setting Reserved BIT 14"
    id: "${devicename}_function_setting_reserved_bit_14"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x4000) == 0x4000; // Return status bit14"
  - platform: template
    name: "Function Setting Reserved BIT 15"
    id: "${devicename}_function_setting_reserved_bit_15"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_5) & 0x8000) == 0x8000; // Return status bit15"

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Reserved BIT 0"
    id: "${devicename}_status_bit_1_reserved_bit_0"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x80
    bitmask: 0x1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Defrosting"
    id: "${devicename}_status_bit_1_defrosting"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Anti Freezing"
    id: "${devicename}_status_bit_1_anti_freezing"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Oil Return"
    id: "${devicename}_status_bit_1_oil_return"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Remote On/Off"
    id: "${devicename}_status_bit_1_remote_on_off"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Outdoor Unit Test Mode Mark"
    id: "${devicename}_status_bit_1_outdoor_unit_test_mode_mark"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x20
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Heating Mode Set By Room Thermostat"
    id: "${devicename}_status_bit_1_heating_mode_set_by_room_thermostat"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x40
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Cooling Mode Set By Room Thermostat"
    id: "${devicename}_status_bit_1_cooling_mode_set_by_room_thermostat"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x80
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Solar Energy Signal Input"
    id: "${devicename}_status_bit_1_solar_energy_signal_input"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x100
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Anti Freezing Operation For Water Tank"
    id: "${devicename}_status_bit_1_anti_freezing_operation_for_water_tank"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x200
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 SG"
    id: "${devicename}_status_bit_1_sg"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x400
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 EUV"
    id: "${devicename}_status_bit_1_euv"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x800
  - platform: modbus_controller
    name: "Status BIT 1 Reserved BIT 12"
    modbus_controller_id: "${devicename}"
    id: "${devicename}_status_bit_1_reserved_bit_12"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x80
    bitmask: 0x1000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Request Serial Number Code"
    id: "${devicename}_status_bit_1_request_serial_number_code"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x2000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Request Software Version"
    id: "${devicename}_status_bit_1_request_software_version"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x4000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status BIT 1 Request Operation Parameter"
    id: "${devicename}_status_bit_1_request_operation_parameter"
    icon: mdi:eye
    register_type: holding
    address: 0x80
    bitmask: 0x8000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Electric Heater IBH 1"
    id: "${devicename}_load_output_electric_heater_ibh1"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Electric Heater IBH 2"
    id: "${devicename}_load_output_electric_heater_ibh2"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x81
    bitmask: 0x2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Electric Heater TBH"
    id: "${devicename}_load_output_electric_heater_tbh"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Internal Circulation Pump PUMP_I"
    id: "${devicename}_load_output_internal_circulation_pump_pump_i"
    icon: mdi:pump
    register_type: holding
    address: 0x81
    bitmask: 0x8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output SV 1"
    id: "${devicename}_load_output_sv1"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output SV 2"
    id: "${devicename}_load_output_sv2"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x81
    bitmask: 0x20
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output External Circulation Pump PUMP_O"
    id: "${devicename}_load_output_external_circulation_pump_pump_o"
    icon: mdi:pump
    register_type: holding
    address: 0x81
    bitmask: 0x40
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Water Return Water Pump PUMP_D"
    id: "${devicename}_load_output_water_return_water_pump_d"
    icon: mdi:pump
    register_type: holding
    address: 0x81
    bitmask: 0x80
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Mixed Water Pump PUMP_C"
    id: "${devicename}_load_output_mixed_water_pump_pump_c"
    icon: mdi:pump
    register_type: holding
    address: 0x81
    bitmask: 0x100
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output SV 3"
    id: "${devicename}_load_output_sv3"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x200
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output HEAT 4"
    id: "${devicename}_load_output_heat4"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x400
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Solar Water Pump PUMP_S"
    id: "${devicename}_load_output_solar_water_pump_pump_s"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x800
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output ALARM"
    id: "${devicename}_load_output_alarm"
    icon: mdi:eye
    register_type: holding
    entity_category: diagnostic
    address: 0x81
    bitmask: 0x1000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output RUN"
    id: "${devicename}_load_output_run"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x2000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output Auxiliary Heat Source"
    id: "${devicename}_load_output_auxiliary_heat_source"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x4000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Load Output DEFROST"
    id: "${devicename}_load_output_defrost"
    icon: mdi:eye
    register_type: holding
    address: 0x81
    bitmask: 0x8000

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit Online Status: Reserved BIT 0"
    id: "${devicename}_slave_unit_online_status_reserved_bit_0"
    icon: mdi:head-question-outline
    register_type: holding
    address: 0x8e
    bitmask: 0x1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 1 Online Status"
    id: "${devicename}_slave_unit_1_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x2
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 2 Online Status"
    id: "${devicename}_slave_unit_2_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x4
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 3 Online Status"
    id: "${devicename}_slave_unit_3_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x8
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 4 Online Status"
    id: "${devicename}_slave_unit_4_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 5 Online Status"
    id: "${devicename}_slave_unit_5_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x20
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 6 Online Status"
    id: "${devicename}_slave_unit_6_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x40
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 7 Online Status"
    id: "${devicename}_slave_unit_7_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x80
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 8 Online Status"
    id: "${devicename}_slave_unit_8_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x100
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 9 Online Status"
    id: "${devicename}_slave_unit_9_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x200
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 10 Online Status"
    id: "${devicename}_slave_unit_10_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x400
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 11 Online Status"
    id: "${devicename}_slave_unit_11_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x800
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 12 Online Status"
    id: "${devicename}_slave_unit_12_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x1000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 13 Online Status"
    id: "${devicename}_slave_unit_13_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x2000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 14 Online Status"
    id: "${devicename}_slave_unit_14_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x4000
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Slave Unit 15 Online Status"
    id: "${devicename}_slave_unit_15_online_status"
    icon: mdi:eye
    register_type: holding
    address: 0x8e
    bitmask: 0x8000

  - platform: template
    name: "Parameter Setting 1 T1S Heating High Low Temperature Settings"
    id: "${devicename}_parameter_setting_1_t1s_heating_high_low_temperature_settings"
    icon: mdi:eye
    lambda: "return (id(unmasked_value_register_210) & 0x40) == 0x40; // Return status bit6"
  - platform: template
    name: "Parameter Setting 1 T1s Cooling High Low Temperature Settings"
    id: "${devicename}_parameter_setting_1_t1s_cooling_high_low_temperature_settings"
    icon: mdi:eye
    lambda: "return (id(unmasked_value_register_210) & 0x100) == 0x100; // Return status bit8"
  - platform: template
    name: "Parameter Setting 1 Reserved BIT 11"
    id: "${devicename}_parameter_setting_1_reserved_bit_11"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_210) & 0x800) == 0x800; // Return status bit11"
  - platform: template
    name: "Parameter Setting 1 Supports Water Tank Electric Heater TBH"
    id: "${devicename}_parameter_setting_1_supports_water_tank_electric_heater_tbh"
    icon: mdi:eye
    lambda: "return (id(unmasked_value_register_210) & 0x4000) == 0x4000; // Return status bit14"

  - platform: template
    name: "Parameter Setting 2 Reserved BIT 15"
    id: "${devicename}_parameter_setting_2_reserved_bit_15"
    icon: mdi:head-question-outline
    lambda: "return (id(unmasked_value_register_211) & 0x8000) == 0x8000; // Return status bit15"

  - platform: template
    name: "Heat pump running"
    id: "${devicename}_heat_pump_running"
    icon: mdi:power
    lambda: |-
      int fan_speed = id(${devicename}_fan_speed).state;
      int compressor_frequency = id(${devicename}_compressor_operating_frequency).state;
      bool external_water_pump_on = id(${devicename}_load_output_external_circulation_pump_pump_o).state;

      // If fan_speed is above 0, compressor_frequency is above 0 or external_water_pump_on is true,
      // then the outside unit of the heat pump system is running
      if (fan_speed > 0 || compressor_frequency > 0 || external_water_pump_on) {
          return true;
      } else {
          return false;
      }

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status TBH Enabled"
    id: "${devicename}_status_tbh_enabled"
    register_type: holding
    address: 0xC6
    bitmask: 0x8000    # BIT15
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status AHS Enabled"
    id: "${devicename}_status_ahs_enabled"
    register_type: holding
    address: 0xC6
    bitmask: 0x4000    # BIT14
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Reserved BIT 13"
    id: "${devicename}_status_reserved_bit_13"
    register_type: holding
    address: 0xC6
    bitmask: 0x2000    # BIT13
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status T1B Enabled"
    id: "${devicename}_status_t1b_enabled"
    register_type: holding
    address: 0xC6
    bitmask: 0x1000    # BIT12
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status AHS Mode"
    id: "${devicename}_status_ahs_mode"
    register_type: holding
    address: 0xC6
    bitmask: 0x0800    # BIT11
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status IBH Enabled"
    id: "${devicename}_status_ibh_enabled"
    register_type: holding
    address: 0xC6
    bitmask: 0x0400    # BIT10
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status T1 Enabled"
    id: "${devicename}_status_t1_enabled"
    register_type: holding
    address: 0xC6
    bitmask: 0x0200    # BIT9
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Energy Metering Enabled"
    id: "${devicename}_status_energy_metering_enabled"
    register_type: holding
    address: 0xC6
    bitmask: 0x0100    # BIT8
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Reserved BIT 7"
    id: "${devicename}_status_reserved_bit_7"
    register_type: holding
    address: 0xC6
    bitmask: 0x0080    # BIT7
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Reserved BIT 6"
    id: "${devicename}_status_reserved_bit_6"
    register_type: holding
    address: 0xC6
    bitmask: 0x0040    # BIT6
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status DHW Operation"
    id: "${devicename}_status_dhw_operation"
    register_type: holding
    address: 0xC6
    bitmask: 0x0020    # BIT5
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Heating Operation"
    id: "${devicename}_status_heating_operation"
    register_type: holding
    address: 0xC6
    bitmask: 0x0010    # BIT4
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Cooling Operation"
    id: "${devicename}_status_cooling_operation"
    register_type: holding
    address: 0xC6
    bitmask: 0x0008    # BIT3
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Reserved BIT 2"
    id: "${devicename}_status_reserved_bit_2"
    register_type: holding
    address: 0xC6
    bitmask: 0x0004    # BIT2
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Reserved BIT 1"
    id: "${devicename}_status_reserved_bit_1"
    register_type: holding
    address: 0xC6
    bitmask: 0x0002    # BIT1
    entity_category: diagnostic
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Status Reserved BIT 0"
    id: "${devicename}_status_reserved_bit_0"
    register_type: holding
    address: 0xC6
    bitmask: 0x0001    # BIT0
    entity_category: diagnostic
switch:
  - platform: factory_reset
    name: Restart with Factory Default Settings
    id: "${devicename}_restart_with_factory_default_settings"
    icon: mdi:restart-alert
  - platform: template
    name: "Room Temperature Control"
    id: "${devicename}_room_temperature_control"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_0) & 0x1) == 0x1;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to on power_air_conditioner_zone_1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to off power_air_conditioner_zone_1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Water Flow Temperature Control Zone 1"
    id: "${devicename}_water_flow_temperature_control_zone_1"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_0) & 0x2) == 0x2; // Return bit 0x2 status"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x2;                          // Affected bit number
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            // Write new value to heatpump if changed
            // ESP_LOGD("unmasked_value_register_0", "Set option to on power_heat_cool_control_zone1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to off power_heat_cool_control_zone1 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Power DHW T5S"
    id: "${devicename}_power_dhw_t5s"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: |-
      return (id(unmasked_value_register_0) & 0x4) == 0x4;
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to on power_dhw_t5s 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to off power_dhw_t5s 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Water Flow Temperature Control Zone 2"
    id: "${devicename}_water_flow_temperature_control_zone_2"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_0) & 0x8) == 0x8;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to on power_air_conditioner_zone_2 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_0);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_0)) {
            // ESP_LOGD("unmasked_value_register_0", "Set option to off power_air_conditioner_zone_2 0x%x -> 0x%x", id(unmasked_value_register_0), new_value);
            id(unmasked_value_register_0) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x0, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Function Setting Disinfect"
    id: "${devicename}_function_setting_disinfect"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x10) == 0x10; // Return status bit 4"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x10;                         // Bit to change
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on f_s_disinfect 0x%x -> 0x%xs", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x10;                         // Bit to change
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off f_s_disinfect 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Function Setting Silent Mode"
    id: "${devicename}_function_setting_silent_mode"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x40) == 0x40;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on f_s_silent_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off f_s_silent_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Function Setting Silent Mode Level"
    id: "${devicename}_function_setting_silent_mode_level"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x80) == 0x80;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on f_s_silent_mode_level 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off f_s_silent_mode_level 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Function Setting Holiday Home"
    id: "${devicename}_function_setting_holiday_home"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x100) == 0x100;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on f_s_holiday_home 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off f_s_holiday_home 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Function Setting ECO Mode"
    id: "${devicename}_function_setting_eco_mode"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x400) == 0x400;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on f_s_eco_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off f_s_eco_mode 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Function Setting DHW Pumps Running Constant Temperature Water Recycling"
    id: "${devicename}_function_setting_dhw_pumps_running_constant_temperature_water_recycling"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x800) == 0x800;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on f_s_dhw_pumps_running_constant_temperature_water_recycling 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off f_s_dhw_pumps_running_constant_temperature_water_recycling 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Weather Compensation Zone 1"
    id: "${devicename}_weather_compensation_zone_1"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x1000) == 0x1000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on weather_compensation_zone_1 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off weather_compensation_zone_1 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Weather Compensation Zone 2"
    id: "${devicename}_weather_compensation_zone_2"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_5) & 0x2000) == 0x2000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to on weather_compensation_zone_2 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_5);  // The original unmasked value
          new_value &= ~checked_bit;                           //Clear and set
          if ((new_value) != id(unmasked_value_register_5)) {
            // ESP_LOGD("unmasked_value_register_5", "Set option to off weather_compensation_zone_2 0x%x -> 0x%x", id(unmasked_value_register_5), new_value);
            id(unmasked_value_register_5) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 5, new_value);
            ${devicename}->queue_command(set_payload_command);
          }

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Forced Water Tank Heating"
    id: "${devicename}_forced_water_tank_heating"
    icon: mdi:fire-alert
    address: 0x7
    register_type: holding
    entity_category: config
    write_lambda: |-
      uint16_t value = 0;

      if (x == 1) {
        // ESP_LOGI("main", "Set forced water tank heating ON");
        value = 1;
      } else {
        // ESP_LOGI("main", "Set forced water tank heating OFF");
        value = 2;
      }

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x7, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Forced Tank Backup Heater"
    id: "${devicename}_forced_tbh"
    icon: mdi:fire-alert
    address: 0x8
    register_type: holding
    entity_category: config
    write_lambda: |-
      uint16_t value = 0;

      if (x == 1) {
        // ESP_LOGI("main", "Set forced tank backup heater ON");
        value = 1;
      } else {
        // ESP_LOGI("main", "Set forced tank backup heater OFF");
        value = 2;
      }

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x8, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  - platform: template
    name: "Parameter Setting 1 Heating And Cooling First Or Water First"
    id: "${devicename}_parameter_setting_1_heating_and_cooling_first_or_water_first"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x1) == 0x1;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to on p_s_1_heating_and_cooling_first_or_water_first 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to off p_s_1_heating_and_cooling_first_or_water_first 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Dual Room Thermostat Supported"
    id: "${devicename}_parameter_setting_1_dual_room_thermostat_supported"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x2) == 0x2;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to on p_s_1_dual_room_thermostat_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to off p_s_1_dual_room_thermostat_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Room Thermostat"
    id: "${devicename}_parameter_setting_1_room_thermostat"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x4) == 0x4;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to on p_s_1_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to off p_s_1_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Supports Room Thermostat"
    id: "${devicename}_parameter_setting_1_supports_room_thermostat"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x8) == 0x8;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to on p_s_1_supports_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to off p_s_1_supports_room_thermostat 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Supports Room Temperature Sensor Ta"
    id: "${devicename}_parameter_setting_1_supports_room_temperature_sensor_ta"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x10) == 0x10;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to on p_s_1_supports_room_temperature_sensor_ta 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGD("unmasked_value_register_210", "Set option to off p_s_1_supports_room_temperature_sensor_ta 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 PUMPI silent mode"
    id: "${devicename}_pumpi_silent_mode"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x20) == 0x20;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_silent_mode_pump_i 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_silent_mode_pump_i 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Enable Heating"
    id: "${devicename}_parameter_setting_1_enable_heating"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x80) == 0x80;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_enable_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_enable_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Enable Cooling"
    id: "${devicename}_parameter_setting_1_enable_cooling"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x200) == 0x200;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_enable_cooling 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_enable_cooling 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 DHW Pump Supports Pipe Disinfect"
    id: "${devicename}_parameter_setting_1_dhw_pump_supports_pipe_disinfect"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x400) == 0x400;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_dhw_pump_supports_pipe_disinfect 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_dhw_pump_supports_pipe_disinfect 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 DHW Pump Supported"
    id: "${devicename}_parameter_setting_1_dhw_pump_supported"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x1000) == 0x1000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_dhw_pump_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_dhw_pump_supported 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Supports Disinfection"
    id: "${devicename}_parameter_setting_1_supports_disinfection"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x2000) == 0x2000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_supports_disinfection 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_supports_disinfection 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 1 Enable Water Heating"
    id: "${devicename}_parameter_setting_1_enable_water_heating"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_210) & 0x8000) == 0x8000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x8000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to on p_s_1_enable_water_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x8000;
          uint16_t new_value = id(unmasked_value_register_210);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_210)) {
            // ESP_LOGI("unmasked_value_register_210", "Set option to off p_s_1_enable_water_heating 0x%x -> 0x%x", id(unmasked_value_register_210), new_value);
            id(unmasked_value_register_210) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 210, new_value);
            ${devicename}->queue_command(set_payload_command);
          }

  - platform: template
    name: "Parameter Setting 2 IBH AHS Installation Position"
    id: "${devicename}_parameter_setting_2_ibh_ahs_installation_position"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x1) == 0x1;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Tbt Sensor Enable"
    id: "${devicename}_parameter_setting_2_tbt_sensor_enable"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x2) == 0x2;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_tbt_sensor_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x2;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_tbt_sensor_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Ta Sensor Position"
    id: "${devicename}_parameter_setting_2_ta_sensor_position"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x4) == 0x4;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_ta_sensor_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x4;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to off p_s_2_ta_sensor_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Double Zone Setting Is Valid"
    id: "${devicename}_parameter_setting_2_double_zone_setting_is_valid"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x8) == 0x8;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGI("unmasked_value_register_211", "Set option to on p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x8;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_ibh_ahs_installation_position 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Setting The High Low Temperature Of Heating Mode T1S"
    id: "${devicename}_parameter_setting_2_setting_the_high_low_temperature_of_heating_mode_t1s"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x10) == 0x10;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x10;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_setting_the_high_low_temperature_of_heating_mode_t1s 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Setting The High Low Temperature Of Cooling Mode T1S"
    id: "${devicename}_parameter_setting_2_setting_the_high_low_temperature_of_cooling_mode_t1s"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x20) == 0x20;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x20;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Tw2 Enabled"
    id: "${devicename}_parameter_setting_2_tw2_enabled"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x40) == 0x40;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x40;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Smart Grid"
    id: "${devicename}_parameter_setting_2_smart_grid"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x80) == 0x80;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x80;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Port Definition"
    id: "${devicename}_parameter_setting_2_port_definition"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x100) == 0x100;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x100;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Solar Energy Kit Enable"
    id: "${devicename}_parameter_setting_2_solar_energy_kit_enable"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x200) == 0x200;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_solar_energy_kit_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x200;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_solar_energy_kit_enable 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Solar Energy Input Port"
    id: "${devicename}_parameter_setting_2_solar_energy_input_port"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x400) == 0x400;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x400;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_smart_grid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Piping Length Selection"
    id: "${devicename}_parameter_setting_2_piping_length_selection"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x800) == 0x800;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_piping_length_selection 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x800;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_piping_length_selection 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Tbt2 Sensor Is Valid"
    id: "${devicename}_parameter_setting_2_tbt2_sensor_is_valid"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x1000) == 0x1000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_tbt2_sensor_is_valid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_tbt2_sensor_is_valid 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 Enable Temperature Collection Kit"
    id: "${devicename}_parameter_setting_2_enable_temperature_collection_kit"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x2000) == 0x2000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_enable_temperature_collection_kit 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x2000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_enable_temperature_collection_kit 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
  - platform: template
    name: "Parameter Setting 2 M1M2 Is Used For AHS Control"
    id: "${devicename}_parameter_setting_2_m1m2_is_used_for_ahs_control"
    icon: mdi:eye
    restore_mode: DISABLED
    entity_category: config
    optimistic: true
    lambda: "return (id(unmasked_value_register_211) & 0x4000) == 0x4000;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x4000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to on p_s_2_m1m2_is_used_for_ahs_control 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x4000;
          uint16_t new_value = id(unmasked_value_register_211);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_211)) {
            // ESP_LOGD("unmasked_value_register_211", "Set option to off p_s_2_m1m2_is_used_for_ahs_control 0x%x -> 0x%x", id(unmasked_value_register_211), new_value);
            id(unmasked_value_register_211) = new_value;
            esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 211, new_value);
            ${devicename}->queue_command(set_payload_command);
          }

  - platform: template
    name: "EnSwitchPDC"
    id: "${devicename}_enswitchpdc"
    icon: mdi:eye
    entity_category: config
    restore_mode: DISABLED
    optimistic: true
    lambda: "return (id(unmasked_value_register_274) & 0x1) == 0x1;"
    on_turn_on:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_274);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          new_value += checked_bit;
          if ((new_value) != id(unmasked_value_register_274)) {
            id(unmasked_value_register_274) = new_value;

            esphome::modbus_controller::ModbusCommandItem set_payload_command =
              esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
                ${devicename},
                274,
                new_value
              );
            ${devicename}->queue_command(set_payload_command);
          }
    on_turn_off:
      - lambda: |-
          uint16_t checked_bit = 0x1;
          uint16_t new_value = id(unmasked_value_register_274);  // The original unmasked value
          new_value &= ~checked_bit;                             // Clear and set
          if ((new_value) != id(unmasked_value_register_274)) {
            id(unmasked_value_register_274) = new_value;

            esphome::modbus_controller::ModbusCommandItem set_payload_command =
              esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
                ${devicename},
                274,
                new_value
              );
            ${devicename}->queue_command(set_payload_command);
          }
number:
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set Water Temperature T1S Zone 1"
    id: "${devicename}_set_water_temperature_t1s_zone_1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x2
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 5
    max_value: 60
    mode: slider
    lambda: |-
      // Update the global var unmasked_value_water_temperature_t1s
      id(unmasked_value_water_temperature_t1s) = x;

      // ESP_LOGI("","unmasked_value_water_temperature_t1s: %d",id(unmasked_value_water_temperature_t1s));
      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)
      // ESP_LOGI("Register 2Low","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);
      return value_bytes[1];
    write_lambda: |-
      uint16_t value = id(unmasked_value_water_temperature_t1s); // The original unmasked value
      uint8_t value_byte = x;                                    // New byte value with the new temp for zone 1
      value &= 0xFF00;      // Clear the lower byte of the value
      value |= value_byte;  // Update the lower byte with the new byte value

      // ESP_LOGI("Register 6Low, set_water_temperature_t1s_zone_1", "Set option to %f, Original value 0x%x New value: 0x%x", float(x), id(unmasked_value_water_temperature_t1s), value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x2, value);
      ${devicename}->queue_command(set_payload_command);
      id(unmasked_value_water_temperature_t1s) = value;
      return {};

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set Water Temperature T1S Zone 2"
    id: "${devicename}_set_water_temperature_t1s_zone_2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x2
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 5
    max_value: 60
    mode: slider
    lambda: |-
      // The global var unmasked_value_water_temperature_t1s is already
      // updated in the previous, where the low byte variant is executed
      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)
      // ESP_LOGD("Register 2High","Zone 1 is %d    Zone 2 is %d", value_bytes[1], value_bytes[0]);
      return value_bytes[0];
    write_lambda: |-
      uint16_t value = id(unmasked_value_water_temperature_t1s); // The original unmasked value
      uint8_t value_byte = x;                                    // New byte value with the new temp for zone 2
      value &= 0x00FF;             // Clear the upper byte of the value
      value |= (value_byte << 8);  // Update the upper byte with the new byte value

      // ESP_LOGD("set_water_temperature_t1s_zone_2", "Set option to %f, Original value 0x%x New value: 0x%x", float(x), id(unmasked_value_water_temperature_t1s), value);
      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x2, value);
      ${devicename}->queue_command(set_payload_command);
      id(unmasked_value_water_temperature_t1s) = value;
      return {};

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Air Temperature Ts"
    id: "${devicename}_air_temperature_ts"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x3
    value_type: U_WORD
    unit_of_measurement: "°C"
    entity_category: config
    device_class: temperature
    min_value: 17
    max_value: 30
    step: 0.5
    mode: slider
    lambda: |-
      return x * 0.5;
    write_lambda: |-
      return x * 2.0;

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Set DHW Tank Temperature T5s"
    id: "${devicename}_set_dhw_tank_temperature_t5s"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x4
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 20
    max_value: 65
    mode: slider

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Weather Compensation Curve Zone 1"
    id: "${devicename}_weather_compensation_curve_zone_1"
    icon: mdi:eye
    register_type: holding
    address: 0x6
    value_type: U_WORD
    entity_category: config
    min_value: 1
    max_value: 9
    mode: slider
    lambda: |-
      // Update the global var unmasked_curve_selection
      id(unmasked_curve_selection) = x;

      // ESP_LOGI("","unmasked_curve_selection: %d",id(unmasked_curve_selection));

      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)

      // ESP_LOGI("","Zone 1 is %d", value_bytes[1]);
      // ESP_LOGI("","Zone 2 is %d", value_bytes[0]);

      return value_bytes[1];
    write_lambda: |-
      uint16_t value = id(unmasked_curve_selection); // The original unmasked value
      uint8_t value_byte = x;                        // New byte value with the new temp for zone 1

      value &= 0xFF00;      // Clear the lower byte of the value
      value |= value_byte;  // Update the lower byte with the new byte value

      // ESP_LOGI("main", "Original value: %d", id(unmasked_curve_selection));
      // ESP_LOGI("main", "New value: %d", value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x6, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Weather Compensation Curve Zone 2"
    id: "${devicename}_weather_compensation_curve_zone_2"
    icon: mdi:eye
    register_type: holding
    address: 0x6
    value_type: U_WORD
    entity_category: config
    min_value: 1
    max_value: 9
    mode: slider
    lambda: |-
      // The global var unmasked_curve_selection is already
      // updated in the previous, where the low byte variant is executed
      // id(unmasked_curve_selection) = x;

      uint8_t value_bytes[2];
      uint16_t value = x;
      value_bytes[0] = value >> 8;     // high byte (zone 2)
      value_bytes[1] = value & 0x00FF; // low byte (zone 1)

      return value_bytes[0];
    write_lambda: |-
      uint16_t value = id(unmasked_curve_selection); // The original unmasked value
      uint8_t value_byte = x;                        // New byte value with the new temp for zone 2

      value &= 0x00FF;             // Clear the upper byte of the value
      value |= (value_byte << 8);  // Update the upper byte with the new byte value

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x6, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DHW Pump Return Running Time"
    id: "${devicename}_dhw_pump_return_running_time"
    icon: mdi:clock-check-outline
    register_type: holding
    address: 0xd1
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 5
    max_value: 120
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT5_On"
    id: "${devicename}_dt5_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd4
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 1
    max_value: 30
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT1S5"
    id: "${devicename}_dt1s5"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd5
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 5
    max_value: 40
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4 DHW max"
    id: "${devicename}_t4_dhw_max"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd7
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 35
    max_value: 46
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4 DHW min"
    id: "${devicename}_t4dhwmin"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xd8
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -25
    max_value: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t TBH Delay"
    id: "${devicename}_t_tbh_delay"
    icon: mdi:camera-timer
    register_type: holding
    address: 0xd9
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 0
    max_value: 240
    step: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT5 TBH Off"
    id: "${devicename}_dt5_tbh_off"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xda
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 0
    max_value: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4 TBH On"
    id: "${devicename}_t4_tbh_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xdb
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -5
    max_value: 20
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature For Disinfection Operation"
    id: "${devicename}_t5s_di"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xdc
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 60
    max_value: 70
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Maximum Disinfection Duration"
    id: "${devicename}_t_di_max"
    icon: mdi:clock
    register_type: holding
    address: 0xdd
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 90
    max_value: 300
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Disinfection High Temperature Duration"
    id: "${devicename}_t_di_hightemp"
    icon: mdi:clock
    register_type: holding
    address: 0xde
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 5
    max_value: 60
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT1SC"
    id: "${devicename}_dt1sc"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe0
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 2
    max_value: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dTSC"
    id: "${devicename}_dtsc"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe1
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 1
    max_value: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4cmax"
    id: "${devicename}_t4cmax"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe2
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 35
    max_value: 52
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4cmin"
    id: "${devicename}_t4cmin"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe3
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -5
    max_value: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Time Interval Of Compressor Startup In Heating mode"
    id: "${devicename}_t_interval_h"
    icon: mdi:clock
    register_type: holding
    address: 0xe4
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 5
    max_value: 60
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dT1SH"
    id: "${devicename}_dt1sh"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe5
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 2
    max_value: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "dTSH"
    id: "${devicename}_dtsh"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe6
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 1
    max_value: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4hmax"
    id: "${devicename}_t4hmax"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe7
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 20
    max_value: 35
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4hmin"
    id: "${devicename}_t4hmin"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe8
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -25
    max_value: 5
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ambient Temperature For Enabling Hydraulic Module Auxiliary Electric Heating IBH"
    id: "${devicename}_t4_ibh_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xe9
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -15
    max_value: 30
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Return Difference For Enabling The Hydraulic Module Auxiliary IBH"
    id: "${devicename}_dt1_ibh_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xea
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 1
    max_value: 7
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Delay Time Of Enabling The Hydraulic Module Auxiliary Electric Heating IBH"
    id: "${devicename}_t_ibh_delay"
    icon: mdi:camera-timer
    register_type: holding
    address: 0xeb
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 15
    max_value: 120
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ambient Temperature Trigger For AHS"
    id: "${devicename}_t4_ahs_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xed
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -15
    max_value: 10
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Trigger Temperature Difference Between T1S And Current Heat for AHS"
    id: "${devicename}_dt1_ahs_on"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xee
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 1
    max_value: 7
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Delay Time for Enabling AHS"
    id: "${devicename}_t_ahs_delay"
    icon: mdi:camera-timer
    register_type: holding
    address: 0xf0
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 5
    max_value: 120
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Water Heating Max Duration"
    id: "${devicename}_t_dhwhp_max"
    icon: mdi:clock-check-outline
    register_type: holding
    address: 0xf1
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 10
    max_value: 600
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T DHWHP Restrict"
    id: "${devicename}_t_dhwhp_restrict"
    icon: mdi:clock-check-outline
    register_type: holding
    address: 0xf2
    value_type: U_WORD
    unit_of_measurement: min
    entity_category: config
    min_value: 10
    max_value: 600
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4autocmin"
    id: "${devicename}_t4autocmin"
    icon: mdi:thermometer
    register_type: holding
    address: 0xf3
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 20
    max_value: 29
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4autohmax"
    id: "${devicename}_t4autohmax"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xf4
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 10
    max_value: 17
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Heating Or Cooling Temperature When Holiday Mode Is Active"
    id: "${devicename}_t1s_h_a_h"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xf5
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 20
    max_value: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Domestic Hot Water Temperature When Holiday Mode is Active"
    id: "${devicename}_t5s_h_a_dhw"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0xf6
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 20
    max_value: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Rise Day Number"
    id: "${devicename}_t_dryup"
    icon: mdi:calendar-week
    register_type: holding
    address: 0xff
    value_type: U_WORD
    entity_category: config
    min_value: 4
    max_value: 15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Drying Day Number"
    id: "${devicename}_t_highpeak"
    icon: mdi:calendar-week
    register_type: holding
    address: 0x100
    value_type: U_WORD
    entity_category: config
    min_value: 3
    max_value: 7
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Temperature Drop Day Number"
    id: "${devicename}_t_dryd"
    icon: mdi:calendar-week
    register_type: holding
    address: 0x101
    value_type: U_WORD
    entity_category: config
    min_value: 4
    max_value: 15
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Highest Drying Temperature"
    id: "${devicename}_t_drypeak"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x102
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 30
    max_value: 55
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Running Time Of Floor Heating For The First Time"
    id: "${devicename}_t_firstfh"
    icon: mdi:clock-check-outline
    register_type: holding
    address: 0x103
    value_type: U_WORD
    unit_of_measurement: hr
    entity_category: config
    min_value: 48
    max_value: 96
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1S Of Floor Heating For The First Time"
    id: "${devicename}_t1s_firstfh"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x104
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 25
    max_value: 35
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetC1"
    id: "${devicename}_t1setc1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x105
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 5
    max_value: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetC2"
    id: "${devicename}_t1setc2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x106
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 5
    max_value: 25
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4C1"
    id: "${devicename}_t4c1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x107
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -5
    max_value: 46
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4C2"
    id: "${devicename}_t4c2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x108
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -5
    max_value: 46
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetH1"
    id: "${devicename}_t1seth1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x109
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 25
    max_value: 80
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T1SetH2"
    id: "${devicename}_t1seth2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x10a
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: 25
    max_value: 80
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4H1"
    id: "${devicename}_t4h1"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x10b
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -25
    max_value: 35
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "T4H2"
    id: "${devicename}_t4h2"
    icon: mdi:temperature-celsius
    register_type: holding
    address: 0x10c
    value_type: S_WORD
    unit_of_measurement: "°C"
    device_class: "temperature"
    entity_category: config
    min_value: -25
    max_value: 35
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t_T4 FRESH_H"
    id: "${devicename}_t_t4_fresh_h"
    icon: mdi:clock-check-outline
    register_type: holding
    address: 0x10e
    value_type: U_WORD
    unit_of_measurement: hr
    entity_category: config
    min_value: 0.5
    max_value: 6.0
    step: 0.5
    mode: slider
    lambda: |-
      // Update the global var unmasked_value_register_270
      id(unmasked_value_register_270) = x;

      float value_floats[2];
      uint16_t value = x;

      // Extracting the high byte (Cooling) and storing it as a float
      value_floats[0] = (float)(value >> 8) * 0.5;

      // Extracting the low byte (Heating) and storing it as a float
      value_floats[1] = (float)(value & 0x00FF) * 0.5;

      // ESP_LOGI("","t_T4 FRESH_H is %f", value_floats[1]);
      // ESP_LOGI("","t_T4 FRESH_C is %f", value_floats[0]);

      return value_floats[1];
    write_lambda: |-
      uint16_t value = id(unmasked_value_register_270); // The original unmasked value
      float input = x * 2.0;                            // Multiply x (the input from the slider) by 2

      // Multiply the input from the slider (x) by by
      // and convert to uint8_t
      uint8_t input_byte = static_cast<uint8_t>(x * 2.0);

      value &= 0xFF00;      // Clear the lower byte of the value
      value |= input_byte;  // Update the lower byte with the new byte value

      // ESP_LOGI("main", "Original value: %d", id(unmasked_value_register_270));
      // ESP_LOGI("main", "New value: %d", value);

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x10e, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "t_T4 FRESH_C"
    id: "${devicename}_t_t4_fresh_c"
    icon: mdi:clock-check-outline
    register_type: holding
    address: 0x10e
    value_type: U_WORD
    unit_of_measurement: hr
    entity_category: config
    min_value: 0.5
    max_value: 6.0
    step: 0.5
    mode: slider
    lambda: |-
      // Update the global var unmasked_value_register_270
      id(unmasked_value_register_270) = x;

      float value_floats[2];
      uint16_t value = x;

      // Extracting the high byte (Cooling) and storing it as a float
      value_floats[0] = (float)(value >> 8) * 0.5;

      // Extracting the low byte (Heating) and storing it as a float
      value_floats[1] = (float)(value & 0x00FF) * 0.5;

      return value_floats[0];
    write_lambda: |-
      uint16_t value = id(unmasked_value_register_270); // The original unmasked value
      float input = x * 2.0;                            // Multiply x (the input from the slider) by 2

      // Multiply the input from the slider (x) by by
      // and convert to uint8_t
      uint8_t input_byte = static_cast<uint8_t>(x * 2.0);

      value &= 0x00FF;             // Clear the upper byte of the value
      value |= (input_byte << 8);  // Update the upper byte with the new byte value

      esphome::modbus_controller::ModbusCommandItem set_payload_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(${devicename}, 0x10e, value);
      ${devicename}->queue_command(set_payload_command);

      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Built-in Circulating Pump Delay"
    id: "${devicename}_t_delay_pump"
    icon: mdi:camera-timer
    register_type: holding
    address: 0x10f
    value_type: U_WORD
    unit_of_measurement: min
    multiply: 2.0
    entity_category: config
    min_value: 2.0
    max_value: 20.0
    step: 0.5

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "DELTATSOL Solar Temp Difference"
    id: "${devicename}_deltatsol_temp_diff"
    icon: mdi:thermometer-lines
    address: 0x111   # Register 273
    value_type: U_WORD
    min_value: 5
    max_value: 20
    step: 1
    unit_of_measurement: "°C"
    lambda: |-
      // Store the full, unmasked register value in the global variable
      id(unmasked_value_register_273) = x;

      // Extract bits 8-15 for DELTATSOL (the higher byte)
      uint8_t deltatsol_value = ((int)x >> 8) & 0xFF;
      return (int)deltatsol_value;

    write_lambda: |-
      uint16_t current_reg_val = id(unmasked_value_register_273); // Get the last known full register value
      uint8_t new_deltatsol_byte = x; // 'x' is the new setpoint value (int)

      uint16_t new_value = (current_reg_val & 0x00FF);      // Clear bits 8-15 (DELTATSOL part)
      new_value |= ((uint16_t)new_deltatsol_byte << 8); // Set bits 8-15 with the new value

      esphome::modbus_controller::ModbusCommandItem set_payload_command =
        esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
          ${devicename},
          273,
          new_value
        );
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Gas price"
    id: "${devicename}_gas_price"
    icon: mdi:cash
    register_type: holding
    address: 0x113
    value_type: U_WORD
    unit_of_measurement: float
    multiply: 100
    entity_category: config
    min_value: 0.0
    max_value: 5.0
    step: 0.1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Electricity price"
    id: "${devicename}_electricity_price"
    icon: mdi:cash
    register_type: holding
    address: 0x114
    value_type: U_WORD
    unit_of_measurement: "kWh"
    multiply: 100
    entity_category: config
    min_value: 0.0
    max_value: 5.0
    step: 0.1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "SETHEATER Max Temperature"
    id: "${devicename}_setheater_max_temp"
    icon: mdi:thermometer-chevron-up
    address: 0x115
    value_type: U_WORD   #
    min_value: 0
    max_value: 80
    step: 1
    unit_of_measurement: "°C"
    lambda: |-
      // Store the full, unmasked register value in the global variable
      id(unmasked_value_register_277) = x;

      // Extract the high byte (bits 8-15) for SETHEATER_Max
      uint8_t max_temp_value = ((int)x >> 8) & 0xFF;

      return (float)max_temp_value;
    write_lambda: |-
      uint16_t current_reg_val = id(unmasked_value_register_277); // Get the last known full register value
      uint8_t new_max_temp_byte = (uint8_t)x; // 'x' is the new setpoint (float)

      // Preserve the low byte (SETHEATER_Min) and update the high byte (SETHEATER_Max)
      uint16_t new_value = (current_reg_val & 0x00FF) | ((uint16_t)new_max_temp_byte << 8);

      // Create and return the Modbus write command
      esphome::modbus_controller::ModbusCommandItem set_payload_command =
        esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
          ${devicename},
          277,
          new_value
        );
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "SETHEATER Min Temperature"
    id: "${devicename}_setheater_min_temp"
    icon: mdi:thermometer-chevron-down
    address: 0x115
    value_type: U_WORD
    min_value: 0
    max_value: 80
    step: 1
    unit_of_measurement: "°C"
    lambda: |-
      // Store the full, unmasked register value in the global variable (can be redundant if Max is read often, but safe)
      id(unmasked_value_register_277) = x;

      // Extract the low byte (bits 0-7) for SETHEATER_Min
      uint8_t min_temp_value = (int)x & 0xFF;
      return (float)min_temp_value;
    write_lambda: |-
      uint16_t current_reg_val = id(unmasked_value_register_277); // Get the last known full register value
      uint8_t new_min_temp_byte = (uint8_t)x; // 'x' is the new setpoint (float)

      // Preserve the high byte (SETHEATER_Max) and update the low byte (SETHEATER_Min)
      uint16_t new_value = (current_reg_val & 0xFF00) | (uint16_t)new_min_temp_byte;

      // Create and return the Modbus write command
      esphome::modbus_controller::ModbusCommandItem set_payload_command =
        esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
          ${devicename},
          277,
          new_value
        );
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "SIGHEATER Max Voltage"
    id: "${devicename}_sigheater_max_voltage"
    icon: mdi:alpha-v-box-outline
    address: 0x116
    value_type: U_WORD
    min_value: 0
    max_value: 10
    step: 1
    unit_of_measurement: "V"
    lambda: |-
      // Store the full, unmasked register value in the global variable
      id(unmasked_value_register_278) = x;

      // Extract the high byte (bits 8-15) for SIGHEATER_Max
      uint8_t max_voltage_value = ((int)x >> 8) & 0xFF;

      return (float)max_voltage_value;
    write_lambda: |-
      uint16_t current_reg_val = id(unmasked_value_register_278); // Get the last known full register value
      uint8_t new_max_voltage_byte = (uint8_t)x; // 'x' is the new setpoint (float)

      // Preserve the low byte (SIGHEATER_Min) and update the high byte (SIGHEATER_Max)
      uint16_t new_value = (current_reg_val & 0x00FF) | ((uint16_t)new_max_voltage_byte << 8);

      // Create and return the Modbus write command
      esphome::modbus_controller::ModbusCommandItem set_payload_command =
        esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
          ${devicename},
          278,
          new_value
        );
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "SIGHEATER Min Voltage"
    id: "${devicename}_sigheater_min_voltage"
    icon: mdi:alpha-v-box-outline
    address: 0x116
    value_type: U_WORD
    min_value: 0
    max_value: 10
    step: 1
    unit_of_measurement: "V"
    lambda: |-
      // Store the full, unmasked register value in the global variable
      id(unmasked_value_register_278) = x;

      // Extract the low byte (bits 0-7) for SIGHEATER_Min
      uint8_t min_voltage_value = (int)x & 0xFF;

      return (float)min_voltage_value;
    write_lambda: |-
      uint16_t current_reg_val = id(unmasked_value_register_278); // Get the last known full register value
      uint8_t new_min_voltage_byte = (uint8_t)x; // 'x' is the new setpoint (float)

      // Preserve the high byte (SIGHEATER_Max) and update the low byte (SIGHEATER_Min)
      uint16_t new_value = (current_reg_val & 0xFF00) | (uint16_t)new_min_voltage_byte;

      // Create and return the Modbus write command
      esphome::modbus_controller::ModbusCommandItem set_payload_command =
        esphome::modbus_controller::ModbusCommandItem::create_write_single_command(
          ${devicename},
          278,
          new_value
        );
      ${devicename}->queue_command(set_payload_command);
      return {};
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Valve anti-lock running time"
    id: "${devicename}_t2_anti_svrun"
    icon: mdi:timer-cog-outline
    address: 0x117
    value_type: U_WORD
    unit_of_measurement: "s"
    entity_category: config
    min_value: 0
    max_value: 120
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T1SetC1 Custom Curve Cooling"
    id: "${devicename}_zone_2_t1setc1_custom_curve_cooling"
    icon: mdi:chart-bell-curve
    address: 0x118
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 5
    max_value: 25
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T1SetC2 Custom Curve Cooling"
    id: "${devicename}_zone_2_t1setc2_custom_curve_cooling"
    icon: mdi:chart-bell-curve
    address: 0x119
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 5
    max_value: 25
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T4C1 Custom Curve Cooling"
    id: "${devicename}_zone_2_t4c1_custom_curve_cooling"
    icon: mdi:chart-bell-curve
    address: 0x11A
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 46
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T4C2 Custom Curve Cooling"
    id: "${devicename}_zone_2_t4c2_custom_curve_cooling"
    icon: mdi:chart-bell-curve
    address: 0x11B
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 46
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T1SetH1 Custom Curve Heating"
    id: "${devicename}_zone_2_t1seth1_custom_curve_heating"
    icon: mdi:chart-bell-curve
    address: 0x11C
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 25
    max_value: 80
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T1SetH2 Custom Curve Heating"
    id: "${devicename}_zone_2_t1seth2_custom_curve_heating"
    icon: mdi:chart-bell-curve
    address: 0x11D
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: 25
    max_value: 80
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T4H1 Custom Curve Heating"
    id: "${devicename}_zone_2_t4h1_custom_curve_heating"
    icon: mdi:chart-bell-curve
    address: 0x11E
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -25
    max_value: 35
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Zone 2 T4H2 Custom Curve Heating"
    id: "${devicename}_zone_2_t4h2_custom_curve_heating"
    icon: mdi:chart-bell-curve
    address: 0x11F
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -25
    max_value: 35
    step: 1
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Ta Adjustment Temperature"
    id: "${devicename}_ta_adjustment_temperature"
    icon: mdi:thermometer-lines
    address: 0x120
    value_type: S_WORD
    unit_of_measurement: "°C"
    entity_category: config
    min_value: -5
    max_value: 5
    step: 1
text_sensor:
  - platform: version
    name: "ESPHome Version"
    id: "${devicename}_esphome_version"
    icon: mdi:information
    hide_timestamp: true
  - platform: template
    name: "Active State"
    id: "${devicename}_active_state"
    icon: mdi:power
    entity_category: "diagnostic"
    lambda: |-
      if (id(${devicename}_operating_mode).state != "OFF") {
        if (id(${devicename}_load_output_run).state) {
          // The heat pump is on
          if (id(${devicename}_status_bit_1_defrosting).state) {
            return {"Defrosting"};
          } else if (id(${devicename}_load_output_sv1).state) {
            return {"DHW"};
          } else {
            // Return the state from "Operating Mode", which can be Cooling or Heating
            return id(${devicename}_operating_mode).state;
          }
        } else {
          // The heat pumps operating mode is on (not OFF), but is not "Heating", "Cooling", or "DHW".
          // In this case the heat pump is Idle, which is for example the case when it is preparing for a DHW
          // run or between "Heating" sessions
          return {"Idle"};
        }
      } else {
        // The heat pump is off
        return {"Inactive"};
      }
  - platform: template
    name: "Current Fault Error Code"
    id: "${devicename}_current_fault_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int current_fault = id(${devicename}_current_fault).state;

      // ESP_LOGI("main", "Current fault: %d", current_fault);

      if (current_fault >= 0 && current_fault <= 143) {
        return std::to_string(current_fault);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9
  - platform: template
    name: "Current Fault Error Code Description"
    id: "${devicename}_current_fault_error_code_description"
    icon: "mdi:alert-circle"
    lambda: |-
      int current_fault = id(${devicename}_current_fault).state;

      // ESP_LOGI("main", "Current fault: %d", current_fault);

      if (current_fault >= 0 && current_fault <= 143) {
        return std::to_string(current_fault);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> Water flow fault(E8 displayed 3 times)
          - 2 -> Phase loss or neutral wire and live wire are connected reversely(only for three phase unit)
          - 3 -> Communication fault between controller and hydraulic module
          - 4 -> Final outlet water temp. sensor(T1) fault
          - 5 -> Water tank temp. sensor(T5) fault
          - 6 -> The condenser outlet refrigerant temperature sensor(T3) fault
          - 7 -> The ambient temperature sensor(T4) fault
          - 8 -> Buffer tank up temp. sensor(Tbt1) fault
          - 9 -> Water flow failure
          - 10 -> Suction temp. sensor (Th) fault
          - 11 -> Discharge temp. sensor (Tp) fault
          - 12 -> Solar temp. sensor(Tsolar) fault
          - 13 -> Buffer tank low temp. sensor(Tbt2) fault
          - 14 -> Inlet water temp. sensor(Tw_in) malfunction
          - 15 -> Hydraulic module EEprom failure
          - 20 -> Low pressure switch protection
          - 21 -> High pressure switch protection
          - 23 -> Compressor overcurrent protection
          - 24 -> High discharge temperature protection
          - 25 -> |Tw_out - Tw_in| value too big protection
          - 26 -> Inverter module protection
          - 31 -> Anti-freeze mode
          - 33 -> High temperature protection of refrigerant outlet temp. of condenser
          - 38 -> Tw_out - Tw_in unusual protection
          - 39 -> Communication fault between main board PCB B and main control board of hydraulic module
          - 40 -> Communication fault between inverter module PCB A and main control board PCB B
          - 41 -> Refrigerant liquid temp. sensor(T2) fault
          - 42 -> Refrigerant gas temp. sensor(T2B) fault
          - 43 -> Three times P6(L0/L1) protection
          - 44 -> Room temo. sensor (Ta) fault
          - 45 -> DC fan motor fault
          - 46 -> Voltage protection
          - 47 -> Pressure sensor fault
          - 48 -> Outlet water for zone 2 temp. sensor(Tw2) fault
          - 49 -> Outlet water temp. sensor(Tw_out) fault
          - 50 -> 3 times PP protection and Tw_out<7℃
          - 52 -> Communication fault between hydraulic module parallel
          - 53 -> Communication error between main board and thermostat transfer board
          - 54 -> Inverter module board EE PROM fault
          - 55 -> H6 display 10 times in 2 hours
          - 57 -> Low pressure protection (Pe<0.6) occurred 3 times in 1 hour
          - 65 -> Transducer module temperature too high protection
          - 112 -> PED PCB fault
          - 116 -> Low DC generatrix voltage protection
          - 134 -> Module protection
          - 135 -> DC generatrix low voltage protection
          - 136 -> DC generatrix high voltage protection
          - 138 -> MCE fault
          - 139 -> Zero speed protection
          - 141 -> Phase sequence fault
          - 142 -> Speed difference > 15Hz protection between the front and the back clock
          - 143 -> Speed difference > 15Hz protection between the real and the setting speed
  - platform: template
    name: "Fault 1 Error Code"
    id: "${devicename}_fault_1_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_one = id(${devicename}_fault_1).state;

      if (fault_one >= 0 && fault_one <= 143) {
        return std::to_string(fault_one);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9
  - platform: template
    name: "Fault 2 Error Code"
    id: "${devicename}_fault_2_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_two = id(${devicename}_fault_2).state;

      if (fault_two >= 0 && fault_two <= 143) {
        return std::to_string(fault_two);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9
  - platform: template
    name: "Fault 3 Error Code"
    id: "${devicename}_fault_3_error_code"
    icon: "mdi:alert-circle"
    lambda: |-
      int fault_three = id(${devicename}_fault_3).state;

      if (fault_three >= 0 && fault_three <= 143) {
        return std::to_string(fault_three);
      } else {
        return {"Unknown"};
      }
    filters:
      - map:
          - 0 -> OK
          - 1 -> E0
          - 2 -> E1
          - 3 -> E2
          - 4 -> E3
          - 5 -> E4
          - 6 -> E5
          - 7 -> E6
          - 8 -> E7
          - 9 -> E8
          - 10 -> E9
          - 11 -> EA
          - 12 -> Eb
          - 13 -> Ec
          - 14 -> Ed
          - 15 -> EE
          - 20 -> P0
          - 21 -> P1
          - 23 -> P3
          - 24 -> P4
          - 25 -> P5
          - 26 -> P6
          - 31 -> Pb
          - 33 -> Pd
          - 38 -> PP
          - 39 -> H0
          - 40 -> H1
          - 41 -> H2
          - 42 -> H3
          - 43 -> H4
          - 44 -> H5
          - 45 -> H6
          - 46 -> H7
          - 47 -> H8
          - 48 -> H9
          - 49 -> HA
          - 50 -> Hb
          - 52 -> Hd
          - 53 -> HE
          - 54 -> HF
          - 55 -> HH
          - 57 -> HP
          - 65 -> C7
          - 112 -> bH
          - 116 -> F1
          - 134 -> L0
          - 135 -> L1
          - 136 -> L2
          - 138 -> L4
          - 139 -> L5
          - 141 -> L7
          - 142 -> L8
          - 143 -> L9
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Operating Mode"
    id: "${devicename}_operating_mode"
    icon: mdi:state-machine
    register_type: holding
    address: 0x65
    response_size: 2
    lambda: |-
      int idx = item->offset;
      uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
      std::string output = "Unknown: ";
      output += to_string(rawdata);
      if (rawdata == 0) output = "OFF";
      else if (rawdata == 2) output = "Cooling";
      else if (rawdata == 3) output = "Heating";
      else if (rawdata == 5) output = "DHW Heating";
      // ESP_LOGD("Register 101","Operating mode %s (%d)", output.c_str(), rawdata);
      return output;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Home Appliance Product Code"
    id: "${devicename}_home_appliance_product_code"
    icon: "mdi:information-box-outline"
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    address: 0xc8
    lambda: |-
      int idx = item->offset;
      std::string z = "";
      uint16_t rawdata = (uint16_t(data[idx]) << 8) + uint16_t(data[idx + 1]);
      // ESP_LOGD("Register 200", "The home appliance product code is 0x%x rawdata ", rawdata);
      if (((rawdata & 0x00F0) >> 4) == 4) {
        z = "4";
      } else {
        z = std::to_string((rawdata & 0x00F0) >> 4);
      }
      return {z};

  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Heat Pump Operation Mode"
    id: "${devicename}_heat_pump_operation_mode"
    icon: mdi:heat-pump
    register_type: holding
    address: 0xC7
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("Off");
        case 2: return std::string("Cooling");
        case 3: return std::string("Heating");
        case 5: return std::string("DHW");
        default: return std::string("Invalid");
      }
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "MachineType"
    id: "${devicename}_machinetype"
    register_type: holding
    address: 0xBB
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 06: return std::string("A-R290");
        default: return std::string("Unknown");
      }
      return x;
  - platform: modbus_controller
    modbus_controller_id: "${devicename}"
    name: "Hydraulic Module Sub-Model"
    id: "${devicename}_hydraulic_module_submodel"
    register_type: holding
    address: 0xBE
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      switch (value) {
        case 0: return std::string("R32-P");
        case 1: return std::string("Aqua");
        case 2: return std::string("C-R32-P");
        case 3: return std::string("R290-A");
        case 4: return std::string("R290-N");
        case 5: return std::string("C-R290-A");
        case 6: return std::string("C-R290-N");
        case 7: return std::string("R32-A");
        case 8: return std::string("C-R32-A");
        case 9: return std::string("R290-M");
        case 10: return std::string("R32-H");
        default: return std::string("Unknown");
      }
      return x;
interval:
  - interval: 1h
    then:
      - lambda: |-
          id(compressor_start_count) = 0;

  - interval: 2s
    then:
      - lambda: |-
          static bool was_running = false;
          bool is_running = id(compressor_running).state;

          if (!was_running && is_running) {
            id(compressor_start_count) += 1;
          }

          was_running = is_running;
